,video_id,comments
0,uSMO86uTxo8,"['Glad to see you came back Alive, after the last stream 😅', 'Angular is favored by Google when it comes to SEO. Google goes out of its way to index Angular apps. Some of that effort also applies to any client-side rendered site unless they have some weird routing.', 'The peak was covid phenomenon we are never going back there.', '', 'No need for an expensive camera - that is not what makes you the GOAT for leetcode videos and explanations. Seriously looking forward to the discrete math course and your newsletter !!!', 'the newsletter being simple is great', 'Why is BST top down/bottom up view, and left view not on leetcode? only level order? arent they like super common questions? hackerrank has top down i think tho leetcode lacking', 'the discrete math course will be amazing, cannot wait!', ""Hi bro, I am from India having a year gap of 2 years after my Bachelors and I haven't done any significant internship but currently I am working on DSA and Web Dev.\nHow can I land a job with a meaningful salary?"", ""is it enough to do all these problems from your practice website to be prepared for interviews at MAANG? I got a message from a recruiter from Google on linkedin if I want to come to an interview but I don't feel ready..""]"
1,UrcwDOEBzZE,"['I have a second channel where I solve the daily leetcode problems: https://youtube.com/@neetcodeio\n\nI curated a list of the 150 most important coding interview problems: https://neetcode.io/practice', 'I actually find dynamic programming to be easier than greedy algo. If you understand recursion well from DFS, then you can transform a DP problem into a DFS problem with a memo table. \n\nGreedy, on the other hand, has no consistent design patterns and is truly looking a spark on cleverness.', 'You know, not many people reveal their tricks like this. Thanks man!', 'Everything is a graph', 'Just out of pure curiosity, are you Jew Neetcode?', 'Gotta study those DFS and BFS until they become my breakfast meal.', 'The amazon backpack in the background is a nice easter egg', 'I hate my life. By the way heapify runs in o(logn) time otherwise every operation runs in o(n) time.', '3:02 isnt a tree a DAG. why did you mention it to be undirected?', ""Been doing a lot of interviews lately, admittedly not at MAANG companies, but still F500 companies and honestly haven't had a single coding-style interview in the dozen or so I've had in the last 3 months. Still good to keep these skills sharp incase they come up, but starting to seem less common at the senior level.""]"
2,a3Aep-SygUA,"['In 24 hours we learned that Go might not be the best language for leetcode problems... :^)\n\nThis is my second and hopefully last 24 hour leetcode stream\n\n0:00 - Stream starts\n17:50 - Challenge starts\n24:14:15 - Challenge ends\n\n🧑\u200d💼 Connect with me on LinkedIn: https://www.linkedin.com/in/navdeep-singh-3aaa14161/', 'I just started the video, it’s hurting me to see you migrate from Python 😭😭', 'this can make me learn go faster<<< thanks alot', ""don't watch this video, you will feel lazy :3"", ""21:23:13 ' destroyed in seconds' "", 'Bookmark: 35:00', 'That would be cool if you could add to this channel some videos related to AVL and red-black trees', 'Hello. I really enjoy your content. I purchased NeetCode Lifetime plan but the discord invite link is not working properly. :(', '4:45 , ur goofy asl', 'legend']"
3,e64g-sJAoK0,"['please make videos like this with java', 'i think the biggest problem i have with this is that you are like 2 years into software if you count internships and are giving advice to people like a senior engineer with 10+ years experience. Just because someone gets accepted into google doesnt mean you should just blindly follow them.', '30:50 🤣🤣', 'Dude is a leetcode god', 'You look like an INDIAN. I thought you will look like an British .', 'yes', ""Bro go and sleep don't tire yourself, this series may harm your health. Nothing is more important than your health."", 'what happened with the other live?', 'What happened to the first 18 hours', 'based gopher']"
4,QHXET1G9Y5U,"[""Not trying to bash Amazon or scare people who wanna work there. Just sharing one person's experience.\n\r\nIt's easy to talk about success, but I think you can learn more from failure."", ""I had a very similar experience when I finally got a job as an engineer at Intel. It's very soothing to hear I'm not the only one!!"", 'Bro talks about his life as smoothly as he explains Leetcode problems. Damn', 'Holy shit bro, had no idea you went through this back then. Been watching the LC videos a while.', 'Thanks for sharing! Very inspiring obviously for alot of people!', ""I'm confused why you didn't seek therapy? With the money u were making, u could have easily gotten good therapist"", 'Tf did i just watch', ""I don't think you can rip the bong constantly and do LSD tablets and then give sound advice to people.  Sounds like a dark period full of benders that had nothing to do with the company you worked at.  I hope you find peace."", 'Many months ago, i decided to post on my linkedin (publicly) that i will refuse any interview offer from amazon. I hate the way they do annual performance reviews.', ""Just subscribed to this channel but I've definitely gone through similar experiences at toxic environments like Tesla and dealing with drugs/severe depression as a result. I've thought many times about sharing my experiences but always backed out. Your honesty is very inspiring. More of us need to be real and open about this sort of thing. Thank you""]"
5,JtdB-jiN6O0,"[""What do you guys think? Not bad for a leetcode monkey eh 🐒\n\n\n\nTry it out: https://neetcode.io/problems/dynamicArray\n\nOr view the full list of problems under the 'Basics' tab: https://neetcode.io/practice"", 'Leetcide: -_-', ""This is a super interesting video since I've been looking at the same problems for the past few years."", 'No the Monaco editor syntax highlighting is annoying. I went through the same thing. I switched to CodeMirror because of how complex it was to add your own highlighting config.', 'This is what I wanted to ask  what backend judge0 ( I infact did a poc but was not sure if i should use this), you answered it. This helps.. Thank you very much !', '3:50 This is exactly why I hate web dev😭', 'Hey great content you honestly make me want to leetcode more and I have only been doing side projects and the comment about next js app router hits home I picked it up so fast and it seems easier to me that the page router', '❤', ""Nothing is hard as long as you have time and money to do what you want. Programming is different for everyone and people learn with different pace. You sounded like someone putting above others. Don't be disrespectful cause there are plenty of people copying with imposter syndrome and you are actually making them feel bad. Other than that keep up a good work"", 'YOINK']"
6,l8dpetPPkFQ,"[""This is the problem with Google IMO. They don't even use their own technology (I mean the open source/GCP version of it).\nUnlike Amazon which is literally a customer of AWS. So they don't understand customer pain points."", 'The people that came up with this shit are genius (real computer scientists).\nUs software engineers just copy paste lmao.', 'Sanjay Ghemawat - The OG 🙏', 'Crazy that I was looking up Sergey Brin today and skimming through his paper he wrote introducing Google and in the same day I find this video simply going to your page because I know how influential you are in tech. I forget why I looked up Sergey but I do remember why I looked up your channel because I have to start practicing for tech interviews like yesterday.', 'message broker*. All in all, nice video and cool new info', ""Excellent explanation of Google's internal tools and their corresponding Open source equivalents or Competitors. You are too good at teaching these things...Thanks for posting these and please keep posting such interesting stuff..!!"", ""Funny that this video doesn't mention memegen as the top tool built at Google😂"", 'Accent fix karle', ""4:58 To answer your question about why Google doesn't migrate to the open-source variants of Google-internal tools (e.g., why Google doesn't migrate from Borg to Kubernetes), I believe it's because:\n1. The cost of migration is not worth it — given how much infrastructure and other Google assets (existing SWE knowledge, additional tooling, integrations with other Google-internal tools, etc.) are built on top of the old, Google-internal tool. \n2. Open-source tool roadmaps are steered/influenced by other companies (e.g., Google doesn't have 100% control over what new features Kubernetes will support in the coming years).\nMy guess is that 1 is the main reason — since some Google products DO use open-source tools (i.e., some Google products use Kubernetes).\n(That said, it's hard to make general statements about Google, since Google is so big and each team is actually quite different.)\n\nGreat video, BTW. I learned a ton!"", ""so what's next after quitting google?""]"
7,6pzoo2HXJT8,"[""Btw here's my linkedin: https://www.linkedin.com/in/navdeep-singh-3aaa14161/\n\nI'm not very active on there, but that will change maybe"", 'Just got done watching one of your videos about python, the way you explain and show examples is really helpful, you really have a gift, congrats on your channel getting so popular, I can see why it has!', 'Bravo, theres appears to be alot of ""nothing special"" probably hence the demise of Helpdesk/desktop support and invert of AI...I too have worked with a few smart...', 'Does Youtube make you more money than your Google comp? Or did you decide to settle for lesser comp to do what you love doing?', 'Man, admire you as much, as a mere mortal who needs pushing to work on leetcode :-)', ""Man when you mentioned working with a few people who were just head and shoulders above everyone else... i immediately thought of similar folks who I've had the pleasure of working alongside in the past. And I'm so grateful to have had those opportunities"", 'у тебя вебка не там стоит', ""I envy you. I graduated a couple of years earlier than you, but after covid19, I don't even get interviews from big tech."", 'Thank you sir for your expectational teaching even a person like me was able to become a software engineering because of you. Hope you will succeed in everything you do.', 'Goat talk']"
8,Hp5zAvNQHjE,[]
9,8wysIxzqgPI,"[""Been a long ass time since I uploaded on this channel, I know. Even though I've been uploading on the second channel, I missed you guys over here. 😭\n\nRoadmap: https://neetcode.io/roadmap\nQuiz feature: https://neetcode.io/practice\nSecond channel: https://youtube.com/@neetcodeio"", 'When am I ready to get started on leetcode? Can I start just knowing nothing at all?', 'This video is giving me hope and a strategy, thank you!!', ""I've taken Data Structures and Algorithms I, but now I want to start getting ready for DS&A II. I don't want to forget what I've learned, so I think this is going to be a great way to apply what I was taught. I will be updating in three months to see how my progress is going. Siri is going to remind me every three months from now."", 'I’m using js and Python were should I start ?', 'Best channel ever', 'This video convinced me to start doing Leetcode problems at some point. Thanks', 'I want to become an expert in C++ I refuse to use python to solve leetcode problems, I will use C++', ""i m exactly like you where you was in the part of solving medium question i just can't figure out the trick for the first time, and exactly like you i solve 100 question until this time."", 'You said 50 leetcode problems helped you get an internship at a bank, but how? Once you have developed some mastery of these problems, how do you market such traits to potential employers?']"
10,3A_YMWcx4HI,"[""Am I just coping or do you agree that the hype is a bit overstated?\n\nBtw, I'm not really pro-google on this topic - I spent the last video shitting on their AI strategy -> https://youtu.be/hL0bn_-FKmo"", ""It's silly to think gpt as a a real person ai, it's just a pretty neat and efficient generator of text that's applicable in a general way.  It's useless without a compilation"", '4 GPT is much better and will spit out the correct code in a flash.', 'Quality, vobvise content', 'It cannot solve Leetcode problems. Neither can you\nSo cold😂😂', 'sponsored by google :DDD', ""Maybe not programmers or lawyers or accountants, but it can definitely replace a lot of interns and paralegals and maybe even financial advisors, it's not an expert but it's really good at many things, that said I think GPT-4 is too expensive and slow to be used for most production code right now and hardware has been kind of stagnating these past maybe 10 years so it probably will take a while to happen, still pretty cool tech though."", 'The ""open"" part is your wallet.', 'As a music teacher I searched ‘how to play Chopin’ in ChatGPT. It gave some general instructions (something like keep practicing and learn chromaticism and music theory) but not up to the standard of a good music teacher can do. Then I searched more based on its previous general instructions and then it basically gave me the same advice back. So I think AI is still not able to do very complex tasks in the current state.', 'You brought up a good point about it not being able to do basic arithmetic lol! Language models suck at math, but they happen to be really good at actually coding things up because of the amount of code its been trained on. Some tools being developed out there have GPT use external tools like a calculator to perform actual computations since it has a tendency to hallucinate. Or, if you ask it to write code to do a math problem rather than give you an actual answer, it will suprisingly give you more accurate answers.']"
11,i53Gi_K3o7I,"['Wow! That took so much knowledge to create such simplicity. Thank you.', 'Your awesome thank you!!', ""Hello, it's a very basic topic, I have you got a video with same concept but much moore advanced?"", 'I learned a lot from this video \nthe best thing I learned is : ""don\'t try to understand 20 things at the same time in 10 minutes""   \ngreat video nevertheless', 'CS590 Software Architecture summarized in 10 mins, awesome...this was definitely the most bulky course and you did way better than my professor in explaining', 'Wow! This video is impressively well-crafted, managing to be both concise and thorough simultaneously.', ""yfw when you know almost everything about system design and still don't run billion dollar click farm."", 'Oops I subscribed by mistake 😏😏', '5:27 I see what you did there...\n\n\n\nand I like it!', ""oh my god, i'm halfway through and i just had to stop watching and come here to comments to tell how much i love the video. the way it is structured and how easily and smoothly it takes us from concept to concept, never breaking the flow is just amazing. very well done! thank you SO SO MUCH for putting it out here!""]"
12,hL0bn_-FKmo,"['Correction: Bing will not be using GPT-4, but a different model that is still more advanced than ChatGPT. (I was baited by some fake news)', 'the ending gave an eternal satisfaction', 'My supermarkets are literally 1 cashier and 8 self checkout machines nowadays.', 'Bard is way better and faster, thats why switched from all ChatGPT tools to using Beyond Bard chrome extension.', ""I know this video is from 3 months ago. GPT-4 can now find bugs in your code and hlep you fix them, even in a project with thousands lines of code. Not in a project with hundreds of thousands lines of code yes, but I'm sure they're working on it"", 'the last part hahahahhaa', 'The ending got me...😂😂😂', 'that ending bit 💀', 'last line was most funny🤣🤣 A big life update: I got laid off yesterday yay...', ""Such bollocks I couldn't stop laughing. Bard is fucking useless and will always be a second class GPT because of what ? Because of Google's need for advertising revenue""]"
13,tAuRQs_d9F8,"[""I might've had too much fun with this one, so I hope it's not too vulgar 😅\nAnd let me know if you want more or less of these types of videos!\n\nIf you wanna learn more about Object-Oriented Design, you can checkout my new course at 🚀 https://neetcode.io/ (you also get lifetime access to all current and future courses).\n\nOh, and I made a second YT channel where I've been posting solutions to the daily Leetcode problems:  https://www.youtube.com/@NeetCodeIO"", ""It's amazing. I really liked how easy and fun you taught about complicated concepts. Tbh, I need more explanation to understand some patterns though. I really appreciate it you made this video. Thank you very much!"", 'Can you do one for databases? On a similar format?', 'I think im too early to watch this. Cuz i cant understand sht 😂', 'You’re awesome man', 'I want to buy \nNeetcode premium\nPlease cover more and \nMore interview questions\nFor lld and hld ?', 'what is vegan burger 😳?', 'This video sucks bro honestly... You use Python? Why not explain how the design patterns can be applied as an overall. Your descriptions are horrendous, Your explanation is terrible.. This is TYPICAL developer arrogance. You enjoy showing off but contributing jack. Waste of time.', 'when u said plz subscribe at the end made me subscribe so ty', '2:20 I knew you could use the backslash to extend if statements more than one physical lines but I did not know you could use it in this way too.']"
14,SpOCDsxouJ4,"[""I didn't wanna stretch this video too long, so I kinda rushed over a few parts. So if it's confusing feel free to ask any questions. But happy new years 🎉!\n\nAnyways, what technologies do you guys plan on learning next year? (other than how to invert a binary tree of course)"", 'I would buy an angular course from you.', 'This year, I want to learn Java, C, C++, and add on to Python, Javascript and HTML and CSS to be able to explore VR Development. And of course, I want to finish the 75 Leetcode questions and be able to solve the Leecode Hard in <30 mins.', 'Boring video', '@NeetCode, Can you please add Time and space complexity in code itself , at the end with comment?', 'What is your opinion on GO lang? Do you think it has a bright future @neetcode', 'How should I learn something as a beginner and get employable this year? Currently in a Support role , would love to change into a developer role instead.\nWould love some advices for where I should start to learn', 'I have an aerospace degree, and a few years of inertial navigation analysis experience, and did a couple hundred LC problems. Could I reasonably expect to get considered for a high TC SDE job/get an interview without any development experience? Any help or advice would be great. Love the channel btw, always helped me.', '2:00 - ""using a server side approach where content is already built and rendered"" - could you define \'rendered\' here? Doesn\'t a browser have to \'render\' the page once it gets the html/css information? That is to say, isn\'t the act of a browser painting pixels on your screen the actual rendering piece? If that\'s the case, I think your statement might be misleading. Thanks!', ""SvelteKit all the way. This is the kind of thing that I've been saying that, if you have any leverage in what stack to pick, adopt Svelte. Drop React, it's just a mess of a framework at this point; we need to drive adoption for Svelte.\n\nAlso advocating for Go. It's one of the simplest back end languages you can learn with strong typing and AOT compilation. It can output small binaries to your platform of choice and you can even embed static files inside such binaires, which makes deployment so much easier. No more cluttering your servers with node_modules. Plus Go is great for concurrency  and performing CPU intensive tasks on separate goroutines. Because of this, I feel like Go scales far better than node.js. The only time I choose TS for back end is if I have dozens or even hundreds of data models I need to share between the front and back end, which is almost never.\n\nLastly, if you want to get into cross platform mobile and desktop development, look into Flutter. It's very straightforward and has a great set of UI components.""]"
15,jgQjes7MgTM,"[""Warning, the roadmap is not mobile-friendly AT ALL. But really looking forward to hearing your guys' thoughts! Btw thanks for 300K subscribers, can't believe we started with less than 100K at the beginning of the year :)  hope you all have a good holiday break!\n\n🚀 https://neetcode.io/"", '7:50 ""your girlfriend.. oh wait"" hahahahaha', 'thank you so much, can someone tell me how do i study about that topic before i start a different concept', 'Would you consider this to be good to help prepare for competitions as well?', 'Literally the gOAT', 'Thank you so much!!', 'The site is great, minus the light theme.', 'Can you add a monthly subscription option? I got 99 problems and money is one.', 'I think if you added the Recursion Topic in this chart, The RoadMap will be excellent', ""To get accepted into swe internship I needed to solve a problem with binary search, one with sliding window, and needed to implement a linked list from scratch and that's all. I went overkill up to 2d dp, that was wayyy too much of unneeded learning for such a role. For an internship its enough to know everything up to trees and thats it""]"
16,D9IFZnIhoe4,"[""No, I don't think AI is going to take our jobs..  unless you don't subscribe, at that point anything can happen 😉\n\nThat said I really hope it automate the boring and tedious stuff soon - it's crazy how much of my time at Google is wasted on things like syntax, API interfaces,  manually fixing build rules, and permissions hell."", 'If anything, it should replace middle management. Soulless text that pushes deadlines.', 'What annoys me the most is people saying ""Oh I asked it to program something for me. It didn\'t work properly so we\'re definitely secure"" \nThis is not really the case. Yes it is deeply flawed right now, but get this, we didn\'t have such a program about 3-5 years ago. Now Imagine 10 years from now. Not good? Imagine 20 years from now. IT IS going to grow rapidly. IT WILL be enough to replace a good amount of programmers. Those who can stand out, are those who can think really really out of the box. But AI will be good enough to replace a bunch of programmers. This is what I believe in at least', 'You should make an updated video of gpt4 to compare how fast it improved', 'No it won\'t, because there\'s no AI at all, Yet! It\'s only algorithmic responses we get from ChatGPT. There\'s no intelligence or whatsoever conscientiousness from the program to generate responses. That\'s still decades away from us in the future. Btw, here is what ChatGPT has to say on this when asking if its AI or algorithmics: ""That\'s correct. I don\'t have subjective experiences or consciousness, and my responses are generated based on patterns and information present in the training data. While I can provide helpful and informative responses, it\'s important to understand that I don\'t possess true intelligence or understanding. I am a tool designed to assist with generating text based on the input I receive."" - I think this is a clear answer. There\'s not yet one company who\'s able to create true intelligence. And it\'s very frustrating that those companies even dare to use the name \'AI\' while it\'s sooo far away from it', 'I have similar experience when I was trying to code a game with hexa map in js, it failed to do its job and it seems to me it was easier to write it alone than to reverse engineering what it has done wrong.', 'Am i dumb or do he say take the last element of the array and put in an index of -1? Was this video AI generated?', 'This is already outdated with GPT-4. You should do another one with GPT-4', 'I always think Hollywood has been predicting the future.  If you watch Westworld you will notice those software engineers don\'t code anymore, they just move panels around, drag the sliders, tweak parameters.  If it will come true these type of visual programming will be friendly accessible to everyone.  ""Programming"" will become as simple as using photoshop nowadays.', ""It's sad, lawyers should be replaced by AI, not programmers.""]"
17,jPKTo1iGQiE,"[""Let me know if you guys want more system design content - I've been wanting to do more and have a lot of ideas, so hopefully you all are interested! Let me know, and feel free to drop a like 👍 =)\n\n🚀 https://neetcode.io/ - Get lifetime access to every course I ever create!"", 'Why are you using noSQL and not SQL?', 'I watch this video in 0.5x to understand 😂😂', '11:00 if a user updates his profile picture you don’t need to update it anywhere is the video metadata iff you have chose to name the profile picture as [uid].jpg in this manner you will always have the current profile picture', 'nat/natbot GPT-3 [:"" ""... thank you. id separate the user and uploader work. more cloud design information please.', 'Why dont we skip the first object storage? Like the app server directly adds the video to the queue?', 'Even in sport live streaming, to the end users, they are mostly over TCP. TCP gets your congestion control, error code checking, and guarantee ordering delivery. With live stream, sure it sucks when you are 10 seconds behind or when you see the ""10x speed up"" or ""fuzzy screen"" when there is a slow network, but ultimately as a viewer we still want to see most of the live video to be played. The client side can throw error when there is a consistent connection error, or skip ahead when it finds itself way behind. With UDP you really don\'t get those benefits. TCP reusing connection also helps. In practice, almost no one will use udp. There are other proprietary protocols out there, but most of them depend on tcp.', '21:49 this is not correct. It loaded the chunk over http3/quic which is udp based', 'what books do I need to read for this any suggestions? what exactly is the name of the topic i need to research?', 'Great video. I like the high level stuff.']"
18,dncBmGtYJ9g,"[""Hope you all are taking care of yourselves, we WILL get through this! As you can see, I'm working on my video editing skills to prepare myself for layoffs.. but in seriousness, the grind NEVER stops. As long as you have valuable skills, your employer never has too much power over you.\n\nI'll have some new features coming to https://neetcode.io pretty soon (free).\nAlso, I'll be making coding interview related content on instagram soon, so follow me here if you're interested: https://www.instagram.com/neetcodeio/\n\nBTW if you're interested in working with me on NeetCode stuff please fill out this form: https://forms.gle/ZUmofsb5QeHzexJv9"", 'Your web is really cool and democratic yet. Yeah more democratic than America', '🔥 Do you think today does it still worth to work at FAANG/MANGA companies?', 'มันมีเหตุผลบางอย่างอมขี้มาพูดก็ไม่เชื่อ', 'เพราะมันมีอำนาจอยู่ในมือคนโง่.😂😂😂', 'นี่ทำได้แต่แก้ไม่ได้.สมน่ำหน้า', 'มันขโมยข้อมูลบนGoogleหลังจากนั้น.ฉิบหายหมด', 'สาเหตุมาจากพวกผู้นำโง่ๆบางกลุ่ม', 'แม่งหลอนละ', 'Never understood why tf Netflix was part of ""FAANG""']"
19,o5n85GRKuzk,"['So are you guys interested in working at Twitter? 😅Btw, don\'t forget to ""Batch"" click the like & subscribe buttons.\n\n🚀 https://neetcode.io/ - Get lifetime access to every course I ever create!', 'I always figured using Goalgn for the REST api and SingleStore as the backend DB would offer the most scalability. And then of course caching with Aerospike or Tarantool. SingleStore has graph too I think as well as most data models. On top of that, it has really good compression.', ""First time Kim Kardashian has come up in any tech video I've watched"", '⥊ :D', ""Don't forget ads. Imagine how complex this whole thing becomes when we add in ads."", 'That initial diss on twitter is everything 😂😂', 'I appreciate the effort and care you put into this video but I think it could use a little more focus. Especially at the sharding-for-writes portion. You jumped around a lot to digressions that made that line of thought hard to follow.', 'Elon Musk prob saw this video and is like should be easy why hire SWEs', 'Sorry I think it was not very Clear the sharding strategy regarding Userid and the people the user follows. Imagine someone who almost every user follows (Beyonce). So all people around the world would end up hittting the same shard  ?', 'Hehehe he said sharting']"
20,46dZH7LDbf8,"['🚀 https://neetcode.io/ - Get lifetime access to all current & future courses I create!\n\nShould FryingPan mock interview me next?\n\nThanks to FryingPan for joining, check out his video here: https://youtu.be/bLk27-xKAD0\n\nBtw this is the question I asked: https://leetcode.com/problems/insert-delete-getrandom-o1/\nWe actually solved it on the channel here: https://youtu.be/j4KwhBziOpg', 'What’s the white thing in Pen’s nose? I hope his real world interviewers did not see this episode - 😂', 'Cocky bastard... 0 humility at the end :D... totally disqualified imo', 'I would implement the Get(bool random, Enum<DataType> input) first, then when implementing the Insert, pass each iteration to Get() with random false. If it returns a value then dont insert it as its duplicate. To get random you jusst need to set random to true. Then the remove is straight forward.', 'So our TC for insertion is still o(n), deletion is o(1) and getRandom is same as before. So really only the deletion method became constant time. But i thought neet said all of them can be constant time? Did i miss somethjng?', 'in getRandom function i could just find a random integer as a index  from range(0, len(self.map)) and return the  value at a particular index \nit will also bt O(1)', 'This was fun. Never seen someone so pleased to get the answer :P', 'So funny. I am still struggling with leetcode by just finishing the first 200. And I did not have much interview experience. The video makes me feel like we are all human beings.', 'Def  not getting hired with that attitude.', 'Dude is hilarious']"
21,Hmf7a5u8nCk,"['Btw I was just kidding at end..\n\n🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'laid… off', 'I genuinely hope you are right. If I take it slow and steady and get a job I will come back and thank you for my entire life.', 'I LOVE YOU!', 'shoutout to NeetCode for including a Chrono Trigger OST song at 2:41', '4:10', ""1:01 I don't know, are Google engineers getting laid.. off?"", 'Hi, NeetCode, would you mind to share where and how you find a project to do when you unemployed? I am unemployed now and really anxious since I do not have project for my resume. thank you', '@Neetcode, you are my inspiration....', 'thank you']"
22,akXP6pC0piE,"['This is one of the lessons from my System Design for Beginners course, which is currently on-going on neetcode.io.\n\n 🚀 https://neetcode.io/ - Get lifetime access to all current & future courses I create!', ""Hi Neetcode! (Neetcode Premium User here) can you make videos on software engineering best practices/ technical concepts that is applicable in the industry? like git commands, databases, operating system, APIs, etc? Just concepts that software engineers (entry level at least) should know. If you release any of that, we'd greatly appreciate it! :)"", 'well this app architecture applies only to web applications. For native/desktop apps the architecture could be vastly different...', 'Great channel! Learning so much about system design from you.', 'Is designing a stock or crypto exchange very different?', 'Hey! Is there a part two for this video?', 'thanks, man. this is very helpful!', 'Got a little long in the tooth around the metrics but otherwise pretty good for beginners.', 'not for production. for practice only and locally. mostly python flask php sqlite . and the loggin vm will do the alerts and metrics tasks.', 'very useful thanx for the clear infos. im starting n i have a dumb question: can it all be set up on vms? or at least the most?']"
23,BgLTDT03QtU,"['🚀 https://neetcode.io/ - Get lifetime access to all current & future courses I create!\n\nCode from the video: https://neetcode.io/courses/lessons/big-o-notation', ""I'm feeling so stupid, man. Looks like w/o basic algebra knowledges, there is no way to understand this..."", 'well explained my fried, you summarised two weeks worth of lectures in 20 minutes thanks for this', 'This guy is GOATed!', ""you're the best, thank you! "", 'The best explanation I could find on YouTube, thanks❤', 'Thanks!', 'best BigO notation explanation period.', 'You are just Awesome!!!!', 'can someone explain? when to put n*m instead n^2. in my understanding, they are both the same but has different emphasis? i am correct?']"
24,0K_eZGS5NsU,"['🚀 All of the code is available at: https://neetcode.io/courses/lessons/python-for-coding-interviews\n\nTimestamps:\n1:13 - variables \n2:40 - if-statements\n4:00 - loops\n6:06 - math\n8:40 - arrays\n12:38 - sorting\n13:40 - list comprehension\n14:20 - 2-d arrays\n15:25 - strings\n16:50 - queues\n17:30 - hash sets\n18:25 - hash maps\n20:15 - tuples\n20:55 - heaps\n22:30 - functions\n22:55 - nested functions\n24:20 - classes', 'Thanks sir a lot of topics to Train kudos', ""Great video. Did you touch on linked lists? I might've missed it."", ""i haven't written a line of python but I have an interview in 20 minutes, thank you for this video"", '20:51 Heaps in Python are underrated.', 'This is such a brilliantly constructed video! Thank you so much. Could not have learned all this python I need for interviews without your help!', ""this was so good, I was like 50% confident with my python collection skills and now I am alot more confident. I can simply google what I know that exists even if i forgot the syntax. This is what I truly need content that can show me that something exists to know what to search. We don't know what we don't know"", ""It'd be great if you did this for JS ❤"", 'Goated channel 10000%, would love it if you could do a C++ tutorial of this struture for people looking to move from python to c++ :)', 'should cover heapq with custom __lt__  comes up very often']"
25,qMky6D6YtXU,"['Thank you!', 'For Distinct Subsequences(2:06:10) use modulo on line 14 like this to get the correct answer when length of s is too long:\nif(s[i] == t[j]):\n                cache[(i,j)] = dfs(i + 1, j + 1)%m + dfs(i + 1,  j)%m\n\n\nhere m = int(1e9+7)', '1:38:00', 'is 2d array dp and pointer approach the same  time complexity?', '1:04:00', 'Edit Distance: What if we have fourth option is exchange two adjacent character?', 'Loved it thanks for the amazing explanations❤', 'for coin change 2 problem\ndp=[0]*(amount+1)\r\n        dp[0] = 1\r\n        for coin in coins:\r\n            for i in range(1, amount+1):\r\n                if i - coin >=0:\r\n                    dp[i] += dp[i-coin]\r\n        return dp[-1]', '```py\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n\n        dp=[0]*(len(text1)+1)\n        \n        for i in text2:\n            flag = 0\n            \n            for j in range(len(text1)):\n\n                if i==text1[j] and flag == 0:\n                    \n                    if dp[j+1]!=dp[j]+1:\n                        flag=1  \n                        dp[j+1]=dp[j]+1\n                else:\n                    if dp[j+1]>=dp[j]:\n                        flag=0\n                    else:\n                        dp[j+1]=dp[j]\n\n            \n                    \n\n        \n        return dp[-1]\n```  I solved it in O(n) space complexity, beats 99% of the code in both time and memory distribution on leetcode', '@neetcode, are u left handed?']"
26,_i4Yxeh5ceQ,"['🚀 https://neetcode.io - Get access to every current and future course I ever create.\n\nSpreadsheet from the video: https://docs.google.com/spreadsheets/d/1A2PaQKcdwO_lwxz9bAnxXnIQayCouZP6d-ENrBz_NXc/edit?usp=sharing', 'the two variable approach to solving the decode ways is missing in this video, but really helpful video. Thanks a lot.', '13:20, at the last step 5, how many ways to land on the same step land on itself, why 1?', 'Out of curiosity, Why do i need 1 step if i am in step 5, I am already there, right ?', 'why is bottom up solution considered the ""true"" DP solution?', 'What’s the difference between this and recursion', ""I've been watching your videos so much through my interview preparations that your voice sounds like a mother's lullaby to me at this point."", ""I didn't quite get it for the house robber 1 problem after watching 2 times. Maybe I failed in one key thought jump."", '48:36', '38:16']"
27,Y7UTvogADH0,"['🚀 https://neetcode.io/ - 25% OFF LAUNCH SALE', '2 minutes into the explanation I got the idea, thanks for the video!', 'I copied and pasted a lot of stuff and stitched together this code, but I have no idea how it works lol. I knew this could be done with bit manipulation but this method is not any better than the binary search solution, but I still wanted to try it. However, I have no idea how this works except for the msb calculation, which i modified to include (the original did not work). \n\nimport math\nclass Solution:\n    \n    def mySqrt(self, x: int) -> int:\n        \n        msb = len(str(bin(x)))\n\n     \n        a = 1 << msb\n        result = 0\n        while a != 0:\n\n            if (result + a) * (result + a) <= x :\n                result += a\n\n            a >>= 1\n\n        return result', 'Can you do Leet Code 443 String Compression?', 'we are popping when len(heap)==k in heap\nand adding curr value in heap..what if the current value is smaller than what we had popped?', ""Did you come up with these solutions for these problems looking at them the first time? Or did you also learn from other people's solution?\nAnswer me NEETCODE"", 'can someone provide java solution ?', 'can someone help in my java code? Some test cases are not getting passed.Thank you.\n\nclass Solution {\n    public int maxPerformance(int n, int[] speed, int[] efficiency, int k) {\n        int[][] zip = new int[speed.length][2]; //eff,speed\n\n        for(int i = 0; i < speed.length; i++){\n            zip[i] = new int[] {efficiency[i], speed[i]};\n        }\n\n        Arrays.sort(zip, (a,b) -> Integer.compare(b[0], a[0]));\n\n        Queue<Integer> minHeap = new PriorityQueue<>((a,b) -> Integer.compare(a,b));\n\n        int res = 0;\n        int totalSpeed = 0;\n        for(int[] pair : zip){\n            if(minHeap.size() == k){\n                totalSpeed -= minHeap.poll();\n            }\n            int eff = pair[0], spd = pair[1];\n            minHeap.add(spd);\n            totalSpeed += spd;\n            res = Math.max(res, totalSpeed*eff);\n        }\n\n        return (int)(res % (Math.pow(10,9) + 7));\n\n\n    }\n}', 'amazing explanation, thank u', ""I've got my Amazon final interview next Friday and I just wanted to let you know that I wouldn't have made it nearly as far without you. Thank you for all your videos! You have no idea how many lives you're changing""]"
28,b1WpYxnuebQ,"['🚀 https://neetcode.io/ - 25% OFF LAUNCH SALE\n\nJust released the first batch of Advanced Algorithm lessons, along with some other updates. A lot more updates coming soon! 🙂', 'update ur roadmap', 'Thanks for your videos and efforts🙏', 'I have no idea what you just did, but thank you.', 'Wow, this was just excellent', 'How would a binary tree with no left node be represented in array (the input in this case)?', 'Hey could you upload a video for Gray Code question. ik there are multiple solutions in the net, but i feel like  ur explanations reach me better', 'Your videos are the most intutive ones.......... Surviving cp bcoz of you brother, If one day I get into Amazon, I will give u whatever u ask for ❤❤❤❤❤❤❤❤', 'Thanks!', 'Thanks!']"
29,4G5t1HwHQD4,"['🚀 https://neetcode.io - Get access to every current and future course I ever create.\n\nLet me know if you enjoyed this new ""architecture"" style video and I\'ll try to do more! 🙂', 'Nice. I made a SaaS too. \n\nReact + NodeJS + Bitcoin Lightning Paywalls + Generative AI for content', ""I loved this video! I'm at a stage where I want to build my own small SaaS project, and this video helped me visualize how I might approach that problem. I know it won't be easy, but I know the rewards of starting your own business can be immense."", 'please create more architecture / system design videos!! loved it :)', 'I think you made a smart move by not joining udemy and having full control over the user experience. I really enjoy the interactive feel of neetcode and how it’s almost like a toolbox you can open up next to you while u grind out leetcode.', ""I'm so interested in Angular content from you"", 'I watched this video when its aired, Its like alien language to me. Today I watched with knowledge of Neetcode system design. Thats realy wonderful.', 'love system design type content! support!', 'how do u style your components and make your own images and icons? what software do u use?', 'how did u learn all of this?']"
30,VUVpTZVa7Ls,"['🚀 https://neetcode.io/ - The best FREE site to prepare for Coding Interviews\n\n🥷 Discord: https://discord.gg/ddjKRXPqtk\n🐦 Twitter: https://twitter.com/neetcode1', 'what name of this ide ?', 'What was the reason for adding the mod function?', 'Such a complex problem, yet you make it so easy to understand! It almost seems obvious at the end!', 'Super Thanks', 'Thanks!', 'Hi neetcode, just saw you website. I think I am the first to saw the changes. Can you give some discount to your Indian user Rs10000($129) is a lot.  Can you make it Rs 5000. I will buy it in a giffy.', 'Using hash maps would make the time complexity better, because insert operation is O(1) in hash maps whereas in list the insert operation is O(n)', 'Neetcode staying prepped up for a senior position\nWhen are you going to do Sys Design ?', ""Can someone pls explain the mod thing? I didn't get that.""]"
31,5ueSge4n4bs,"['What tech stack do you guys use?\n\n🚀 https://neetcode.io/ - Get access to every course I will ever create!', 'I will work at Google very soon 😊', 'Why java over golang for a microservice', 'Svelte also does things in a very certain way just way better than angular', 'Angular is well known for being the shitty', 'Video of microservice in c++?', 'internals', 'No Go (GoLang) at Google ?', 'Man your voice is so soothing and calming ,. \nOne day even I made your video on autoplay in playlist and  on hearing your voice i slept.', 'At work we use Angular, . NET (c#), and some relational database systems.\nFor data-science apps we use python with flask and langchain.\nWe deploy to azure or digital ocean.\nVersion control is git.']"
32,DmWirHqCq1s,"['Damn, over 100 people already signed up in the first 15 minutes! Please msg me on twitter, discord, or comment here if you notice any issues!\n\n🚀 https://neetcode.io/\n🥷 Discord: https://discord.gg/ddjKRXPqtk\n🐦 Twitter: https://twitter.com/neetcode1', 'I thought it is free but it isnt.', 'Thank you dude, I love you 😘😘', 'You are on fire 🔥', ""FE (front-end) development is just as hard, if not harder, than back-end development sometimes. That's why I'm shocked when people are wanting full-stack devs and they're disappointed when front-end isn't the strong suit."", 'First thanks for your hard work its really helpful ,second can you please show us how you made this web site i want to do the same but in my language with different design and different options .', 'A big thanks to you !', 'Great!', '謝謝！', ""Hey Neet, just wanted to say that, thanks to your courses, I managed to get an offer from Google at L4 (actually an uplevel from the L3 I interviewed at, since I did so well on all the interviews) even through all of the recent hiring freezes and turbulence! Really appreciate all the work you've put in. Your site/videos are a fantastic resource.""]"
33,RegQckCegDk,"['4:25 doesnt make sense, 5 is okay but 4 isnt?', 'Bro I just love the way u explain things by considering various types of test cases. Mad Respect for your efforts. Seriously !', 'please solve  this problem 🙏 44. Wildcard Matching', ""I kind of get it.  But can't see it clearly in my head"", 'understood', 'try testing [4,2,1] with your code', ""I'm glad that I solved this question on my own which I think is a result of following your channel. Even though the code that I wrote is a lot less elegant than yours but I'm glad that my thought is pretty much the same as yours and the time complexity is the same. Thank you for doing these videos!"", 'thanku so much', 'Why are we adding 3 in the begining of the array? Please, anyone can explain it to me.', 'My goodness this was very wel explained']"
34,D4T2N0yAr20,"['Discord: https://discord.gg/ddjKRXPqtk\n\nCorrection: Time complexity is O(nlogn + n + m) where n is size of products, and m is length of searchWord.', 'This doesnt seem scalable because you would need to sort every word first.', ""I'd use a TreeMap / std::map, which will do the l/r portion in logN time"", 'Hey please mention the the time and space complexity for every question you solve', 'I think on your website you should list this problem under two pointers rather than binary search.', ""Can I send a graph question and also a simple question that I didn't get to solve. Will you have look into that"", 'easiest solution', 'I really have no clue how are we supposed to come up with this sort of answers during an interview if we never saw the problem 😅', ""Hey @NeetCode, wouldn't it be faster to use a slice on the final append to answer instead of that for j in range loop? \n\nie: answer.append(products[l:min(3, r - l + 1)+l])"", '5 seconds in: trie trie trie trie']"
35,PFRzAysTvpo,"['🚀 https://neetcode.io/ - 25% OFF LAUNCH SALE\n\nDiscord: https://discord.gg/ZdDafbpw', 'Thanks GOD for a real video on how working at Google really is. A lot of internal tools we use at Google are not something super unique and are still transferable. They are based on similar core concepts.', ""I had to pause during your explanation about the internal tools. I think most of them are OK, except the whole resource management system. I can't believe how outdated and tedious the whole quota allocation and setup process is, with permissions, memberships, approvals, etc. They really do suck. But the internal tools I've used seem pretty great to me, especially because of the monorepo which makes dependency management super easy. Plus the concept of dedicated hardware for testing instead of testing locally is pretty neat because of the level of standardisation this approach offers. I'd say Google's internal tools (except the one I mentioned) are a bit of a golden handcuff for me.\n\nSo, the difference in our opinions are probably due to lack of experience in the ecosystem, rather than there being problems with the tools. It is also nice that you have the tool creators on speed dial. You can message them directly and get replies within reasonable time. You can also tell them exactly what's missing in the documentation.\n\nInternal chat app sucks, and it is one of those products that keeps getting worse with new features."", 'You can work anywhere now with that experience, and google is ripping you off.  Good luck.', 'Good night❤', ""You should not sell anything you wouldn't buy yourself. I don't sell anything which I wouldn't buy myself. I see there is a very deep issue with GCP in Google."", ""I'm cheap 😂"", 'Neetcode thanks so much for all your videos! After struggling with Leetcodes for 1.5 years, your videos helped me get better and I finally landed a new grad software engineering job at my dream company!! Big thank you ❤', ""I am guessing, you're alo trying to save your job :)"", 'Hey i dont know what department you worked in but i wanted to ask you a question . Is there any way i could get my old gmail account back if its been longer than 6 months since deleting it? They say its impossible to retrieve but i know my data must be stored somewhere especially since i cant make a new account with the same name because it\'s ""taken"" any advice on who to contact or how to retrieve my account (other than the usual Google account recovery thing) would be greatly appreciated!! Thanks :)']"
36,rMj6KnxZu5M,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'I am going through your leetCode site doing 1 question a day, and it has been great! Thank you so much!', 'Where can we tip you? Would love to throw a little appreciation back after I get a job!', 'would u prefer 14 inch MacBook Pro or 16 inch as developer tool ?', ""As a hiring manager I completely agree, at least for me, I am much more interested in knowing the candidates thought process than seeing a correct solution. I'd rather hear a candidate describe their (correct) approach to many scenarios than to see a implementation of just one."", 'Bombed my coding interview today 😢 . I recognized the question and jumped in immediately.', 'Thanks needcode landed a job at intuit and got into the onsite on couple of companies. Got an offer from Google also but the intuit offer was better.\n\nI really appreciate your content.', 'Hi, How do you make a video like this? What software tools do you use?', 'Any extra advice for students overseas, having the white board interviews online.', 'I was able to enter heaven thanks to neetcode. Saint Peter was tough but I still got through.']"
37,nalYyLZgvCY,"['Your observation of how to check the vacant positive/negative diagonal cells is brilliant', 'You make this problem super easy! Thanks!', 'Thanks!', 'Plzz man make video on leetcode-542 ,\nTBH i love and understand ur way of logical explanation with in a minutes, most of YouTuber make long brain fucking videos man 😭😭', 'Just want to thank you for making these vidoes! You are awesome and helping a ton of people !!', 'You Genius 👏', 'Thanks!', 'Hi there! absolutely love your explanations, could you please make an explanation video on 164 Maximum Gap which uses Radix/Bucket sort? Thank you', 'What would be a better way for Python(not python3) to deal with the non-local variable WITHOUT creating a list and returning the len(list)?', ""Leetcode doesn't accept nonlocal variables for python. It seems like it only works for python3""]"
38,KE8MQuwE2yA,"[""you're de besttttt....Thank youuuuu"", ""What's the logic behind calculating prefix sum for each cell? What's the intuition behind the formula you used?"", 'At first, it was a little tough to understand, but I watched this video multiple times. Now I fully understood the concept! thanks Neetcode!', 'Tanks a lot ~', 'I understand why we are adding a top row since it would be out of bounds when we are calculating prefix sum for the first row (no ""above""), but why are we also adding a left column?', 'cant we compute the prefix matrix in place of the given matrix ?', 'this is fabulous, nice work', 'Hey Neet! You explain great! I love your videos. Can you make a video about Problem 307. Range Sum Query - Mutable? \nIt uses Segment Trees to optimize the algorithm. Would love to see that!', 'Thank you! You are a master at explaining!', 'Sir, will you please solve leetcode 174?']"
39,qU32rTy_kOM,"['This is clever!', 'We can add if ((s.length() - k + 1) * k < (1 << k)) return false for pruning the invalid data to make the algorithm faster.', 'Interesting to think that there is a subset of  the183K subscribers who passed an interview and accepted the job because of this channel. Very strong impact', 'Awesome 😁😁', 'why O(n*k) can someone explain for me ?: thank u', 'hey Neet, your solution is brilliant but what if (s) dont have enough sample to return the number of solution we are seeking. E.g s=""0110"" k=2', ""Man, thank you so much. I just got my dream Google offer and I would've never ever gotten it without your videos. Thank you so much and I'll be joining you in the Seattle office this fall!"", 'Hi, hashcode is not too efficient here. Since we have a continuous sequence of integers to search for, why not have an array, 0 to 2^k-1?\nThis leads to a quite efficient code :)\n\nRuntime: 555 ms, faster than 100.00% of Kotlin online submissions for Check If a String Contains All Binary Codes of Size K.\nMemory Usage: 68.4 MB, less than 100.00% of Kotlin online submissions for Check If a String Contains All Binary Codes of Size K.', ""Thought you'd stop after your hard work paid off. Good to see that you're still at it! Keep it up man, it's greatly appreciated :)"", 'Hi NeetCode, would you consider making a video on more advanced topics like string hashing or segment trees?']"
40,uhYq27iSk9s,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', ""I'm not sure if inserting to a hashmap is, by definition, O(1). It really depends on your hashing function. Your worst case to deal with hashing collisions will be by using a height balanced binary tree as collision structure, so this becomes O((logn)/k). If you never deal with collisions, then yeah O(1) is correct, but you'll need a really big starting array."", 'Started my journey of getting ready for tech interviews… I have been watching your vids every chance I get!!', 'Cool.', ""Question: May be I am missing something ? But inserting or removing at the mid of linked list how it's O(1) unless we have a reference to the mid node, which in usual scenario we don't have that reference, in that case we have to loop to find the mid node and then insert or remove in this case it won't be constant."", ""Regarding Linked list how it's possible to insert or remove in middle of the linked list in O(1)? How you will get the node of middle in constant time without storing the index of the nodes of the linked list?"", '@NeetCode , One que, How time complexity of linked list for insert and delete will be  O(1), first we need to traverse till that node right ?, which in worst case O(n). so O(n) + O(1) would be O(n) right ?', ""When inserting/deleting from a linked list, don't you have to get the nodes 6 and 8 before inserting 7? But if you do, insert can't be O(1), since reading from a linked list is O(n)"", 'As far as I know, inserting an element at any position to a linked list is O(N) because you have to traverse and update your pointer untill that element. In the video it says O(1). How is this possible?', 'Fantastic video!']"
41,q5ANAl8Z458,"['“…and as you can see, it’s pretty efficient”. Yet it is only better than 20% 😂\n\nThat always makes laugh. But your explanations are still the best regardless. Got my job because of you. So thank you.', 'I added some pythonic comments to make more sense of the solution. Here is the code in Java. (Dang this was hard to understand): \n\npublic boolean find132pattern(int[] nums) {\n        if (nums.length < 3) return false;\n\n        // [nums[j], min(nums[:j]) = nums[i]], monotone decreasing in nums[j] \n        Stack<int[]> stack = new Stack<>(); \n\n        int currMin = nums[0]; // i candidate (min(nums[:j]))\n\n        for (int k = 1; k < nums.length; k++) {\n            // while not (nums[k] < nums[j])\n            while (!stack.isEmpty() && !(nums[k] < stack.peek()[0])) stack.pop();  \n\n            // The while loop above ensures that nums[k] < nums[j].\n            // So only check that nums[i] = min(nums[:j]) < nums[k].\n            if (!stack.isEmpty() && stack.peek()[1] < nums[k]) return true; \n\n            stack.push(new int[]{ nums[k], currMin });\n\n            currMin = Math.min(currMin, nums[k]); \n        }\n\n        return false; \n    }', 'which tool do you use for drawing,writing in the video?', 'A way to think about it is that the stack stores a potential j candidate with the best i candidate for that j. Then for each k checks if it is between them and returns True. While checking it removes j candidates that are sub-optimal(nums[candidate] <= nums[n]) since we want to maximise j.', 'thanks', 'Thank for explanation!', 'C++ code for brute force approach \nclass Solution {\npublic:\n    bool find132pattern(vector<int>& nums) {\n    //coding the brute force\n   int k=2;\n    while(k<nums.size()){\n        int i=0;\n        for( i=0; i<k; i++){\n          if(nums[i]<nums[k]){\n              for(int l=i; l<k; l++){\n                  if(nums[l]>nums[i] && nums[l]>nums[k]){\n                      return true;\n                  }\n              }\n          }\n        }\n        k++;\n    }\n    return false;\n    }\n};', 'Thank you for the explanation, It was quite difficult coming up with a stack approach.', ""It wasn't clear to me why this solution is correct. You didn't explain why."", 'Amazing solution']"
42,w6LcypDgC4w,"[""As soon as I saw the question, I knew it was similar to parenthesis problem. I wonder why this is medium difficulty, since it's very very similar to prenthesis problem."", 'The idea of combing value and count together is brilliant.🎉', 'Hi Your code is failing for K=1', 'so satisfying!', 'Could you pls explain on how to do it if instead of adjacent same character, we have to remove if a pattern is repeated\nEg. Input - abcabcabcd\nOutput - abcd\nThanks', 'I think consecutive numbers are for example: 1, 2, 3, 4, 5, 6, so maybe 333 has a better name to call it?', 'Wow, every time I watch Neetcode, I feel my brain refreshed! Thank you so much!', 'I feel a little accomplished if I were to solve the problem after the coding explanation without looking at your solution. Now all I need is to find the solution without looking at the explanation.', ""I think that part when you creating res can be simplified to: \n\nreturn ''.join([char * count for char, count in stack])"", 'Can someone explain the stack.pop() part? Isnt stack.pop only removing the last character of the string? So when the loop gets to ""caabbb"" b will have count of 3, so stack.pop() will get called and only remove the last character which will result in ""caabb"", then it will continue onto the next iteration. Wouldn\'t stack.pop need to be called k times? Thanks']"
43,bwgjvzMSlMQ,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', ""I should say you're the one mate. People ex-facebook ex google just bullshit talking about how great they are actually giving not much insights to the viewers."", 'The first resume would not even make through ats system , never has for me atleast .... Give me a Interview atleast.... Crying in pain', 'Thank you for posting this 🥰🥰🥰', 'https://youtu.be/bwgjvzMSlMQ', 'at this point, what is your 1st programming language', '""Engineers probably wouldn\'t care about this"" - Shows what you know. Being a hiring manager, skills matter. It matters what you say you can do because then I know what to expect. What you say you know vs what you show you know through your experience are often very different things.\n\nTalking points. Version(s). Flexibility of the candidate. It matters.', ""I'm gonna return to this video several times :))"", 'great!', 'Really appreciate your honesty, this was great content as usual!']"
44,4SUJt3dP2Jc,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'idk if its just me but he has a similar voice to Fireship in a way', 'Please add a Front-End specific section/ more content?', 'Thank you for sharing your experience, it is very valuable.', 'Hey I am studying 2nd yr BTech. I am not having clear idea about what they will ask in interview. Please explain me... In this interview what about other topics? Jst only DSA??', ""What language should i use in the interview java, c, python or they tell u to do it with a specific language or i choose the one I'm more confortable with?"", 'What more do they want , you did pretty much everything they asked and got the answered and they still didn’t want you ? No way , those interviewers were on some stupid stuff', 'I have talked to some people who work at Google, on TeamBlind. The ones I talked to were all sh*t people. Plus, guess what, they always look for some reasons to say you ""may be a false positive"", but if you are a girl wearing short skirt, well then, they cannot mistake you and will take you as a false negative. You can be quite likely hired. I really don\'t want to work at such a sh*t place.', ""Is this the same Google that can't display an accurate message count in YouTube Studio? That Google?"", 'ran into a similar situation few years ago during a Meta interview where I decided to pass an extra variable to accumulate the recursive result. Great insights!']"
45,T53EyLPj4UM,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'So no system design rounds?', ""I think it's pretty impressive anyone gets hired if even you found difficulty in an L3 loop."", ""I felt the thick accent big time. Most of my interviews are shaky because of thick accents. I feel terrible when I can't understand them."", ""It's 50% luck...the vibe that day...Just learn your subject matter better than everyone else, be passionate and demonstrate some hacker out of the box thinking"", 'On your Algorithms and Data Structures for Beginners course, you speak about 8 bits but you only draw lines for 7 bits. You even circle the 7 lines and say it\'s ""8 bits"". Just a heads-up.', 'can you list which question you were asked??', ""Ive started learning DSA 6 momths ago. But im feeling like im just trying go remember the solution approaches instead of understanding it. I understand that leetcode questions will not come in the actual interviews as it is. There will be some twist too. And i think at this point I'll get stuck. HOW should i fix this? What can help me understand and not remember the solutions?"", 'congrats man', 'Does Google care about previous experience on their stack language, or is that ok we have a different coding language experience?']"
46,7vVEJwVvAlI,"['The main catch of this problem is the part is updating the curSum 😴', 'Hey Neetcode, you could also eliminate temp by doing something like this(just carry the updated root.val as currSum for further iterations): Just a suggestion :). BTW, great work!            \n            dfs(root.right)\n            root.val += currSum\n            currSum = root.val', ""If you want, we could use a list to store the curSum, and modify it in the nested function, Cause it is a shallow copy. And no need to store the tmp.\ndef convertBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\r\n        curSum = [0]\r\n        def dfs(node):\r\n            if not node:\r\n                return None\r\n            dfs(node.right)\r\n            '''\r\n            tmp = node.val\r\n            node.val += curSum[0]\r\n            curSum[0] += tmp\r\n            '''\r\n            node.val += curSum[0]\r\n            curSum[0] = node.val\r\n            dfs(node.left)\r\n        dfs(root)\r\n        return root"", ""We can also Pass the curSum as a member variable in the Constructor initialize part. Then inside DFS  we don't need to mention curSum as global variable."", 'what app do you use to record screen and for white board?', ""Hey man I just want to say thanks for all you do for the community. I landed my dream job at Microsoft and your channel was a big part of me building up my DSA foundations. Everybody out there keep practicing these problems I swear it'll pay off in the long run"", 'hey there NeetCode, love your channel its really bright and understandable!\ncan you make a video on: \n1202. Smallest String With Swaps?\nthere are coupe of videos on youtube but i didnt quite understand their explanations.', '💯✨', 'Hello Neetcode, thank you for these great videos and your explanation. Could you please share with us what drawing tablet do you use and what software do you use for video editing? Thank you and I am eagerly waiting for your new videos!', 'Hi Neetcode, thanks for your amazing explanations. cannot think of solving DSA with out your videos. thanks for making it possible for me. i have a request. is it possible for u to create playlists based on companies ?']"
47,U4hFQCa1Cq0,"['chef kiss', 'Can you make a video on populating Next Right Pointers in Each Node II - Leetcode 117?', 'So clear!', 'Best video yet', ""Simple pre-order recursion\n\nclass Solution:\r\n    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':\r\n        if root and root.left: \r\n            root.left.next = root.right        \r\n            if root.next: \r\n                root.right.next = root.next.left          \r\n            self.connect(root.left)\r\n            self.connect(root.right)\r\n        return root"", 'I did it with the queue data structure initially. It did pass but the code was too much. But you did it so efficiently! Neat code indeed! Thanks!', 'My approach was to do a standard layer by layer BFS and just ensure the order of the layer is left to right.\nI think it is better only because it looks exactly like a standard BFS, without confusing expressions like cur.left.next = cur.right', 'How is it related to binary search? In neetcode practice list, it is under the binary search section. @NeetCode', '4:35 - 6:10', 'very clear explantation, thank you!']"
48,nJYFh4Dl-as,"['I was putting all row and cols in 1D and back to grid\ncache = []\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                cache.append(grid[i][j])\n\n        tmp1 = cache[:-k]\n        tmp2 = cache[-k:]\n        cache = tmp2 + tmp1\n\n        p = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                grid[i][j] = cache[p]\n                p += 1\n        return grid', 'Would it be possible to convert the 2D list into 1D, do the scrolling and then for each 3 elements, add those into 3 lists for 9 items?', ""So is N the number of columns or values in a row, because he goes back to saying 'values in a row' in the code part?"", 'Still not understand', 'I feel like this is not an easy lol', 'I found this solution to be more intuitive and cleaner. the sum(grid,[]) is new to me though.\nclass Solution:\r\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\r\n        col=len(grid[0])\r\n        nums=sum(grid,[])        \r\n        k = k % len(nums)\r\n        move=len(nums)-k\r\n        ans=grid\r\n        count=0\r\n        nums = nums[move:] + nums[:move]\r\n        for i in range(0,len(nums),col):\r\n            ans[count]=nums[i:i+col]\r\n            count+=1\r\n        return ans', 'great use of helper functions,  make it much more readable of a solution', 'use c and use pointers.', 'Clear and helpful!', 'nice solution']"
49,Id_tqGdsZQI,"['Thanks!', ""hey neetcode! solid solution. I just wanted to point out that there isn't much error checking here. What if there was a symbol other than the ones provided? It would fail of course because converting a character to an int may ruin the summation. Thus, my solution (provided on leetcode through amazonintern), is much better. If anyone needs help please feel free to reach out. I understand leetcode can be intimidating. But don't worry, we were all there at one point, and I remember being there myself back when I was in the first grade. Back then, baseball problem was quite hard, but by the time I was 7 I had it solved with 0ms runtime. I'm 11 now."", 'If you store sum variable as well, you would not have to sum again at the end so TC would be O(N) rather than O(2N). I know they are same but still.', ""using switch case which was introduced in python 3.10\n\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack = []\n\n        for o in operations:\n\n            match o:\n                case '+':\n                    stack.append(stack[-1] + stack[-2])\n\n                case 'D':\n                    stack.append(stack[-1]*2)\n\n                case 'C':\n                    stack.pop()\n\n                case _:\n                    stack.append(int(o))\n\n        return sum(stack)"", 'thank you for the great explanation not only for the solution but for the problem itself!', 'I agree,  really weird to call it a baseball game! Great explanation as always.', 'How r u so much clear in explaining things man :| just love ur videos', 'I like ur way of explanation man ❤ 👏💯✨', 'easy prbs are here to boost our ego enough to confront hard prbs xd', '☕']"
50,Re_v0j0CRsg,"['A genius can make a complex topic seem simple', 'Thank you!!!', 'This is Superbb.. Very clean solution', 'Thanks for making this super easy 🙌', ""I cannot believe I couldn't solve it on my own 😥😥"", 'No algoexpert, for the 1000th time, i don’t want to be a software engineer at google. Thank you', 'This is a super neat solution. \nInitially, I was approaching this with a visited  and current_path sets & was doing backtracking on both :) \nNow the code is much cleaner! Thank you for this video.', 'cant stand this guys voice. his inflexes dont make sense!!!', 'This is Amazing... I have written code following all your videos and code looks like this:\n    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:\n        output = []\n        for index, ele in enumerate(graph):\n            for inner_ele in ele:\n                output.append((index, inner_ele))\n\n        new_graph = {i: [] for i in range(len(graph))}\n        for src, dst in output:\n            new_graph[src].append(dst)\n            if dst not in new_graph:\n                new_graph[dst] = []\n\n        stack = []\n        result = {}\n\n        def dfs(vertex):\n            if vertex in result:\n                return result[vertex]\n\n            if vertex in stack:\n                while stack:\n                    vertex = stack.pop()\n                    result[vertex] = False\n                return False\n\n            stack.append(vertex)\n            for neighbor in new_graph[vertex]:\n                if not dfs(neighbor):\n                    return False\n\n            if stack:\n                stack.pop()\n                result[vertex] = True\n            return True\n\n        final_result = []\n        for node in new_graph:\n            if node not in result:\n                if dfs(node):\n                    final_result.append(node)\n            elif result[node]:\n                final_result.append(node)\n        \n        return final_result', 'such a elegant way to detect loops']"
51,08sn_w4LWEE,"['We may not need to set the max of 1001, use this could get the max stations.  stations = [0] * (max(trip[-1] for trip in trips) + 1)', 'As to the mistake from 10 : 40, it yields from variable naming which is not self explanatory.\nNaming a variable ""minHeap"" is like naming it ""list"" or ""dictionary"", it\'s doesn\'t reflect its specific purpose.', ""why we don't need to heapify"", 'Great Solution', 'A much simpler way I did this problem is by creating a new list of trips where each element is tuple of position (src or dest) and passengers (+ve for src and -ve for dest). Simply loop through these (position, passengers) list and add the passengers and check the current count with capacity.', 'mimic your Meeting room 2 solution\nclass Solution:\r\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\r\n  \r\n        starts = sorted([(trip[1], trip[0]) for trip in trips])\r\n        ends =  sorted([(trip[2], trip[0]) for trip in trips])\r\n        \r\n        s = e = 0\r\n        count = maxP = 0\r\n        \r\n        while s < len(starts):\r\n            from_s, numP_s = starts[s]\r\n            from_e, numP_e = ends[e]\r\n            if from_s < from_e:\r\n                count += numP_s\r\n                s += 1\r\n            else:\r\n                count -= numP_e\r\n                e += 1\r\n            maxP = max(count, maxP)\r\n            \r\n            if maxP > capacity:\r\n                return False\r\n        \r\n        return True', 'For the second solution I would argue that the order is O(k + n) or O(k) instead of O(n). Because in the second solution the complexity does not only depend on the number of input but also on the constraint.', 'You solved this completely differently from meeting rooms 2', 'May also be solved by visualising a highway and tracking how many people are sitting in the car at any point. Time and space O(n)', 'Line sweep is another way to solve this']"
52,aa2ijyWBBIc,"['Wanted to make this months ago... but better late than never 😅', ""I haven't landed a job in any significant company yet, but i've benefitted and learned sooo much from your videos. I will support your channel/website/contribution monetarily once I land my dream job. THANK YOU!"", 'You are a God send, your content has helped me soo much!!!', ""nice one 👍 Im just starting out but linked lists in c made me want to minecraft myself, maybe this can help :')"", 'just finished arrays and hashing, finally understand the practical applications of hashing now from actually using it to reduce time and solve harder problems', 'Hey man, neetcode has really helped me brush up my concepts and prepare me for the interviews. Thank you so much.', 'This is amazing. Thank you.', 'I am so glad how useful this site turned out to be!', 'Leetcode + gfg is best', 'This is game changing']"
53,JrxRYBwG6EI,"[""I still don't get it. Why isn't it O(n^2) if you're reversing the string each time you check for a palindrome? Isn't that operation linear as well?"", 'Thanks NeetCode.\nI love my solution without allocating extra memory\nfun validPalindrome(string: String): Boolean {\n    var i = 0\n    var j = string.lastIndex\n    while (i < j && string[i] == string[j]) {\n        i++\n        j--\n    }\n    return isPalindrome(string, i + 1, j) || isPalindrome(string, i, j - 1)\n}\n\nfun isPalindrome(string: String, start: Int, end: Int): Boolean {\n    var i = start\n    var j = end\n    while (i < j) {\n        if (string[i] != string[j]) {\n            return false\n        }\n        i++\n        j--\n    }\n    return true\n}', 'class Solution:\r\n    def validPalindrome(self, s: str) -> bool:\r\n        def checkValid(l,r):\r\n            while l<r:\r\n                if s[l]!=s[r]:\r\n                    return False\r\n                l,r = l+1,r-1\r\n            return True\r\n        l,r = 0,len(s)-1\r\n        while l<r:\r\n            if s[l]!=s[r]:\r\n                return (\r\n                    checkValid(l+1,r) or\r\n                    checkValid(l,r-1)\r\n                )\r\n            l,r = l+1,r-1\r\n        return True', ""I'm a little confused about how this solution is not runtime of O(n^2).\nThe outside while loop is 0(n). Then the reversal (skipL/skipR[::-1]) inside of the while loop is O(n).\nSince it's nested, I'd think that would be O(n^2).\nAm I missing something?"", '2:00', 'Reversing a string is not really the optimal way to determine if it’s a palindrome. It uses extra memory and you also have to iterate over the whole string. With two pointers you only iterate half the string. Still O(n) but should be a bit faster on average! But I see you mentioned it at the end of the video anyway so great job.', 'with helper function O(1) space\nclass Solution:\r\n    def validPalindrome(self, s: str) -> bool:\r\n        left = 0\r\n        right = len(s) - 1\r\n    \r\n        while left < right:\r\n            \r\n            if s[left] != s[right]:\r\n                return self.is_palindrome(s, left+1, right) or self.is_palindrome(s, left, right-1)\r\n            \r\n  \r\n            left += 1\r\n            right -= 1\r\n        return True\r\n        \r\n        \r\n    def is_palindrome(self,s, start_index, end_index):\r\n        while (start_index < end_index):\r\n            if s[start_index] != s[end_index]:\r\n                return False\r\n            \r\n    \r\n            start_index += 1\r\n            end_index -= 1\r\n        return True', 'class Solution:\n    def validPalindrome(self, s: str) -> bool:\n        def is_valid_palindrome(l,r):\n            while l < r:\n                if s[l] != s[r]:\n                    return False\n                l +=1\n                r -=1\n            return True\n        l_pointer = 0\n        r_pointer = len(s)-1\n        while l_pointer < r_pointer:\n            if s[l_pointer] == s[r_pointer]:\n                l_pointer +=1\n                r_pointer -=1\n            else:\n                if is_valid_palindrome(l_pointer+1,r_pointer):\n                    return True\n                if is_valid_palindrome(l_pointer,r_pointer-1):\n                     return True\n                return False\n            \n        return True', 'Can you create a hash map and check if the number of Keys in the map is greater than 2 return false since there is more than two unique characters that if we choose to delete any of them it would still not be a palindrom. Return true if the amount of Keys is 2 or less?', 'Can I get guidelines to practice on ABAP in the site you mentioned ?']"
54,_d0T_2Lk2qA,"['thanks for help!!!', 'Incase someone is looking for a solution for a string:\ndef reverse(s):\n\tif len(s) == 0:\n\t\treturn s\n\treturn (reverse(s[1:]) + s[0])\n\nHere is how it works:\nInput: ""hello""\nreverse(""hello"")\n    reverse(""ello"") + ""h""\n        reverse(""llo"") + ""e""\n            reverse(""lo"") + ""l""\n                reverse(""o"") + ""l""\n                    reverse("""") + ""o""\n                    => """" + ""o""\n                => ""o"" + ""l""\n            => ""ol"" + ""l""\n        => ""oll"" + ""e""\n    => ""olle"" + ""h""\n=> ""olleh""', 'Other way: \nnew_str_list = []\r\nnew_str_list[:0] = """".join(str_list)[::-1]\nreturn new_str_list', 'Oh great!', 'What about...\nreturn s[::-1]\n???', ""Slicing works but Incase interviewer doesn't allow us to use built in functions then swapping is great"", 'Thanks', 'Why s=s[::-1] is not working? Could you please tell.', 'using slice trick print(s[::-1]) should work as well', ""Isn't s.reverse() also works for this problem?""]"
55,YUF3_eBdzsk,"['Python - https://github.com/neetcode-gh/leetcode/blob/main/410-Split-Array-Largest-Sum.py', 'If your code is not working then try returning low after the if else condition at last it was cut down from the video. Returning should solve your problem', 'was stuck on this one, thanks a lot for explaining it so well', '⬇Simple Code | TC: O( n*log( sum(nums) ) | SC: O( 1 )\n\tint splitArray(vector<int>& nums, int m) {\n        int l=0,r=0,n=nums.size();\n        for(int i=0;i<n;++i) l=max(l,nums[i]), r+=nums[i];\n        \n        int mid=0,ans=0;\n        while(l<=r){\n            mid=(l+r)/2;\n            int count=0,tempsum=0;\n            for(int i=0;i<n;++i){\n                if(tempsum+nums[i]<=mid) tempsum+=nums[i];\n                else count++,tempsum=nums[i];\n            }\n            count++; \n            \n            if(count<=m) r=mid-1, ans=mid;\n            else l=mid+1;\n        }  \n        return ans;\n    }', 'Can we build a prefix sum array and use it somehow to solve the problem greedily or binary search on the same array?', 'Why is the canSplit function """"return (subarry +1 <= m)"""" and not """"""return ((subarry +1) == m) """"""? Don\'t we need to make sure all the splits can occur? For example, if the target is MAX_INTEGER (in case the sum of nums), then this will be true.', 'can we do by keep target=sum(nums)//k and finding the split?', ""It's basically the painters partition problem"", 'Is this question similar to book allocation problem of ggg?', 'classy explanation']"
56,RXy5RzGF5wo,"['for some reason the constructor keeps going over my head', ""You CAN do it recursively in Python by writing a Generator function, which uses *yield* and *yield from.* The end result is a very clean in-order recursive traversal that's been consumed sequentially, but with O(h) memory ( O(1) for our own state + O(h) where Python keeps track of the generator state)."", 'Still dont get why does has next work?', 'Can someone please verify if it could be done this way?\n\nclass BSTIterator:\n\n    def __init__(self, root: Optional[TreeNode]):\n        \n        arr=[]\n        def flatten(root):\n            if(root):\n                flatten(root.left)\n                arr.append(root.val)\n                flatten(root.right)\n        \n        flatten(root)\n        self.arr=arr\n        \n    def next(self) -> int:\n        return(self.arr.pop(0))\n\n    def hasNext(self) -> bool:\n        return(self.arr)\n        \nI just done a inorder traversal before hand and store it in an array', 'Great Explanation !!!', 'amazing solution! thanks a lot for posting:)', 'Does there exists a solution with O(1) space complexity for this problem?', 'You are always very helpful! I wish I could work with you in the future!', 'Omg! Thank you so much! I love your videos Neetcode! Just curious, could you also solve Perfect Rectangles?', 'Man U doing more leetcode than me and u already have a job ☠️']"
57,s4DPM8ct1pI,"['running it with m=l+r//2 doesnt work anymore you have to use m=l+l-r//2 only, otherwise it gives a time limit exceeded error', 'This video was easy to digest, I will give a try on 2 more videos of yours. if they are easy to understand as well, I will signup for NeetCode premium membership.', ""It's fascinating how beginner friendly this explanation was despite how professional you are, thank you"", 'the recursive approach.\n        if len(nums) == 0:\r\n            return -1\r\n        mid = (len(nums)) // 2\r\n\r\n        if nums[mid] == target:\r\n            return mid\r\n        elif nums[mid] > target:\r\n            return self.search(nums[:mid], target)\r\n        else:\r\n            result = self.search(nums[mid+1:], target)\r\n            startIdx = mid + 1\r\n            if result != -1:\r\n                return startIdx + result\r\n            else:\r\n                return -1', 'understood', 'How can  the list be added in the program????', 'Thank you for the video! Is there a way to do this with recursion??? Thanks!', ""but you also have to  add something for that solution of overflow problem, Because when the array have only one element, right would be negative in te while loop, they've been tricky these days"", 'Great video! It helped me with this! \nFor those coding in JavaScript, be sure to make the middle variable:   let middle = Math.round((left + right) / 2);   Otherwise the value will be 2.5 instead of 3.', 'Thanks for the video! I think it helps to mention the // syntax is a floor division, I have been implementing unnecessary checks on whether the array length is odd or even🥲']"
58,d-B_gk_gJtQ,"['Replacing sorting with median finding makes this solution O(n) in time complexity.', 'I can always code the solution after I hear your explanation. I never see your code. But getting that thought and approach always stump me and I keep on thinking complicated intuitive ways to solve it.', 'Can someone please explain why DP solution had complexity O(n*n).', ""I was asked this question in one of the interview. I couldn't solve it. Because its really HARD. Just because leetcode marks them as medium it doesn't need to be medium. And interviewers grade you thinking that you can't solve medium also. So its a reject. Honestly, what's the point of these question in real world use case. Which company is running short of budjet to send employee overseas so that they can make millions for the company only. These questions are so useless"", 'I am sure why cache would work with just counts, as countA=1 and countB=1 with two different total received mean different output, which means we not calculate all possibilities, any help?', 'we can do A-B and then take the first half of array for A and 2nd half for B. That will also work.', 'looked very difficult. but i actually understood how to get there!', 'another approach is to think this way: first all would go to city A, and now you have to move one person to city B while keep the total cost to be minimum, what would you do? after the move the cost would be sum(a)-a[k]+b[k] = sum(a)-(a[k]-b[k]), so you would move the person that has the highest difference from b-a. and then so on and so forth.', 'Can I plz see the alternative way to solve it using DP in code form? Thanks.', 'does using heaps to sort while appending is little better?']"
59,XbaxWuHIWUs,"['I think Kinda same \n```\npeople.sort()\n        n = len(people)\n\n        c = 0\n        l = 0\n        r = n -1\n        while l <= r:\n            if people[l] + people[r] <= limit:\n                l += 1\n                r -= 1\n                c += 1\n            else:\n                r -= 1\n                c += 1\n\n        \n        return c\n\n```', 'as always clear explanation I just watched the drawing part, I coded it differently', ""There is no need to write l<=r inside if as it's already considered in the loop....."", 'The if condition make no sense. ?', 'what is the app used to do all these drawings and sketching?', 'is the time complexity nlogn + n ?', 'new challenge', 'LeetCode: faster than 3% of Python3 submissions\nNeetCode: as you can see its prettty efficient xD \n\nthanks for the great videos btw', 'i used the 2 pointer approach also, but coded it a bit different.\nwhile (left <= right) {\r\n    let weight = people[left] + people[right]\r\n    if (weight % limit === 0 || weight % limit === weight) {\r\n      count++;\r\n      left++;\r\n      right--;\r\n    } else {\r\n      count++;\r\n      right--;\r\n    }\r\n  }\r\n  return count;', 'fun pb and crisp explanation as usual!! ']"
60,gkINMhbbIbU,"[""intresting! I did it a very similer way but differ syntax style. Unlike you I looked for the initial starting edges for island 1 and then did the bfs.\n\n        q=deque()\r\n        visited=set()\r\n        def findEdge(i,j): \r\n            if (i<0 or i==len(grid) or\r\n                j<0 or j==len(grid[0]) or\r\n                (i,j) in visited):\r\n                return\r\n            \r\n            if grid[i][j]==0:       # edge found, add to q\r\n                q.append([i,j,1])\r\n                return\r\n            \r\n            visited.add((i,j))\r\n            \r\n            for x,y in [[1,0],[-1,0],[0,1],[0,-1]]:\r\n                findEdge(i+x,j+y)\r\n\n         '''  This could be improved  '''\r\n        flag=True\r\n        for i in range(len(grid)):\r\n            for j in range(len(grid[0])):\r\n                if grid[i][j]==1:\r\n                    findEdge(i,j)\r\n                    flag=False\r\n                    break\r\n\r\n            if not flag:\r\n                break\r\n\r\n        \r\n        while q:\r\n            i,j,count=q.popleft()\r\n\r\n            if (i,j) in visited:\r\n                continue\r\n\r\n            if grid[i][j]==1:\r\n                return count-1\r\n            \r\n\r\n            visited.add((i,j))\r\n            for x,y in [[1,0],[-1,0],[0,1],[0,-1]]:\r\n                if(0<=x+i<len(grid) and 0<=y+j<len(grid[0])):\r\n                    q.append([x+i,y+j,count+1])"", 'I hate coding because I don’t like having to move my fingers on the keyboard to anything that isn’t just letters 😂', 'Thank you so much for your solution. I have spent one hour stuck on this problem.', 'Finally it make sense how to solve this problem and why we do all of these things, thank you', 'very helpful!', 'What is the need of dfs in here could I not traverse the entire grid and push the values which are simply ones', 'Beautifully explained . Thank you', 'C#  Implemenation\n\n   public class Solution\r\n    {\r\n        readonly int[][] directions = new int[][] { new int[] { 0, 1 }, new int[] { 0, -1 }, new int[] { 1, 0 }, new int[] { -1, 0 } };\r\n        HashSet<(int, int)> visited = new HashSet<(int, int)>();\r\n        public int ShortestBridge(int[][] grid)\r\n        {\r\n            Queue<(int R,int C)> q = new Queue<(int R, int C)>();\r\n            for (int i = 0; i < grid.Length; i++)\r\n            {\r\n                for (int j = 0; j < grid[0].Length; j++)\r\n                {\r\n                    if (grid[i][j] == 1)\r\n                    {\r\n                        DFS(grid, i, j, q);\r\n                        return BFS(grid, q);\r\n                    }\r\n                }\r\n            }\r\n           return -1;            \r\n        }\r\n\r\n        private void DFS(int[][] grid, int row, int col, Queue<(int R, int C)> q)\r\n        {\r\n            if (row < 0 || row >= grid.Length || col < 0 || col >= grid[0].Length || visited.Contains((row, col)) || grid[row][col] != 1)\r\n            {\r\n                return;\r\n            }\r\n            visited.Add((row,col));\r\n            q.Enqueue((row, col));\r\n            dfs(grid, row - 1, col, q);\r\n            dfs(grid, row, col + 1, q);\r\n            dfs(grid, row + 1, col, q);\r\n            dfs(grid, row, col - 1, q);\r\n            return;\r\n        }\r\n\r\n        private int BFS(int[][] grid, Queue<(int R, int C)> q)\r\n        {\r\n            int res= 0;\r\n            while (q.Any())\r\n            {\r\n                int size = q.Count;\r\n                while (size > 0)\r\n                {\r\n                    var row_col = q.Dequeue();\r\n                    foreach(int[] dir in directions)\r\n                    {\r\n                        int r = dir[0] + row_col.R;\r\n                        int c = dir[1] + row_col.C;\r\n                        if (r >= grid.Length || r < 0 || c >= grid[0].Length || c < 0 || visited.Contains((r, c)))\r\n                        {\r\n                            continue;\r\n                        }\r\n                        if (grid[r][c] == 1)\r\n                        {\r\n                            return level;\r\n                        }\r\n                        else\r\n                        {\r\n                            visited.Add((r, c));\r\n                            q.Enqueue((r, c));\r\n                        }\r\n                    }\r\n                    size--;\r\n\r\n                }\r\n                res+= 1; \r\n            }\r\n            return res;\r\n        }\r\n    }', 'awesome explanation man!!', 'When I understand the key point is DFS(a very basic island problem) + BFS (a very basic shortest path), then I can solve this problem by myself.\nThanks a lot.']"
61,68a1Dc_qVq4,"[""The line ->while cur > stack[-1]  is giving me the error:\n'>' not supported between instances of 'int' and 'list'\nI dont understand why, what do I do??"", 'Can someone help me fix my code\n// public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n//         HashMap<Integer, Integer> mp = new HashMap<>();\n//         int p = -1;\n\n//         mp.put(nums2[nums2.length -1],-1);\n//         int max = nums2[nums2.length-1];\n//         for(int i = nums2.length-2; i>=0; i--){\n//           int current= nums2[i];\n//             if(current < max){\n//                 if(i!=nums2.length && nums2[i+1] > current){   \n//                     max = nums2[i+1];\n//                     mp.put(current,max );}\n//                 }\n//             else mp.put(current,-1);\n            \n//             max = Math.max(current,max);\n            \n//         }\n//         int[] res = new int [nums1.length];\n//         for(int i =0; i< nums1.length; i++){\n//             res[i] = mp.get(nums1[i]);\n//         }\n//         return res;\n//     }', 'Perfect explanation. Very helpful. Thanks so much.', 'my solution was O ( n * m) but still had the same runtime as your optimized code lmao', ""@12:59  Can anyone please explain to me line 4, where it's written as { n: i for i, n in enumerate(nums1)}? Shouldn't it be {i:n for i, n in enumerate(nums1)} to match both i and n? Thanks!"", 'First calculate the next greater element (NGE) of each element in nums2 starting from the right, such that NGE(nums2.length-1) = -1 and NGE(i) = max(nums[i+1], NGE(i+1)). Store the values in a hashmap. This is O(nums2.length). Next, iterate over the elements of nums1 from left to right, accessing the values in the hashmap. This is O(num1.length).', 'How did you calculate the space complexity for the stack part?', 'This is definitely not an easy problem!!', 'How is this easy?!!', 'How is this Easy?']"
62,Z6idIicFDOE,"['Perfect explanation', 'Simplified a little bit :\nimport collections\r\n\r\nclass FreqStack:\r\n\r\n    def __init__(self):\r\n        self.count = {}\r\n        self.groups = collections.defaultdict(list)\r\n        \r\n    def push(self, val):\r\n        self.count[val] = self.count.get(val, 0) + 1\r\n        self.groups[self.count[val]].append(val)    \r\n\r\n    def pop(self):\r\n        result = self.groups[max(self.groups.keys())].pop()\r\n        self.count[result] -= 1\r\n        if self.groups[max(self.groups.keys())] == []:\r\n            self.groups.pop(max(self.groups.keys()))\r\n        return result', ""I don't think you need to keep track of the maximum.  A frequency can only ever be incremented (increased by one).  Thus the maximum frequency can only ever rise by one.  Thus it is enough to keep an array, indexed by frequency-1.  Its size is then the maximum frequency."", 'neetcode is like the rachel maddow of all tech youtubers...... best explainer everrrrrrr...', 'I always feel released when I got stuck in a problem but found out that you have posted a video solution on it. Thanks NeetCode!! Keep going!!!!', 'Yes, thought of the heap solution n(log n) -> O(n^2) worst case :(', 'superb explanation', 'Very good solution', 'Heap will work, just keep the heap index of a valand update its freq and do top to bottom and bottom to top...', 'My implementation, I find it one more intuitive :)\n---------------------------------------------------------\nclass FreqStack:\r\n    def __init__(self):\r\n        self.c = count(0)\r\n        self.pq = []\r\n        self.freq = defaultdict(int)\r\n\r\n    def push(self, data):\r\n        self.freq[data] += 1\r\n        heapq.heappush(self.pq, (-self.freq[data], -next(self.c), data))\r\n\r\n    def pop(self):\r\n        while self.pq:\r\n            _, _, d = heapq.heappop(self.pq)\r\n            self.freq[d] -= 1\r\n            return d\r\n        raise KeyError(""pop from empty cache"")']"
63,j4KwhBziOpg,"['Feels like you were not feeling well while making this video as I am following yor videos for quite long time now.\nWe appreciate your efforts bro 🙂', ""I think it should be len(self.numList)-1 shouldn't it? Or you'll constantly have the wrong index"", 'I used a Doubly Linked List to store the vals and operate in O(1) time. Is that overcomplicating things?', 'In numMap are the values mappedd as.{val:index} or {index:val} ?', 'Hi. I use the build set type.\n\nclass RandomizedSet:\r\n\r\n    def __init__(self):\r\n        self.setNum = set([])\r\n\r\n    def insert(self, val: int) -> bool:\r\n        isPresent = val not in self.setNum\r\n        self.setNum.add(val)\r\n        return isPresent\r\n\r\n    def remove(self, val: int) -> bool:\r\n        isPresent = val in self.setNum\r\n        self.setNum.discard(val)\r\n        return isPresent\r\n\r\n    def getRandom(self) -> int:\r\n        return random.choice(list(self.setNum))\r\n        \r\n\r\n# Your RandomizedSet object will be instantiated and called as such:\r\n# obj = RandomizedSet()\r\n# param_1 = obj.insert(val)\r\n# param_2 = obj.remove(val)\r\n# param_3 = obj.getRandom()\n\nThe memory used is equal of your solution. However, my runtime if almost 3x your solution. I guess because I needed to convert the set into a list to use the random. What do you think?', ""Thanks NeetCode! just want to say it actually won't work when removing the last item! changing line 20 and 21 will fix it."", ""Doesn't using len making it O(n) though?"", ""That's awesome man, thanks a lot :)"", 'I was thinking maybe a LinkedHashMap (Java) since it maintain insertion order.', 'what an explanation man,  perfect !!! 🙌🙌🙌']"
64,FzTYfsmtOso,"['time complexity will be O(n*k)\nwhere k = length of string slicing.\n\nto do it in O(n), you have to use rolling hash algorithm.', ""hash sets hash the input. I don't think it saves space. Similar to websites that limit how long your password can be. No website saves your password, they save a >100 character long hash of your password"", 'I dont understand in example one, why ""aaaacccca"", ""aaacccccaa|"",""aacccccaaa"",etc not in the output? they also appeared more than once in the string', 'Done thanks todo take note\nUsing hashset to store every 10 letter sequence in the string to check if seen before\nIf seen before then add it to results hashset so using two hash sets one to identify seen and one to hold the results as a sequence can be found multiple times', 'why this is not working:\n    vector<string> findRepeatedDnaSequences(string s) {\r\n        int n = s.size();\r\n        vector<string> ans;\r\n        if(n < 10) return ans;\r\n        map<string,int> m;\r\n        int i=0;\r\n        int j=0;\r\n        \r\n        string temp = """";\r\n        while(j < n){\r\n            temp += s[j];\r\n            if(j-i+1 < 10) j++;\r\n\r\n            else if(j-i+1 == 10){\r\n                m[temp]++;\r\n                //so that it will be included only once if more than one occurence\r\n                if(m[temp] == 2) ans.push_back(temp);\r\n                j++;\r\n            }\r\n\r\n            else{\r\n                temp.erase(0,1);\r\n                i++;\r\n                j++;\r\n            }\r\n        }\r\n        return ans;\r\n    }', 'Thanks', 'Can someone explain why we do -9 in the for loop?', 'i used a hash map with super long keys lol', 'I think we can use a hashmap instead of a set for seen and the value could be false (meaning we didn’t add to result yet) by default and when seen second time and we add it to our result, we can update it to true.\n\nThat way our result can be a list from the start and second check of true or false value would ensure we don’t add it to our result twice.\n\nAll said, thank you for a detailed, easy to understand explanation', ""Solution : \nEvery iteration starting from index i = 0 -> size of string - 9\nyou are getting the substring of 10 characters out from i'th index and adding them to the set, while also checking if the added substring exists in the set.\nAnd if it does, add it to result (which means the 10 character substring appeared more than once).\nThen finally returning the result. \n\nI understand this very clearly but wouldn't come up with it on the spot.. I guess more practice in recognizing these patterns will eventually help me get through interviews at tech companies.\nGood luck everyone""]"
65,ft0owvS5tQA,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'My technical interview with a big oil company had 2D programming :(', 'IMO if there is a better channel for coding interview prep it is not in this this world,  this is IMO by far the best resource to prepare, everything well organized , excellent explanations and a lot more. Million thanks', 'Can we get an update to this and maybe a walk through on these patterns on separate videos?', 'I think Eulerian Circles belong to this list as well', 'How is this true ?', '6:34 Ah yes, “Djikstra”, the famous pioneer of computer science…', 'Great vid!', 'why heapify time complexity is O(n) .', ""When I started to prepare dor DSA 6 months ago, I only had a theoretical understanding of the concepts you've said here. \n\n6 months in, now I've solved 150 questions and my understanding of all these concepts is pretty good. \n\nYou're a great resource dor coding interviews. Please do some videos on LLD also since that's more important than HLD for junior levels.""]"
66,evUFsOb_iLY,"['lol best ending', 'do you use any AI algorith?', 'Thanks for the great explanations. Can you please do leetcode 790 as well?', 'Brilliant solution! \nmy first thought was actually to use a two-pointer solution (because I just bunged your videos discussing two-pointer  😋)\nit took O(n) time and O(1) space (the algorithm is in place by nature, but in python or other immutable string you kind of forced to convert to an array of characters)\n\nthe idea is very simple, just three lines:\n1) the fast pointer stops when it encounters either R or L.\n2) If it\'s an R, move the slow pointer here and find the next R or L; If its an R again or the end of string, fill the gap with Rs, else move to the next iteration.\n3) If it\'s an L, check if the slow pinter is a dot, if so fill the gap with Ls; if the slow pinter is an R, fill the gap with Rs and Ls, and potentially a middle dot.\n\r\n\nclass Solution:\r\n    def pushDominoes(self, dominoes: str) -> str:\r\n        dominoes = list(dominoes)\r\n        slow, fast = 0, 0\r\n        while fast < len(dominoes):\r\n            if dominoes[fast] == ""R"":\r\n                # R...L\r\n                # R.R.R\r\n                # RR...\r\n                # ""R....""\r\n                slow = fast\r\n                fast += 1\r\n                while fast < len(dominoes) and dominoes[fast] == ""."":\r\n                    fast += 1\r\n                if (\r\n                    fast == len(dominoes)  # end of string\r\n                    or fast < len(dominoes)\r\n                    and dominoes[fast] == ""R""\r\n                ):\r\n                    # R.... fast == len(dominoes)\r\n                    # R...R dominoes[fast] == ""R""\r\n                    # RR... dominoes[fast] == ""R""\r\n                    dominoes[slow:fast] = [""R""] * (fast - slow)\r\n                    slow = fast\r\n                # else:\r\n                # R...L will be addressed in the next iteration\r\n            elif dominoes[fast] == ""L"":\r\n                if dominoes[slow] == ""R"":\r\n                    # if (fast - slow) % 2 == 0\r\n                    # .R...L.\r\n                    # 0123456\r\n                    # 5 - 1 = 4\r\n                    # there will be a middle domino\r\n                    # otherwise\r\n                    # .R..L.\r\n                    # 012345\r\n                    # 4 - 1 = 3\r\n                    # so there will be no middle domino\r\n                    middle = int((fast - slow) % 2 == 0)\r\n                    dominoes[slow + 1 : fast] = (\r\n                        [""R""] * ((fast - slow) // 2 - middle)\r\n                        + ["".""] * middle\r\n                        + [""L""] * ((fast - slow) // 2 - middle)\r\n                    )\r\n                    slow = fast + 1\r\n                    fast += 1\r\n                else:\r\n                    # L...L\r\n                    # ....L\r\n                    dominoes[slow:fast] = [""L""] * (fast - slow)\r\n                    slow = fast + 1\r\n                    fast += 1\r\n            else:  # .\r\n                fast += 1\r\n        return """".join(dominoes)', 'i wasnt able to pass 5 t.c , neetcode always makes me think that  i am kind of stupid.', 'The video ended abruptly\nWas that only for me ?', 'Great video! To avoid the worst case O(n^2) and get a pure O(n) solution, just find and handle intervals occupied by “.” in one pass using sliding window. This method passed all tests.', ""Java Soln:\n\nclass Solution {\r\n    public String pushDominoes(String dominoes) {\r\n        ArrayDeque<Pair<Integer,Character>> que = new ArrayDeque<>();\r\n        char [] list = dominoes.toCharArray();\r\n        for(int i=0;i<dominoes.length();i++){\r\n            char c = dominoes.charAt(i); \r\n            list[i]=c;\r\n            if(c != '.'){que.add(new Pair<>(i,c));}\r\n        }\r\n        while(!que.isEmpty()){\r\n            var pairs = que.poll();\r\n            int index = pairs.getKey(), ch = pairs.getValue();\r\n            if(ch=='L' && index>0 && list[index-1]=='.'){\r\n                que.add(new Pair<>(index-1,'L')); list[index-1]='L';\r\n            }\r\n            else if(ch=='R' && index+1<dominoes.length() && list[index+1]=='.'){\r\n                if( (index+2 < dominoes.length() ) && (list[index+2]=='L') ){\r\n                    que.poll(); \r\n                }\r\n                else{\r\n                  que.add(new Pair<>(index+1,'R')); list[index+1]='R';  \r\n                }\r\n            }\r\n        }\r\n       return String.valueOf(list);\r\n    }\r\n}"", 'Do I watch him too much so we came up with exactly the same solution?', 'how about finding the standing dominoes?']"
67,g_S5WuasWUE,"['Did you know, you can do iterative in / pre / post order traversals using same code??\nCheckout how I did it in just 20 lines, in my new video\n\nhttps://www.youtube.com/watch?v=6wxNc8gCj8E', 'I guess instead of inner while Ioop, we could simply use if condition , am I right ?\ndef inorder(root):\n    curr, stack = root, []\n    res = []\n    while curr or stack:\n        if curr:\n            stack.append(curr)\n            curr = curr.left\n        else:\n            curr = stack.pop()\n            res.append(curr)\n            curr = curr.right\n    return res', 'thank you after your explanation i can do it on my own, the description was afwul', 'heyyy brooo thanks alot❤', 'May I know why only stack is considered hare ??', 'This iterative solution is pretty unintuitive.', 'can you please explain Morris Traversal algorithm, please.', 'You have literally every single question explained, jesus. Thank you man I love you!', 'This is fantastic, thank you.', 'Welp the iterative solution is 5 lines, be gone from twitter you not-hardcore pleb!']"
68,5rHz_6s2Buw,"['i did it in O(1) by using the formula i(i+1)//2= n of n natural numbers, then find out the one positive(real) root (by the fomula (-b+(underroot(-b+4ac))//2a) and return  int(root)', 'when you said u consider it as a medium level problem , I got relieved.', 'Hey @NeetCode,\n\nI think the time complexity of the brute force soution should be sqrt(N) instead of O(n) since the loop is starting at 1 and will not go upto N.\nIt will go upto Please do correct me if I am wrong. Thanks!', ""Just wanted to let you know your code doesn't pass the test cases. Line 8 should be changed to mid*(mid+1)/2"", 'my issue with binary search problems is that for the while loop I never know whether to use l  <  r or l  <= r, is there some way I can tell which one to use based on the problem given?', 'Simply the Best! I have no words!', ""Is there a typo somewhere in this solution? I've been breaking it down, and comparing it with what I have typed up, but I keep getting a few failed test cases."", 'There is no need to use max().\nI try this solution and it works on leet code with over 1300 test case.\nthe solution:\nclass Solution:\r\n    def arrangeCoins(self, n : int):\r\n        start, end = 0, n\r\n        while start <= end:\r\n            mid = (start+end)//2\r\n            guess = mid*(mid+1)//2\r\n            if guess > n:\r\n                end = mid-1\r\n            elif guess <= n:\r\n                start = mid+1\r\n                row = mid\r\n        return row', 'How was this easy question then? I mean code is easy, but the thought process was not', 'This can also work :                                                                                                                                                                                  def arrangeCoins(self, n):\n        """"""\n        :type n: int\n        :rtype: int\n        """"""\n        row = 0\n        i = 0\n        while n > 0:\n            if n >= (i + 1):\n                row += 1\n            n = n - (i + 1)\n            i += 1\n        return row']"
69,EYeR-_1NRlQ,"['Can we write condition\n if  target<0:\n       Return', 'Not the 4sum i was looking for but not disappointed either', 'Every time I get stuck on leetcode question, I first find your video on youtube rather than check the editorial.', 'Nice solution', 'Nice solution', 'Hi,\n\nCan you please explain why did you pop the last value from quad?\n\nthanks', '4? Whats next? 5? This is getting crazy', 'It been a long time what', ""I love when you make tiny errors in your code, it's funny how you react to it"", 'Hi, I have a confusion regarding the position of ""return"" statement. From what I learned, we should put ""return"" at the end of the base case. However, I\'m quite confused that in this question it can pass no matter we put ""return"" at the end of general case (like Neetcode did in the video), or at the end of the base case (k==2), or without ""return"" statement inside nSum function. Can someone help to explain this? tysm!']"
70,OKcrLfR-8mE,"[""Yep, it's hard to come up with the part 'i-remainder[r] > 1' by my own. It's great that we leave in the era of streaming to gain best practices"", 'I managed to do this on my own with prefix sum approach. My approach is different though and is more than O(n). Following is the code.\n\n    bool checkSubarraySum(vector<int>& nums, int k) {\n\t\t\tint sum = 0;\n\t\t\tunordered_map<int, int> hash;\n\n\t\t\tfor (int i = 0; i < nums.size(); i++) {\n\t\t\t\tsum += nums[i];\n\n\t\t\t\tif (!i) {\n\t\t\t\t\thash[sum] = i;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (sum % k == 0) return true;\n\n\t\t\t\tint j = 0;\n\t\t\t\twhile (k * j < sum) {\n\t\t\t\t\tint rem = sum - k * j;\n\n\t\t\t\t\tif (hash.count(rem) && i - hash[rem] >= 2) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tj++;\n\t\t\t\t}\n\n\t\t\t\tif (!hash.count(sum)) hash[sum] = i;\n\t\t\t}\n\n\t\t\treturn false;\n    }', 'great explanation bro💗', 'i laughed when i saw the solution its sooooooo clever', 'Could it be solved using Brute force  method?  If solved, then how?', 'thanks, great intution.', 'great solution', 'What if we wanted to know where or wich list entries give us this multiple?', ""just best. I'm watching you for about a year and just wanna say that u'r the best! Thanks for ur job!"", 'used this to solve 974. made a few changes. \n\ndef checksumarray_k(nums, k):\r\n  remainder={0:[-1]}\r\n  total=0\r\n  count=0\r\n  for idx, element in enumerate(nums):\r\n    total+=element\r\n    r=total%k\r\n    if r not in remainder:\r\n      remainder[r]=[idx]\r\n    else:\r\n      count+=len(remainder[r])\r\n      remainder[r].append(idx)\r\n  return count']"
71,VD9NACqBCw4,"['Btw this was identified as a Google question from leetcode 😛: https://leetcode.com/discuss/interview-question/352460/Google-Online-Assessment-Questions', 'class Solution:\r\n    def minDominoRotations(self, tops: List[int], bottoms: List[int]) -> int:\r\n        def rotations_to_make_equal(target, A, B):\r\n            """"""Returns the number of rotations required to make all of A equal to target.\r\n            Uses B for possible rotations. If it\'s not possible, returns float(\'inf\').""""""\r\n            rotations = 0\r\n            for i in range(len(A)):\r\n                if A[i] != target and B[i] != target:  # Cannot make this domino equal to target\r\n                    return float(\'inf\')\r\n                if A[i] != target:  # Need to rotate this domino\r\n                    rotations += 1\r\n            return rotations\r\n\r\n        # Calculate the minimum rotations required for each number from 1 to 6\r\n        min_rotations = float(\'inf\')\r\n        for num in range(1, 7):\r\n            min_rotations = min(min_rotations, rotations_to_make_equal(num, tops, bottoms))\r\n            min_rotations = min(min_rotations, rotations_to_make_equal(num, bottoms, tops))\r\n\r\n        # If no valid rotations are found, return -1\r\n        return min_rotations if min_rotations != float(\'inf\') else -1', ""@NeetCode - can you tell us if you had to peek at the solution or if you figured this out on your own? How does one even come up with a O(2n) solution without either spending a great deal of time on the problem or being a complete genius?\n\nThis is an unusually harder problem that looks very simple at first. I found two places in the code harder/unintuitive to understand but it made sense after looking at it with fresh eyes :)\n\nOne: the reason why we take only the first top and bottom as targets is because if they aren't there in the rest of the indices in either of the arrays, the result is a -1.\nTwo: the return statement in the inner for-loop. This was harder than the first one. I kept thinking why is he returning without exhausting the processing for both the targets! But the only way the top[0] (target 1) reaches till the end is if it was present at all the indices of either of the arrays, but it also means the bottom[0] (target 2) which is still unexplored is either the same as top[0] or it is **not** present at all the indices in either of the arrays.\n\n\nI may find this harder to understand again if I look at this problem after 2 years. I think anyone can come up with a O(6n) solution but it takes special talent to come up with a O(2n) solution."", 'Thanks for all the videos. One quick question. I know you use a nice drawing pad for all your videos. Did you/were you allowed to use it during the interview? If not, what did you use to draw conceptual figures such as a tree? Thanks again!', 'Have you ever heard of PEP8?!', ""Hey NeetCode - just wanted to say thanks so much for the videos you've put out. I have been watching you for the last year and you've really helped me with my prep as well as my confidence.\nI was offered a job to a great company the other day, and I can definitely say you were a large part of why I was able to pass the interview.\n\nThank you again! Truly appreciate the effort you've put in."", 'Hey Neetcode, can you do LeetCode 314, since it is a pie number and you never done that?', ""Hi @Neetcode, I really liked your videos! It's great to see you illustrating the solution in such a neet and easy to understand way! I would also appreciate you if you can also make similar videos to Google Code Jam problems, which are also very difficult but very interesting!"", 'Hey Neet,\ncould you go over LeetCode #109, Convert Sorted List to BST? Thanks!', 'Hey I mentioned you in my LinkedIn post! Thank you for your help man, you helped me get into FAANG!! Connect with me there, I owe you a drink!']"
72,iu0082c4HDE,"['Java Code (by a viewer): https://github.com/ndesai15/coding-java/blob/master/src/com/coding/patterns/stacks/ReversePolishNotation.java', 'Note that using a//b in python is not the same as using int(a/b). Double slash is floor division which will also round down with negative numbers. int(a/b) will round toward zero', 'How can you pop if the stack is empty?', 'I love your videos. Minor issue was the explanation of popping the stack to assign values to a and b. You say that we want to “subtract the one that was popped second from the one that was popped first”. I believe you just mixed up the words, but in case others got slightly confused, b actually gets the value that is popped first and a gets the value popped second. This is clear if you take an input example [2, 1, -], which you actually discussed at 4:30 in the video, this would be 2 - 1. Therefore you would want to subtract the one popped first from the one popped second. And in python, because tuple unpacking is done right to left, b did indeed get the first popped value, so your solution is still valid despite mixing up the words.', ""for subtracting can't we multiply -1 to the result in the default order?"", 'i have no clue why I thought RPN was so much harder than it really is', 'If I am using javascript what can i do when declaring [a, b] ? I try to do const [a, b] and const [c, d] so avoid having the same variable declaring twice. Its there a better way to do this? Thanks a lot for the video as always! learning so much!', 'how did you add right bracket using keyboard shortcut at timestamp 7:28 ?', 'for anyone debugging, you have to do int(b / a) because b // a will not work!', 'Genius!']"
73,8u-H6O_XQKE,"['To be honest your solutions are usually pretty unreadable, I think readability should be prioritized over conciseness or the usage of ""tricks"" but that might just be me', 'Appreciated bro✅✅✅✅', ""why don't we heapify"", ""I came up with this solution except for the edge case where one of the inputs is zero. Thank you so much for your videos. You're the reason for most of the coding skills I have acquired."", ""I am super excited I literally solved this problem myself but the code is identical! all the same except I have 3 if statements at the beginning instead of putting 3 input arguments into a list and then loop over the list. I feel super motivated, @NeetCode thank you very much! You can't believe how the community is thankful!"", ""Why don't we heapify?"", 'Thank you so much! Amazing content!', 'You are simply the BEST! Thanks a ton!', 'Can u explain for this a=0 b=8 c=11?I tried in java !', 'Hi, Can you please solve ""Find Closest Palindrome"" I am struggling with that question for a long time.']"
74,WDx6Y4i4xJ8,"[""Wait, how can you compare strings like integers, it compares the ascii value right, so shouldn't we use int(n1+n2) > int(n2+n1) ?"", ""I'm not sure why, but this is returning a NULL value in each case when I try to run it. Is there any solution to this??"", 'did anyone else tried extracting just the first character and arranging as such and got stuck.', 'You are the best one yet. Your videos had been helping me so much, from struggling doing medium, to now conquering medium leetcode. Your positive energy also giving me such a good vibe to work on supposed to be boring  and painful leetcode questions. ❤❤❤ Thank you.', 'The sound feels like ASMR, which makes me personally feel disturbing. Content is clear', 'Damn You are good', ""Hey can anyone explain why we return -1 when n1 + n2 > n2 + n1? I'm confused about how returning -1 or 1 works here..Thanks!"", 'for anyone looking for Javascript solution\n\n\nvar largestNumber = function(nums) {\n    nums = nums.map(n => \'\'+n);\n    \n    nums.sort((a,b) => {\n        let num1 = a+b;\n        let num2 = b+a;\n        \n        if (+num1 > +num2) {\n            return -1;\n        } else if (+num2 > +num1) {\n            return 1;\n        } else {\n            return 0;\n        }\n    });\n    let res = nums.join("""");\n    if (res[0] === \'0\') // for case [0,0] ==> ""00"", expected is ""0""\n        return ""0"";\n    else\n        return res;\n};', ""Javascript solution that mimicks a bubble sort by swapping positions\n\nvar largestNumber = function(nums) {\r\n  for(var i = 0; i < nums.length; i++){ \r\n    for(var j = 0; j < ( nums.length - i -1 ); j++){\r\n      // Checking if the item at present iteration \r\n      // is greater than the next iteration\r\n      if(Number(`${nums[j]}${nums[j+1]}`) < Number(`${nums[j+1]}${nums[j]}`)) {\r\n        // If the condition is true then swap them\r\n        var temp = nums[j]\r\n        nums[j] = nums[j + 1]\r\n        nums[j+1] = temp\r\n      }\r\n    }\r\n  }\r\n  const result = nums.join('')\r\n  return result[0] == 0 ? '0' : result\r\n}"", 'Wow this is a genius solution wtf']"
75,nhAsMabiVkM,"[""I don't think that you need that list and additional memory.\nYou need just 1 pointer to the last uncovered element\n\nclass Solution:\r\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\r\n        A = sorted(intervals, key=lambda x: (x[0], -x[1]))\r\n        L,R = A[0]\r\n        res=1\r\n        for v in A[1:]:\r\n            if not(L<=v[0] and R>=v[1]):\r\n                L,R = v\r\n                res+=1\r\n        return res\nfaster than 97.30% of Python3"", 'class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort()\n        prevStart, prevEnd = intervals[0][0], intervals[0][1]\n        count = 0\n\n        for start, end in intervals[1:]:\n            if prevEnd >= end or (start == prevStart and end >= prevEnd):\n                prevEnd = max(end, prevEnd)\n                count = count + 1\n            else:\n                prevStart = start\n                prevEnd = end\n        \n        return len(intervals) - count', 'class Solution:\r\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\r\n        intervals.sort(key = lambda x:(x[0], -x[1]))\r\n        count = len(intervals)\r\n                \r\n        c, d = intervals[0]\r\n        for i in range(1, len(intervals)):\r\n            a, b = intervals[i]\r\n\r\n            if (c <= a and d >= b):\r\n                count -= 1\r\n            else:\r\n                c = a\r\n                d = b\r\n        \r\n        return count', 'As the intervals are already sorted the `if prevL <= L ` conditions seems extra.', 'A more efficient solution, without extra memory:\n----------------\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\r\n        intervals.sort(key=lambda range: (range[0], -range[1]))\r\n        last_interval = intervals[0]\r\n        remove = 0\r\n        for range in intervals[1:]:\r\n            if range[1] <= last_interval[1]:\r\n                remove += 1\r\n            else:\r\n                if range[1] > last_interval[1]:\r\n                    last_interval = range\r\n        return len(intervals) - remove', 'I solved it the same way yesterday in C++ but got about 20% CPU and memory scores... I am confused', 'Using a more classic neetcode style for a similar perf: \ndef removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x : x[0], reverse=True)\n        stack = []\n        for j in range(len(intervals)):\n            while stack and stack[-1][1]<=intervals[j][1]:\n                stack.pop()\n            stack.append(intervals[j])\n        return len(stack)', 'Huh, initially I thought, hold on, this wont work for cases like - [[1,4], [2,6], [4, 8]]. Here, [2, 6] is covered by the others combined. So, a better approach would be creating a contiguous timeline and look for missing segments - something like that. Then I re-read the problem description - ""remove all intervals that are covered by **another interval** in the list"" - ""another interval"",  not multiple intervals.', 'Can you solve 395. Longest Substring with At Least K Repeating Characters, it has many solutions and each one is confusing.\nYour explanations are really good.', 'doesnt sort funtion will use looping within to sort the array, so it is still n2 time complexity']"
76,aBbsfn863oA,"[""I found the solution using list more intuitive. Here's the code:\nclass MyCircularQueue:\n\n    def __init__(self, k: int):\n        self.q = [] * k\n        self.size = k\n        \n\n    def enQueue(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        \n        self.q.append(value)\n        return True\n\n    def deQueue(self) -> bool:\n        if self.isEmpty():\n            return False\n        \n        self.q.pop(0)\n        return True\n\n    def Front(self) -> int:\n        return self.q[0] if not self.isEmpty() else -1\n\n    def Rear(self) -> int:\n        return self.q[-1] if not self.isEmpty() else -1\n\n    def isEmpty(self) -> bool:\n        return len(self.q) == 0\n\n    def isFull(self) -> bool:\n        return len(self.q) == self.size"", 'Always found linked lists easier to deal with than index manipulation xD', 'cleared a lot of my doubts. thankyou', 'thanks for the easy solution...', ""I feel that by using a linked list, you have not implemented a circular queue at all. Instead, you have only implemented a fixed-size queue. In that sense you have not captured the essence of the question, and I'm pretty sure if you did that in an interview they might not look too favourably upon it.\nThere are cases where a circular queue is necessary, for instance when allocating and deallocating memory is expensive, or when the garbage collector doesn't run often (or maybe there isn't one) and you just keep consuming more memory for all the ListNodes you have to create."", 'thanks  because you upload daily', 'Appreciate the effort you have taken to give a linked list solution. The array solution can be easily understood looking at the submissions in leetcode. This would have been more difficult for me to grasp. So thank you so much !!!!!', 'Thank you so much! your explanations are the only thing that keeps me going', 'Thank you so much Neetcode', 'Really good explanation.....😍']"
77,cFabMOnJaq0,"['Easy to solve intuitively but hard to implement.', 'Open a problem -> try to solve -> if not successful, open youtube -> type ""question_name"" + neetcode\nThis is how my interview prep looks like!\nExplanations are so simplified and  so easy to understand! Cannot thank you enough', 'isnt the smallest number 1122 in the solve example thou', 'super explanation👍👍', 'logic to strip leading zeros needed to be modified otherwise I am getting below error\nValueError: Exceeds the limit (4300) for integer string conversion: value has 9001 digits; use sys.set_int_max_str_digits() to increase the limit', 'you made it so easy....thanks man', 'I got the exact same intuition and conceptual approach but i cant implement in code. I found my mistake it was about the unremoved k integers from the back of the number', 'the code is not working\n\nValueError: Exceeds the limit (4300) for integer string conversion: value has 9001 digits; use sys.set_int_max_str_digits() to increase the limit\r\n    return str(int(res)) if res else ""0""\r\nLine 15 in removeKdigits (Solution.py)\r\n    ret = Solution().removeKdigits(param_1, param_2)\r\nLine 43 in _driver (Solution.py)\r\n    _driver()\r\nLine 54 in <module> (Solution.py)\n\nwhat to do ?', 'You are such a great soul!', ""Alternative:\nif the goal is to remove K digits to find the lowest value, then we can rephrase this as:\n- find the subsequence of length solutionLen = N - K which represents the smallest numeric value\nThen we can implement this by iterating (N-K times) by selecting the smallest value from left up to some maximum ending index, where max ending index  is calculated to be N - solutionLen + i (where i is our iteration index)\nIn each iteration we select the smallest value and its corresponding index, and then enter the next iteration to search for the next minimum value, starting with the last iteration's corresponding idx.\n\nThis has naievely N squared time complexity, but we can use a segment tree to efficiently get minimums in a segment, so that our minimum search aborts early (in constant time aggregated).""]"
78,Kk6mXAzqX3Y,"['Thank You', 'you are the best!!!', 'Why this code gives TLE?\n\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode insertionSortList(ListNode head) {\r\n        ListNode helpHead = new ListNode(-9999, head); //without set pointer dummy.next is works\r\n        ListNode curr = head;\r\n\r\n        while (curr != null) {\r\n            ListNode prev = helpHead; \r\n            while(prev.next != null && prev.next.val <= curr.val){ //if insertion position is just after helpHead (insert curr to first pos, then prev = helphead)\r\n                prev = prev.next;\r\n            }\r\n            ListNode next = curr.next;\r\n            curr.next = prev.next;\r\n            prev.next = curr;\r\n           \r\n            \r\n            curr = next;\r\n        }\r\n\r\n        return helpHead.next;\r\n    }\r\n}', 'Shukriya !', ""tmp = dummy, or you will not sort first element. Dummy is not even used after it's initialized."", 'super helpful', 'Hello, why my code in java is not correct(Time Limit Exceeded)?        \n\n        ListNode dummy = head;\n        ListNode curr = head.next;\n        ListNode prev = head;\n        ListNode tmp = null;\n        \n        while( curr != null){\n            if (curr.val >= prev.val){\n                prev = curr;\n                curr = curr.next;\n                continue;\n            }\n            \n            tmp = head;\n            while(curr.val > tmp.next.val){                \n                tmp = tmp.next;\n            }\n\n            prev.next = curr.next;\n            curr.next = tmp.next;\n            tmp.next = curr;\n            curr = prev;\n        }\n\n        return dummy.next;', 'Great Job, That was so helpful.', 'after initializing the dummy node, which point to head. When assigning head to prev with (prev = head). Are you assigning the dummy node to prev or the old head to prev? 9th line', 'Thank you! This is very clear.']"
79,vGsyTE4s34w,"['""google pays me well but not well enough to afford leetcode premium"". Come on man!', 'You could have made the if statement smaller. if (not i%2 ^ nums[i] < nums[i-1]). That way you xor over the both cases and only if both are true or false it will ttigger. It is slightly different though, as the second case would also be executed with <=, but that is ok for the problem.', 'Google should give employees free leetcode premium as perk~', 'Lintcodee user', 'If the array contains duplicate elts then?', ""who's here because they tryna solve Wiggle Sort 2 first lol"", 'Looking forward to watching wiggle sort Ⅱ : )', 'rip our boy posted this on valentines day. we need a neetgirl for our neetcode', 'Hey - can you make a video for Wiggle Sort 2? \nAs always, this was super easy to understand. Thanks!', 'This explanation was spot on. So grateful']"
80,slYh0ZNEqSw,"[""Sorry the video cuts off before the code is complete, here's the full code: https://github.com/neetcode-gh/leetcode/blob/main/python/901-Online-Stock-Span.py"", 'Maybe it is easier to push price/index pair to stack. Then span=currIndex-prevIndex.', 'class StockSpanner:\r\n\r\n    def __init__(self):\r\n        self.stack = []\r\n\r\n    def next(self, price: int) -> int:\r\n        span = 1\r\n\r\n        while self.stack and price >= self.stack[-1][0]:\r\n            span += self.stack[-1][1]\r\n            self.stack.pop()\r\n        self.stack.append([price, span])    \r\n        \r\n        return self.stack[-1][1]\r\n\nThank you neetcode', 'right?', 'Great video thanks!!', ""Nice approach ♥️\nI thought of something(without using pair)what if we use a count variable that is set to 1 then we push an element in stack and if the stack was empty we push 1 to our ans array. \nIf the top of stack has larger element than incoming element then we will also push 1 since there will be no consecutives. \nIf the top has element smaller than our incoming element than we pop until larger element is found and increment the count and push this count to ans array now for the next element if it will be larger than previous element than then can use previous count and for the rest element we can pop again and add to count and push to ans this way we don't have to use pair.."", '11:19 What happened if the number is 65 instead ???', 'Thank you very much. I finally understood monotonic stack. Neetcode is a true legend', '@NeetCode Even though each element will be added and removed at Max one time, but the comparisons we had to make to compute span of a particular position can be more than 1.\nSo time complexity would be O(n*n).\n\nDetailed explanation: what we are basically doing is summing up the spans of previous peeks, provided previous peeks are smaller than the current value for which we are computing span.\nE.g. if data is [1,5,10,2,4,9,4,5,8,13], then to compute the span of 13, we will have to sum up spans of previous peaks smaller than 13, i.e. span(8) + span(9) + span(10).', 'The video ends for me at 15:18, cutting off before the code is completed.']"
81,W_akoecmCbM,"[""saying that i love this channel is literally saying nothing :'))) <333333"", 'class Solution:\r\n    def wordPattern(self, pattern: str, s: str) -> bool:\r\n\r\n        words = s.split("" "")\r\n        patt = [i for i in pattern]\r\n\r\n        a=[]\r\n        b=[]\r\n\r\n        for i in patt:\r\n           a.append(patt.index(i))\r\n        for i in words:\r\n            b.append(words.index(i))\r\n\r\n        if a==b:\r\n            return True\r\n        else:\r\n            return False', 'It is very good solution thank you for all of your efforts. Your videos help me a lot. I did it very similarly with minor difference. I kept track of mapped letters of pattern using HashSet instead of HasMap but I still used HasMap to map the words with letters. Contains method of set is also O(1) and I think it better not to store the words again. Basicly I think in this way time complexity is the same but it is more efficient in terms of memory. If I think wrong inform me please.\n\nclass Solution {\n    public boolean wordPattern(String pattern, String s) \n    {\n        var words = s.split(""[ ]"");\n        var wordMap = new HashMap<String, Character>(); \n        var mappedChrs = new HashSet<Character>();\n\n        if (pattern.length() != words.length)\n            return false;\n\n        for (var i = 0; i < words.length; i++) {\n            var word = words[i];\n            var patternChr = pattern.charAt(i);\n\n            if (!wordMap.containsKey(word)) {\n                if (mappedChrs.contains(patternChr))\n                    return false;\n\n                wordMap.put(word, patternChr);\n                mappedChrs.add(patternChr);\n            }\n            else if (wordMap.get(word) != patternChr)\n                return false;\n        }\n\n        return true; \n    }\n}', 'this problem is exactly same as 205. Isomorphic Strings except the words and the small use of split function.', 'Clean solution! Nice.', 'Hello, I made an attempt to explain this solution using simple intuitive approach, you can check this out 😉\nhttps://www.youtube.com/watch?v=tRCDoqo0l40', 'yes it does and its pretty efficient!', 'taking lessons from google employer', ""There is a mistake in time complexity analysis.\nThe actual complexity is O(n * m), where n is number of words, and m is width of the longest word.\nWhy?\nFirst, on the 11-th line each time we compare word from hash map with word from zip.\nSecond, on the 13-th line because each time when we check w in wordToChar, hash-map doing 2 things:\n1)  The hash comparison.\n2) After checking hash, the words comparison.\nThe comparison is loop with m iterations, and it's nested into zip loop with n iterations."", 'I found you today, thank you sooo much.']"
82,xW4QsTtaCa4,"[""Thank you. Just one question. Any reason for using 'res > 0 and res < 0' instead of 'res == 1 and res == -1' based on the description of the problem?"", 'Thank you so much for this.', 'why the solution is Time Limit Exceeded for me ?', ""On Leetcode, the running can't find the API guess and return this error, any one knows what is happening?\n\nNameError: name 'guess' is not defined. Did you mean: 'gauss'?\r\n    res = guess(m)\r\nLine 18 in guessNumber (Solution.py)\r\n    Solution().guessNumber(10)\r\nLine 28 in <module> (Solution.py)"", 'Hi,\nTo prove what I wrote yesterday I am now a subscriber :) Thank you again.', 'Damm how do people think up this strategiesss??? Cheat sheet??', 'u are best', 'I have an interview soon with Microsoft. Any other suggestions for a common problem?', 'Please do Skyline Problem. 🙏🙏', 'I am JavaScript and C++ developer, is that okay to watch your videos in python directly or should I first learn Python ?']"
83,Cg_wWPHJ2Sk,"['I have this wseird isssue. U used binary search, but what if we just take z= sqrt(num) and check if z*z==num? This should be better. And also, it was accepted.', 'When searching for the square root, we could use the upper bound as (num // 2) since the square root will always be less than (num // 2).  That will make algorithm more efficient, but big O will stay the same.', 'not sure in python but in java we have to declare left right and mid pointers of type long thank you for this video appreciated', 'Thanks!', 'Was asked this question in my yesterday interview.', 'Really helpful content!', 'Thank you so much.Your videos are really helpful.....😊👍', ""You could get slightly better time complexity with log base 10 by checking if the number is less than 100, \nIf it is more than 100, you divide the list at 1/10th the max instead of 1/2. This works because of the exponential growth of square numbers, it's much better to guess  lower."", ""It's almost cheating that you don't need to worry about overflow in Python"", 'your voice changed. take care.']"
84,o-YDQzHoaKM,"['Python Code: https://github.com/neetcode-gh/leetcode/blob/main/658-Find-K-Closest-Elements.py', 'restart everything over again~~ wish me good luck', 'Does anyone know why the right pointer is simply arr[mid] + k, and not arr[mid] + k - 1? I thought there is a need to offset the index', 'it\'s much easier to reason the solution if you think in terms of ""arr[mid] + arr[mid + k] < 2 * x"", because both extremes of the array are at most going to be 2 * x if every element in the array is equal to x', 'In cases where k is as big as n, O(log n + k) is as good as O(n) only. Considering sorted nature could sliding window be implemented in log(k)?', 'can any body please explain me why we are taking r=m and not r=m-1', 'ahh haa moment', 'Whoever came up with this solution surely has the IQ of a sociopath💀', 'great solution..but if you are not able to explain this then you are screwed! the interviewer will know that you have mugged it up  :p', 'What if we use lower bound and then apply two pointers !???']"
85,QhPdNS143Qg,"['Python Code: https://github.com/neetcode-gh/leetcode/blob/main/678-Valid-Parenthesis-String.py', ""I came up with an easier solution O(n) space O(1)\nIt requires two passes\nclass Solution {\r\n    public boolean checkValidString(String s) {\r\n        int conflicts=0;\r\n        int resolvers=0;\r\n        for(int i=0;i<s.length();i++){\r\n            if(s.charAt(i)=='('){\r\n                conflicts++;\r\n            }\r\n            else  if(s.charAt(i)==')'){\r\n                if(conflicts==0){\r\n                    if(resolvers>0)resolvers--;\r\n                    else return false;\r\n                }\r\n                else{\r\n                    conflicts--;\r\n                }\r\n            }\r\n            else resolvers++;\r\n        }\r\n\r\n        conflicts=0;resolvers=0;\r\n        for(int i=s.length()-1;i>=0;i--){\r\n            if(s.charAt(i)==')'){\r\n                conflicts++;\r\n            }\r\n            else  if(s.charAt(i)=='('){\r\n                if(conflicts==0){\r\n                    if(resolvers>0)resolvers--;\r\n                    else return false;\r\n                }\r\n                else{\r\n                    conflicts--;\r\n                }\r\n            }\r\n            else resolvers++;\r\n        }\r\n        return true;\r\n        \r\n    }\r\n}"", ""bool solve( int i , int cnt , string &s){\r\n        if( i == s.length() ){\r\n            return cnt == 0;\r\n        }\r\n\r\n        bool ans = false;\r\n        if( s[i] == '('){\r\n            \r\n            ans = solve(i+1 , cnt+1 , s);\r\n        } \r\n        else if( s[i] == ')' && cnt-1 >= 0){\r\n            \r\n            ans = solve( i+1 , cnt-1 , s);\r\n        }\r\n        else{\r\n            \r\n            bool ans2 = false;\r\n            if( cnt-1 >= 0 ) {\r\n                ans2 = solve(i+1 , cnt-1 ,s);\r\n            } \r\n            ans = solve(i+1 , cnt+1 , s) || solve(i+1 , cnt , s ) || ans2;\r\n            \r\n        }\r\n\r\n        return ans;\r\n    }\r\n\r\n    bool checkValidString(string s) {\r\n        return solve( 0 , 0 , s);\r\n    }\n\nthis recursive relation is not working i want to know why .........plzzz anybody can help me"", 'I will just go with 2 Stack solution :P', ""My two cents on the reset of negative leftMin, basically there're two sources we decrease the values of leftMin:\n1. when we meet the ')' \n2. encounter '*'. \nIf we have more than enough of ')' leftMax will become negative, and we will directly return false. However, if we don't return, and we get negative leftMin, which means we get more than enough '*' since we can transform the '*' to an empty string, this is how this -1 to 0 comes. \nFor eg,  \n(**"", ""Couldn't find the link for the DP or memorization solution, can anyone please let me know where I can find it?"", 'Hi NeetCode, I noticed that this this problem is under ""Stack"" and the actual code in Java use Stack, but your video explanation is something else. What is preferred?', ""A good explanation for the reason why we need a special resetting work for and only for leftmin can be: \n\nA string can be invalid only if either it contains more left parentheses than right parentheses and vice versa or their positions violate the balance rule. \n\nLeftmax can help us detect all possible violations but one: some left parentheses do not have matching right parentheses. We leave this mission to leftmin.\n\nWe traverse the string for the left to the right, and the leftmin is responsible for recording the most possible choices of the right parenthesis. However,  a right parenthesis can never match a left one which is right to it.\n\nSo, whenever leftmin is less than zero, we will have no other choices apart from considering it(the character we are visiting)  not existing and resetting it(leftmin) to zero. By doing that, we assure that we will never match a right parenthesis to a left one which is right to it. \n\nTherefore, upon traversing the string, if leftmin is still larger than zero, we can be certain that there are unmatched left parentheses and return false. We can also be certain that every left parenthesis is matched otherwise, and since all possible 'right parenthesis' violations would have been detected by leftmax during the traversal, if we can finish the traversal, it is certain that every right parenthesis is matched, so it's safe to return true"", '1. Why is the recursive + caching solution O(N^3) 5:20 ? Seems like it would be same as space complexity O(N^2).\n2. The greedy approach is not well explained. Why will it return false iff the string is invalid?', ""if(leftMax < 0 )  return false; \n // even we selected * as ( still right parenthesis are more then left parenthesis\n   \nf(leftMin <0 ) leftMin=0; \n// last time we choose * as ')' was our wrong choice so neglect that thing""]"
86,aYqYMIqZx5s,"['Thank you, I was struggling to this question until I found your video', 'This was a pretty complicated problem. Thanks a lot for helping me understand it.', 'Can anybody help me with understanding the complexity of the solution coded here?', 'When neet say things like: ""well this is easy solution"" or ""this is just a standard xyz algo"" just makes a dumbhead like me feel even dumber.', '@neetcode sir .in this question follow up is to solve this by binary search....please help me to do using binary search...atleast please give a hint how we can solve  using binarysearch..please', 'Much appreciated, the explanation is way better than any Leetcode solution provided.', 'wait, they got rid of the ""contiguous"" part on the problem. Is it still contiguous?', 'amazing! love it', 'Really feel relaxed when i am looking for a solution of a problem on youtube  and find your vedio ❤❤', 'great... You makes coding fun']"
87,G9xeB2-7PqY,"[""I feel like my solution is a bit dumb but here ... : \n\ndef MNOB(n:str): \r\n    Balloons =['b','a','l','o','n']  \r\n    counter = 0\r\n    for c in n :\r\n        if c in Balloons:\r\n            counter+=1     \r\n    return counter // 7"", 'Thanks for video.\nDo you know a solution without using hash?', 'Neetcode please upload Videos from 1100 to 2000 Leetcode Problems.I cant find proper solutions from leetcode 1100 to 2000', 'This was what I came up with:\ndef bla(text):\r\n    word = ""balloon""\r\n    hash_map = {}\r\n    for i in text:\r\n        if i in word and i not in hash_map:\r\n            if i == ""l"" or i == ""o"":\r\n                hash_map[i] = text.count(i) // 2\r\n            else:\r\n                hash_map[i] = text.count(i)\r\n    if len(hash_map.keys()) == len(set(word)):\r\n        return min(hash_map.values())\r\n    else:\r\n        return 0', 'For someone Who wanna do it in a hardcode way:\n        hashmap = {}\n        balloon = {}\n        example = ""balloon""\n        \n        for n in text:\n            hashmap[n] = 1 + hashmap.get(n, 0)\n        \n        for x in example:\n            balloon[x] = 1 + balloon.get(x, 0)\n        \n        res = len(text)\n        for c in balloon:\n            res = min(res, hashmap[c] // balloon[c] if c in hashmap else 0)\n        return res', 'Thank you so much . Excellent explanation. Before I watched the solution, I tried to figure that out on my own. My idea is to divide the values the two dictionaries and then take the min value from the resulting dictionary, so I guess  I end up with a poorer  time complexity  ( O(n) for dividing the values  and O(n) (at most) when I am searching the minimum value )  .', 'This solution is invalid when result is 0', 'i see improvements every day from watching your videos', 'what do you use for drawing on the screen like that?', 'It’s much easier and much faster to use an array of 26 ints and map the characters to them..']"
88,8i-f24YFWC4,"['goodquestion', ""ok that's fucking cool"", 'Yeah I can go back to McDonald if this is easy question....', 'can you please name this algorithm', 'Do it with cyclic sort, will be less confusing✌', ""I've devised following solution, but I'm not sure if it still counts as O(1) memory:\nclass Solution:\r\n    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:\r\n        nums = [0] + nums\r\n        for n in nums:\r\n            if nums[abs(n)] > 0:\r\n                nums[abs(n)] *= -1    \r\n            \r\n        return [i for i,v in enumerate(nums) if v > 0]"", 'I had a hard time to understand the problem:\n\nMy way of understanding is:\n\nWe are using the indexes to our advantage as they are in range of n. So we are marking the values at the indexes as -ve to signify(the number in the array) is marked visited by putting a -ve sign on the particular index. Finally we loop through all the elements and find which indexes are not -ve and then return them.', 'if some people dont understand this very clearly, there is this sorting technique called cyclic sort ( sorts array in O(n) if elements are in range of [1,n] ). look it up , will be useful.', 'I feel like doing this in constant space makes it a medium', 'good stuff! thanks!']"
89,Pzg3bCDY87w,"['Python Code: https://github.com/neetcode-gh/leetcode/blob/main/752-Open-the-Lock.py\nJava Code: https://github.com/ndesai15/coding-java/blob/master/src/com/coding/patterns/bfs/OpenLock.java', 'Shouldn’t “0000” be added to the visit set as well? What happens when children(1000) returns “0000”, wouldn’t that cause an infinite loop?', 'Shouldn\'t we have added ""0000"" to the visit set in the beginning?', 'I have written code like this in c++ but this is leading to TLE and I cant figure out why ? Can anyone help \n\nclass Solution {\r\npublic:\r\n    vector <string> children(string x) {\r\n        vector <string> v;\r\n        for (int i=0; i<4; i++) {\r\n            char a = (((x[i] - \'0\') + 1) % 10) + \'0\';\r\n            v.push_back(x.substr(0, i) + a + x.substr(i+1));\r\n            char b = (((x[i] - \'0\') - 1 + 10) % 10) + \'0\';\r\n            v.push_back(x.substr(0, i) + b + x.substr(i+1));\r\n        }\r\n        return v;\r\n    }\r\n    int openLock(vector<string>& deadends, string target) {\r\n        if (find(deadends.begin(), deadends.end(), ""0000"") != deadends.end()) return -1;\r\n        queue <pair <string, int> > q; q.push({""0000"", 0});\r\n        set <string> s; s.insert(""0000""); for (auto i: deadends) s.insert(i);\r\n        while (! q.empty()) {\r\n            pair <string, int> p = q.front();\r\n            q.pop();\r\n            if (p.first == target) return p.second;\r\n            for (auto child: children(p.first)) {\r\n                if (find(s.begin(), s.end(), child) == s.end()) {\r\n                    s.insert(child);\r\n                    q.push({child, p.second+1});\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n};', 'thank you for soldiering on', ""More of a Python question. How come we didn't return the res in the helper function but the for loop in the main function picked the child of children up? \nHow come we can iterate through the res without having it returned?\n\nThanks"", ""Simple and straightforward explanations. I'd appreciate it if you could extend the time allotted for explaining time and space complexity."", 'Thanks for the explanation. So clear!', ""Would've been interesting to see this solved using a* if you use each lock digit as a coordinate"", 'Wonderful explanation.']"
90,D0X0BONOQhI,"['I am pretty sure when they say O(m + n) they actually mean O(m + n), not O(2(m + n))', 'Really Really thank you sir', 'Thank! YOU! it took me so long to understand, your video explanation helped so much!', 'it is not accepting my answer', ""thank you! :) appreciate the hard work and effort you've put into this"", 'brilliant', 'Hi! I wrote l1 = l1.next if l1.next else headB but doing that gives my a Time Limit error. Any idea why that would be ?', ""I thought about an interesting solution. Since in the description is it specified that all node values will be positive this will work. First, go all the way through listA and flip all the values to their negatives. Now go through listB, and the first node with a negative value you find, is the intersection, but don't return it yet, just save pointer to some variable. Now finally, go all the way through listA again and unflip all the values back to positive, since the task requires us to leave the lists untouched. Now you can return your saved pointer.\n\nI sent the solution and it is accepted, give it a try. The time complexity should be O(m+n), since we're going twice through one list and once through other, and the space complexity is O(1), since you only need the variable for the saved return value and some iterators. Hope this helps!"", 'how the hell do you not have over million subscribers?', 'Is that easy level? ffs 😂']"
91,YYX93BWqQY8,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews\nNext video -> Why I left google after 3 days (as an ex-google engineer).  jk\n\n\nIn seriousness, even the name NEETcode is about unemployment (NEET is an acronym for Not in Education, Employement or Training). \nThanks to all of you and hope you have a great 2022!', ""this video really opened my eyes on how competitive this industry is\nwell if someone as good as you took that long to get a job then my chances are low since I'm not really that good and I'm doing this thing because I love it, I love gaining knowledge and the challenge. But I don't have a degree and have no plans on getting one (degree in my country is so expensive) and I can't be hired here without a degree (cultural thing) I mean I can get hired but I will be forever be working for peanuts no matter how good I get. So low that I have to get 2-3 jobs as a dev to give my family a decent life and to mention the salary cut when i make the jump is so big it's a big no no as a breadwinner, not beeing prideful but the salary cant really feed the people who look up to me. My only chance is to get really good and do freelancing and do b2b to western companies but this is extremely hard I hope I can make it."", 'Only getting the interview from Google out of so many random tech companies says lot about how shitty the current hiring trends are.', ""I lived in Seattle in the past three years. I left at mid 2022 for family unifycation.\n\nI had been walking on the same Seattle streets  as you shown in this video, countless times before. Always staring at Google's logo in front of their office and wondering, will I be able to join this company in the future? I didn't feel jealous at all because of your sincereness. Instead, I am so glad that you did, even though we don't know each other.\n\nI have been using you site for practicing leetcode. Very much appreciated the way you group those problems, it helps me keeping on a curated path toward the end goal, instead of selecting random questions.\n\nI will keep practicing until I land a dream job like you did. Thank you so much."", 'Reverse engineering practise in real life :)', 'Thank you for all your lessons!', ""I couldn't understand clearly; when you started to work at Google?"", ""Congratulations Down to earth personality sir👏 \nkeep uploading some great videos I'm loving your playlist getting a good confidence in problem solving  Love from India 🇮🇳 ❤️"", 'You deserve it :D', 'Congrats!']"
92,6lH4nO3JfLk,"['Python Code: https://github.com/neetcode-gh/leetcode/blob/main/909-Snakes-and-Ladders.py\nJava Code: https://github.com/ndesai15/coding-java/blob/master/src/com/coding/patterns/bfs/SnakesLadders.java (from a viewer - ndesai)', 'great explanation', 'I think if you did DFS it might not find the shortest path.', 'where did you take care of the case that no two snake/ladder are taken in one move', ""1:48 bro really said he never played Snake and Ladder. I'm shocked"", 'Simpler version of intToPos without reversing the board:\n\nn = len(board)\ndef int_to_pos(idx):\r\n    i = ~(idx // n)\r\n    j = idx % n if i % 2 else ~(idx % n) \r\n    return i, j', 'we are exploring every possible value from lets say from x + 1 to x + 6 for each x which gives an intution as it was a backtracking problem exploring all the possible path until reached n^^2. Is it correct or am I missing something?', 'Very easy to understand! Love this solution. You are the best YouTuber on solving Leetcode problems.', ""Here's a C++ implementation of the approach discussed above.\nI am facing problem in a test case: [[-1,-1,-1],[-1,9,8],[-1,8,9]]\nPlease help.\n\n\nclass Solution {\npublic:\n    vector<int> intToPos(int square, int n){\n        int r = (square-1)/n;\n        int c = (square-1)%n;\n        if(r%2)\n            c = n-1-c;\n        vector<int> pos;\n        pos.emplace_back(r);\n        pos.emplace_back(c);\n        return pos;\n    }\n    int snakesAndLadders(vector<vector<int>>& board) {\n        int n = board.size();\n        reverse(board.begin(),board.end());\n        queue<pair<int,int>> q;\n        q.push({1,0});\n        unordered_set<int> visited;\n        \n        while(!q.empty())\n        {\n            pair<int,int> curr = q.front();\n            q.pop();\n            int square = curr.first;\n            int moves = curr.second;\n            for(int i=1;i<8;i++)\n            {\n                int nextSquare = square + i;\n                vector<int> boardpos = intToPos(square,n);\n                int row = boardpos[0], col = boardpos[1];\n                if(board[row][col]!=-1) nextSquare = board[row][col];\n                if (nextSquare == n*n) return moves+1;\n                if(visited.find(nextSquare)==visited.end())\n                {\n                    visited.insert(nextSquare);\n                    q.push({nextSquare,moves+1});\n                }\n            }\n        }\n        return -1;\n    }\n};"", 'If we can use extra memory, the implementation of intToPos becomes way easier if we convert it to a 1D array.']"
93,qMPX1AOa83k,"['Python Code: https://github.com/neetcode-gh/leetcode/blob/main/136-Single-Number.py\nJava Code (from a viewer - ndesai): https://github.com/ndesai15/coding-java/blob/master/src/com/coding/patterns/bitwiseXOR/SingleNumberXOR.java', 'Awesome explanation!', 'let h = new Array(Math.abs(nums.length)).fill(0);\n    if(nums.length == 1){\n        return nums;\n    }\n    \n    for(let i = 0 ; i < nums.length ; i++){\n        h[Math.abs(nums[i])]++;\n    }\n    \n    for(let i = 0 ; i < h.length ; i++){\n        if(h[i] == 1){\n            return i;\n        }\n    }\n\nCan anyone tell is my approach correct or not.\nAnd it does work for positive number but not negative 😅', 'Theres an easier way to do this. The single number is simply: 2*sum(set(nums)) - sum(nums). One line thats faster than 99% of the solutions on leet', 'Thank you very much', 'Amazing, but.... how do you come up to this solutions...?', '😀😀😀', ""Man I solved this problem using sorting and hashmap but I just couldn't optimize it any further no matter what. I didn't even knew about this method."", '""Hey!, I like that you have a computer science collage degree, I also see that you have experience for your sophomore year internship, but you couldn\'t imagine an xor when the solution was more obvious with another data structure, I\'m sorry to say that you did not get selected, ah , and by the way, fuck you""', 'I come up with this solution by myself！ I am clever😁']"
94,pNichitDD2E,"['Recommend watching this one at 1.5x Speed!\n\nPython Code: https://github.com/neetcode-gh/leetcode/blob/main/python/355-Design-Twitter.py\nJava Code: https://github.com/neetcode-gh/leetcode/blob/main/java/355-Design-Twitter.java', 'This problem is actually not that hard compared to the previous several DP problems. I solved it in 20 minutes. But the DP problems? I am 100% sure I have a 0% chance to solve it.', ""I passed with a O(N log N), although it's in the 5% slowest solution"", 'nah this is insane', 'Thank You So Much for this wonderful video........🙏🏻🙏🏻🙏🏻🙏🏻🙏🏻🙏🏻', 'Thank You So Much for this wonderful video.......🙏🏻🙏🏻🙏🏻🙏🏻🙏🏻🙏🏻', ""Can someone please explain why can't we just use userId in maxHeap? The most recent tweet will always has the largest id number. Why should we use count?"", 'This question is Brilliant! Its litterally the reason to get up in the morning from you bed, just to design code to such questions. I struggled a lot with this, and after seeing a couple of tutorials on this, I came up with my C++ design for the solution of this question: ->\nstruct Tweet\n{\n    int id;\n    Tweet *next;\n    int timeStamp;\n    static int time;\n\n    Tweet(int tweetId, Tweet *nextTweet=nullptr) {\n        id=tweetId;\n        next=nextTweet;\n        timeStamp = time++;\n    }\n};\nint Tweet::time = 0;\n\nstruct TweetComparison\n{\n    bool operator()(const Tweet *tweet1, const Tweet *tweet2) {\n        return tweet1->timeStamp < tweet2->timeStamp;\n    }\n};\n\nstruct User\n{\n    int id;\n    Tweet *tweetHead;\n    unordered_set<int> followeeIds;\n\n    User() {}\n\n    User(int userId) {\n        id=userId;\n        tweetHead=nullptr;\n    }\n\n    void follow(int userId) {\n        followeeIds.insert(userId);\n    }\n    void unfollow(int userId) {\n        followeeIds.erase(userId);\n    }\n\n    void post(int tweetId) {\n        tweetHead = new Tweet(tweetId, tweetHead);\n    }\n    vector<int> getRecentTweets(int count,const unordered_map<int, User> &userStore) const {\n        vector<int> recentTweets;\n\n        priority_queue<Tweet*, vector<Tweet*>, TweetComparison> heap;\n\n        for(auto itr=followeeIds.begin(); itr != followeeIds.end(); itr++) \n        {\n            const User *followee = &userStore.at(*itr);\n            if(followee->tweetHead != nullptr)\n                heap.push(followee->tweetHead);\n        }\n        if(tweetHead)\n            heap.push(tweetHead);\n\n\n        for(int i=0; i<count && !heap.empty(); i++)\n        {\n            Tweet *curr = heap.top();\n            heap.pop();\n\n            recentTweets.push_back(curr->id);\n\n            if(curr->next)\n                heap.push(curr->next);\n        }\n\n        return recentTweets;\n    }\n\n};\n\n\nclass Twitter {\npublic:\n    Twitter() {\n\n    }\n    void postTweet(int userId, int tweetId) {\n        if(userStore.find(userId) == userStore.end())\n            userStore[userId]=User(userId);\n        userStore[userId].post(tweetId);\n    }\n    vector<int> getNewsFeed(int userId) {\n        if(userStore.find(userId) == userStore.end()) \n            return {};\n        return userStore[userId].getRecentTweets(10, userStore);\n    }\n    void follow(int followerId, int followeeId) {\n        if(userStore.find(followerId) == userStore.end())\n            userStore[followerId]=User(followerId);\n        if(userStore.find(followeeId) == userStore.end())\n            userStore[followeeId]=User(followeeId);\n            \n        userStore[followerId].follow(followeeId);\n    }\n    void unfollow(int followerId, int followeeId) {\n        userStore[followerId].unfollow(followeeId);\n    }\n\nprivate:\n    unordered_map<int, User> userStore;\n};\n\n/**\n * Your Twitter object will be instantiated and called as such:\n * Twitter* obj = new Twitter();\n * obj->postTweet(userId,tweetId);\n * vector<int> param_2 = obj->getNewsFeed(userId);\n * obj->follow(followerId,followeeId);\n * obj->unfollow(followerId,followeeId);\n */', 'At 19:05, is that only adding one tweet per followee by far?', ""I'm able to figure out how to implement a dictionary of lists, but how do you implement a dictionary of sets?""]"
95,u89i60lYx8U,"['Python Code: https://github.com/neetcode-gh/leetcode/blob/main/724-Find-Pivot-Index.py\nJava Code: https://github.com/ndesai15/coding-java/blob/master/src/com/coding/patterns/arrays/PivotIndexFinder.java\n(Provided by ndesai15 /  Neel Desai)', 'class Solution {\r\n    public int pivotIndex(int[] nums) {\r\n        int totalSum = 0 ;\r\n        for(int i = 0 ; i < nums.length ; i++){\r\n            totalSum = totalSum + nums[i];\r\n        }\r\n        int leftSum = 0 ;\r\n        for(int i = 0 ; i < nums.length ; i++){\r\n            totalSum = totalSum - nums[i];\r\n            if(leftSum == totalSum){\r\n                return i;\r\n            }\r\n            leftSum = leftSum + nums[i];\r\n        }\r\n        return -1;\r\n    }\r\n}\nCode using Java', 'happy teachers day', 'Thanks for the video! I used the prefix sum methodology for this problem and it ran efficiently, sharing it in case if anyone finds it useful.\n\ndef find_pivot_index(nums):\n    prefix = [nums[0]]\n    for i in range(1, len(nums)):\n        prefix.append(nums[i] + prefix[-1])\n\n    for i in range(len(prefix)):\n        if i == 0:\n            left_sum = 0\n        else:\n            left_sum = prefix[i-1]\n        right_sum = prefix[-1] - prefix[i]\n        if left_sum == right_sum:\n            return i\n    return -1', 'Use two arrays (of the same size as nums) to store the left sums (starting from the left) and the right sums (starting from the right) respectively. When calculating the ""next"" sum, you only need to add the value of the ""previous"" index\'s value with the partial sum already stored. (Next and previous\'s definitions depend on direction). Starting from the left, return the first index where the values are equal. Space: O(n), Time: O(n)', 'Hey Man Thanks for the smooth Explanantion ;))', 'Hi, I got a solution which is similar to yours, but instead of updating the right side by using the total left and the value of the pivot, Instead, I followed the same way we calculated the left side by taking the total right and taking away the pivot value as we move through the list (right_side -= i). Is there a reason your version is better, or are they equal roughly in speed? and Thanks for the Videos, they always help so much.', 'If you create C++videos you will be famous more than now', 'Thanks buddy ....loves a ton for this vdo...totally worth it', 'Logic was to focus on non zeros numbers . But the question focused on zeros. Good question']"
96,2g_b1aYTHeg,"['Python Code: https://github.com/neetcode-gh/leetcode/blob/main/767-Reorganize-String.py\nJava Code (Provided by a viewer): https://github.com/ndesai15/coding-java/blob/master/src/com/coding/patterns/heap/ReOrganizeString.java', 'No need ""if prev and not maxHeap"". it\'s confusing. \njust ""return res if len(res)==len(s) else """""".  \n\nIf there are no extra letters for combining the maximum number of letter.  The maximum number of letter won\'t push in the minheap. which means it can not fill in all letters.', 'Whats the approach if they asked for minimum swaps required to make the possible string??', 'thanks for the great explanation, in just first 6 min understood how to solve problem', 'I watched this video till 5:35 and was able to code it myself. Thanks.\n\nC++ Guys:\nclass Solution {\r\npublic:\r\n    struct Compare{\r\n        bool operator()(pair<char,int>a,pair<char,int>b){\r\n            return a.second<b.second;\r\n        }\r\n    };\r\n    string reorganizeString(string s) {\r\n        unordered_map<char,int>mp;\r\n        for(int i=0;i<s.size();i++)\r\n            mp[s[i]]++;\r\n        priority_queue<pair<char,int>, vector<pair<char,int>>,Compare>pq;\r\n        for(auto it:mp)\r\n            pq.push({it.first,it.second});\r\n        string ans;\r\n        char prev=\'\\0\';\r\n        while(!pq.empty()){\r\n            pair<char,int>top=pq.top();\r\n            pq.pop();\r\n            if(top.first!=prev){\r\n                prev=top.first;\r\n                ans+=top.first;\r\n                top.second--;\r\n                if(top.second>0)\r\n                    pq.push(top);\r\n            }\r\n            else if(!pq.empty()){\r\n                pair<char,int>top2=pq.top();\r\n                pq.pop();\r\n                prev=top2.first;\r\n                ans+=top2.first;\r\n                top2.second--;\r\n                if(top2.second>0)\r\n                    pq.push(top2);\r\n                pq.push(top);\r\n            }\r\n            else\r\n                return """";\r\n        }\r\n        return ans;\r\n    }\r\n};', 'Daily dose of Neetcode! 🙌', '# from max heap\nimport heapq\nlst = list(range(1,11))\nheapq._heapify_max(lst)\nprint(lst[0])', ""A more readable solution\nclass Solution:\n    def reorganizeString(self, s: str) -> str:\n        if len(s) == 1:\n            return s\n        res = []\n        char_count = {}\n        for char in s:\n            char_count[char] = 1 + char_count.get(char,0)\n        \n        max_heap = [] #[(char_count,char)]\n        for char,count in char_count.items():\n            heapq.heappush(max_heap,(-count,char))\n        \n        while len(max_heap) >= 2:\n            top_most_count,top_most_char = heapq.heappop(max_heap)\n            next_count,next_char = heapq.heappop(max_heap)\n            \n            res.append(top_most_char)\n            res.append(next_char)\n            \n            if top_most_count + 1 != 0:\n                heapq.heappush(max_heap,(top_most_count+1,top_most_char))\n            \n            if next_count + 1 != 0:\n                heapq.heappush(max_heap,(next_count+1,next_char))\n        \n        # only one odd char left to get processed\n        if max_heap:\n            char_count,char = heapq.heappop(max_heap)\n            # not a valid case to add into result\n            if -1*char_count > 1 or res[-1] == char:\n                return ''\n            res.append(char)\n        return ''.join(res)"", ""I just did it W/O seeing any video or discussion. Guess I'm good enough for Tesla 🤣🤣🤣"", 'how do you know this problem is from tesla']"
97,wCc_nd-GiEc,"['When you said it is a doable hard, I figured lets try this till I get it accepted and after a bit of back and forth, I was able to get my code accepted.\nThis is my C++ implementation:\n\nclass Solution {\r\npublic:\r\n    int n,m;\r\n    int drow[4]={-1,0,1,0}, dcol[4]={0,1,0,-1};\r\n\r\n    bool isValid(int &row, int &col){\r\n        return row>=0 && row<n && col>=0 && col<m;\r\n    }\r\n\r\n    void solve(int row, int col, vector<vector<int>> &dp, vector<vector<int>> &matrix){\r\n        int ans=0;\r\n\r\n        for(int i=0;i<4;i++){\r\n            int nrow=row+drow[i], ncol=col+dcol[i];\r\n\r\n            if(!isValid(nrow,ncol) || matrix[row][col]>=matrix[nrow][ncol]) continue;\r\n\r\n            // figure out the sub answer first\r\n            if(dp[nrow][ncol]==-1) solve(nrow,ncol,dp,matrix);\r\n\r\n            // update the ans \r\n            ans=max(ans,dp[nrow][ncol]);\r\n        }\r\n\r\n        dp[row][col]=1+ans;\r\n    }\r\n\r\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\r\n        n=matrix.size(), m=matrix[0].size();\r\n        vector<vector<int>> dp(n,vector<int>(m,-1));\r\n\r\n        // using DP as cache to make sure each element is visited once\r\n        for(int i=0;i<n;i++){\r\n            for(int j=0;j<m;j++){\r\n                if(dp[i][j]==-1){\r\n                    solve(i,j,dp,matrix);\r\n                }\r\n            }\r\n        }\r\n\r\n        int ans=1;\r\n\r\n        // finding out the max in the dp cache\r\n        for(int i=0;i<n;i++){\r\n            for(int j=0;j<m;j++){\r\n                ans=max(ans,dp[i][j]);\r\n            }\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n};', ""Small addition, implement backtracking to slightly improve the running time. P.S. Solved this problem on my own in just 20 minutes. Can't stop thanking you."", 'Seems like this shouldn\'t really be labelled ""hard"". Some of the graph dfs medium problems are much harder', ""Amazing, thanks so much. I want to just add, I think these few lines look a bit cleaner than the 4 repeated lines of reassigning the 'res' variable.\n\n            directions = [[1,0], [0,1], [-1,0], [0,-1]]\r\n            for rowDir, colDir in directions:\r\n                res = max(res, 1 + backtrack(row+rowDir, col+colDir, cur))"", ""Is'nt not a hard.🤩"", 'Thanks man any tips to approach problem like u do?', 'Brilliant explanation!', 'The Gold Standard of Leetcode tutorials', ""A bit of trivia here.  I just read the section on DFS in Intro to Algorithms (https://en.wikipedia.org/wiki/Introduction_to_Algorithms )  The theoretical kind of DFS they define there is actually always run on all the vertices of the graph.  So anyone who read that book and was paying attention -- I wasn't :) :D -- would have this idea cold."", ""this one made me feel good about myself, cuz I knew right away it's a grid DFS with memoized storage""]"
98,aayNRwUN3Do,"['LeetCode: Do not return anything, modify nums in-place instead\nNeetCode: return nums', 'your efforts are appreciated !!!!', 'If you are confused about where does this patterns fits, read about partition alorithm. Thanks Neetcode.', ""they clearly told don't return anything"", 'How about just moving all the non-zero values to the start and just adding zeroes to the end. Beats 99.48 python users apparently', ""when 0s are not present in the list, this method swaps all the elements with itself. However, the following doesn't\n\nvar moveZeroes = function(nums) {\n  let left = 0; \n  let right = 1;\n\n  while(right < nums.length){\n    if(nums[left]){\n      left++;\n    }\n\n    if(nums[right] && nums[left] === 0){\n      const temp = nums[right]; \n      nums[right] = nums[left];\n      nums[left] = temp;\n      left++;      \n    }\n    right++;    \n  }\n  \n  return nums;\n};"", ""The implementation is super concise. However, it seems like it performs some unnecessary operations and can be a bit messy (But it's not true). Nonetheless, it works correctly even with this messy approach"", 'Nice insights of simple algorithm. Thanks!', 'My notes for this problem\n\n""""""\r\nGiven an integer array nums, move all 0\'s to the end of it while maintaining the relative order of the non-zero elements.\r\n\r\nNote that you must do this in-place without making a copy of the array.\r\n""""""\r\n\r\n\r\n""""""\r\nApproach 1: Using 2 pointer\r\nTC O(n) & SC O(1)\r\n\r\n1. Basically, It is 2 pointer quesion. It seems very easy but the way it works is quite interesting.\r\n\r\n2. Left pointer is putting every none-zero element at the right place. Wheneve left pointer find zero elemnt it will stick with it.\r\n\r\n3. Right pointer is helping left pointer to find and put non-zero element at right place. we can say that right pointer is \r\n   showing way to left pointer where to go.\r\n\r\n4. What happens if we start right pointer from the second element instead of first?\r\n   - In this case it will give wrong output. Because right pointer swap every non-zero item to left pointing item. \r\n     so it will chage the order of list.\r\n   - Swapping also occurs when right and left pointer both start from 0th position but in this case the swapping of element \r\n     happens at the same place. which does not changes the order.\r\n\r\n\r\n\r\n""""""\r\n\r\ndef moveZeroes(nums):\r\n    l=0\r\n    for r in range(0,len(nums)): #4\r\n        if nums[r]:\r\n            nums[l],nums[r]=nums[r],nums[l] \r\n            l+=1\r\n    return nums   \r\n\r\nprint(moveZeroes([0,1,0,3,12]))', ""I was confused in this line <if nums[i]> I thought He did not wrote the hole condition but then I  realise if 0 is present at ith index it will return fasle and if not then it will reurn true. So we don't hav to write hole condition here. Interesting humm!""]"
99,Vn2v6ajA7U0,"['thanks for such a great explanation brother', 'why we have to sort our input list', 'On line 8, why use `res.append(subset[::])` and not `res.append(subset[:])`?', 'I did something a little bit different here, when I drew the graph, I noticed that the duplicate values will always be next to each other in the result, so I did a comparison between the latest element in the solution and the current subset, worked like charm! \n   def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:   \n        nums.sort()     \n        res = []\n        sub = []\n        \n        def dfs(depth):\n            if depth >= len(nums):\n                res.append(sub[:])\n                return \n            sub.append(nums[depth])\n            if not res or res[-1] != sub:\n                dfs(depth+1)\n\n            sub.pop()\n            if not res or res[-1] != sub:\n                dfs(depth+1)\n\n        dfs(0)\n        return res', 'Why is the time complexity the number of combinations times the length of the longest combination? I.e. why `n * n!` instead of `n!`?', 'good video', 'if i >= len(nums):\r\n                if sorted(lst[:]) not in res:\r\n                    res.append(sorted(lst[:]))\n\nrest of the code same as subsets 1\n\nway worse time complexity since u sort every time LOL but just thought it was funny', 'Can somebody explain me why the TC is O(N*2^N)?', 'This is a similar pattern to combination sum', ""I don't understand why the TC is O(N*2^N). Is it because we can have almost N elements equal to each other?""]"
100,7FCemBxvGw0,"['did the recursive solution on my own but optimising this is tough', 'Once he draws a recursion tree i can write a recursive code', 'damm\nthat was such a good explanation', 'If I get into faang, you deserve my first salary lol. such a quality explanation', 'I am Stupid', 'good explanation', ""The fact You have to know that You need to sort it first and then eliminate duplicates is ludicrous. How on this earth is anyone supposed to come up with that? it's just guessing"", 'Ty! np: sorted() converts the set of nums array to the list in Python; can skip list() function of line #4', 'only if this dude coded in c++', 'This is an exceptionally well taught lesson']"
101,ZyB_gQ8vqGA,"['Hey, I think the time complexity should be E ^ d where d is the maximum number of outgoing flights from a particular airport. Squaring it means that the max is 2 only', 'Hey, with your solution I get a TLE error.', 'Code is not submitting on leetcode , time limit is getting exceeded', ""I like that this solution is not like the perfect 5 line submissions in leetcode. It's a well thought out solution that has intuition embedded in it. You're the man!"", 'Cannot pass all test cases for naive solution using DFS+Backtracking?', ""This solution doesn't work, it fails the 80st test case."", ""Anyone else getting a time limit exceeded result with this solution? Doesn't pass the 80th Test case for me"", ""Clearly confirm it wasn't 'doable' for me."", 'Awesome explanation', 'Great Explanation. Thank you!']"
102,LSKQyOz_P8I,"[""Problem with these videos is that the code is always the shortest possible, and not the most intuitive for beginners like me. Like how am i gonna learn when i can't clearly see the algorithm when its hidden behind a recursive overly complex solution."", '# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\r\n        if not root :\r\n            return False\r\n        if not root.left and not root.right and targetSum-root.val==0:\r\n            return True\r\n        if self.hasPathSum(root.left,targetSum-root.val):\r\n            return True\r\n        if self.hasPathSum(root.right,targetSum-root.val):\r\n            return True\r\n        \r\n        return False', ""I'm just confused when I should use preorder, inorder or postorder?"", ""This is preorder DFS and you don't need a helper function if you just subtract the root.val from target\n\nclass Solution:\r\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\r\n        if not root:\r\n            return False\r\n\r\n        targetSum -= root.val\r\n        if targetSum == 0 and not root.left and not root.right:\r\n            return True\r\n        \r\n        return self.hasPathSum(root.left, targetSum) or self.hasPathSum(root.right, targetSum)"", ""can't path stop at any node when the sum == targetSum?\nig it doesn't have to finish at the leaf node"", 'I thought return False would stop it ? I used to return None for it to keep working (backtrack).', 'since you visited the root node first, does it not make the traversal a pre-order', 'When you return dfs of both left and right nodes, does the the left node dfs run and then the right runs once the left is finished?', 'Is there any way to modify the iterative preOrder traversal script for this solution? The code for iterative preorder traversal:\n res = []\n        stack = []\n     \n        def dfs(root):\n            while stack or root:\n                while root:\n                    stack.append(root)\n                    res.append(root.val)\n                    root = root.left\n                    \n                root = stack.pop()\n                root = root.right\n                \n            return res\n        \n        return dfs(root)', 'This recursive function is a little bit harder to understand for beginners, I saw another solution without using dfs helper method and it was easier. Would you add recursion courses for beginners? Thank you.']"
103,FPCZsG_AkUg,"['I used a stack in my solution and it is pretty efficient:\n\nclass Solution:\r\n    def sortedSquares(self, nums: List[int]) -> List[int]:\r\n        stack = []\r\n        idx = 0\r\n\r\n        for val in nums:\r\n            valSqr = val * val\r\n            while stack and stack[-1] < valSqr:\r\n                nums[idx] = stack.pop()\r\n                idx += 1\r\n            \r\n            stack.append(valSqr)\r\n        \r\n        while stack:\r\n            nums[idx] = stack.pop()\r\n            idx += 1\r\n        \r\n        return nums', 'hey @neetcode, enjoyed this problem and your explanation but why is this tagged as binary search?', 'wow that was tricky', 'is there a way to do this in-place? without using a new array?', 'No need to reverse array; Java solution: \nclass Solution {\n    public int[] sortedSquares(int[] nums) {\n        int[] res = new int[nums.length];\n        int i = nums.length - 1, left = 0, right = i;\n        while (left <= right) {\n            if (Math.abs(nums[left]) <= nums[right]) res[i--] = (int) Math.pow(nums[right--], 2);\n            else res[i--] = (int) Math.pow(nums[left++], 2);\n        }\n        return res;\n    }\n}', 'that finding the maximum instead of minimum was genius. It made the code so much cleaner', 'don\'t know if this is a good question to test a candidate. I can see an IQ 300 candidate, superb programmer, if he didn\'t see this question before, he may not reach this optimal answer, versus a person who sucked at programmer but have seen this problem before, will start with this, ""oh two pointers from both sides"" method and get hired? That\'s totally unjust', ""My question to you is this: if you have a cs degree and you've never thought of code this way, how would you even begin to think that you would build an external list and then reverse it? That would have never ever occurred to me."", 'If you have to sort in the end after all. Why not just return sorted([ n ** 2 for n in nums]) ?', 'Why is this in binary search rather than two pointers?']"
104,y704fEOx0s0,"['More Graph Problems: https://www.youtube.com/watch?v=utDu3Q7Flrw&list=PLot-Xpze53ldBT_7QA8NVot219jFNr_GI&index=1', ""I converted this to JS but can't seem to pass all the test cases. I'm on 179/306. Anyone know why?\n\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar orangesRotting = function(grid) {\n  const queue = [];\n  const rows = grid.length;\n  const cols = grid[0].length;\n  let minutes = 0;\n  let fresh = 0;\n\n  const directions = [[0,1], [1,0], [-1,0], [0,-1]];\n  const inBounds = (x,y) => x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] === 1;\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j] === 1) fresh++;\n      else if (grid[i][j] === 2) {\n        queue.push([i,j])\n      }\n    }\n  }\n\n  while (queue.length && fresh > 0) {\n      for (let i = 0; i < queue.length; i++) {\n        const [r,c] = queue.shift();\n        for (const [dr,dc] of directions) {\n          const [row, col] = [dr + r, dc + c];\n          if (inBounds(row,col)) {\n            grid[row][col] = 2;\n            queue.push([row,col]);\n            fresh--;\n          };\n        }\n      }\n      minutes++;\n  }\n\n  return fresh === 0 ? minutes : -1;\n};"", 'Maaaaaaaaaaaaaaaaaaan, you are the legend', 'that kind of testing is only meaningful if you have nothing else to assess on a candidate like fresh graduate with zero experience. otherwise it\'s a good chance to miss opportunity to hire someone skillful and knowledgeable but not that good at ""challenges"" that are not even close to real software developer job challenges.\nnext time use tuples instead of lists. in many if not most scenarios set is better than deque and lists are unhashable.\nlearn `elif` - that could be life saver in real life.\nand please stop creating classes at will. It\'s Python not Java.', 'I found it less confusing if I popleft one at a time instead of 3 at a time in this example by passing in a time variable into the queue with the r,c and make sure to increment time when a good orange turns rotten. The directions array + loop makes it hard for me to follow along while I run through an example. Here is my approach, hope this helps people with my kind of monkey brain:\n\n    ROWS = len(grid)\r\n    COLS = len(grid[0])\r\n    maxTime, goodOrange = 0, 0\r\n    q = collections.deque()\r\n\r\n    for r in range(ROWS):\r\n        for c in range(COLS):\r\n            if grid[r][c] == 2:\r\n                q.append((r,c,0))\r\n            if grid[r][c] == 1:\r\n                goodOrange += 1\r\n\r\n    while q:\r\n        r, c, time = q.popleft()\r\n        maxTime = max(maxTime, time)\r\n        if r+1 < ROWS and grid[r+1][c] == 1:\r\n            goodOrange -= 1\r\n            grid[r+1][c] = 2\r\n            q.append((r+1,c,time+1))\r\n        if r-1 >= 0 and grid[r-1][c] == 1:\r\n            goodOrange -= 1\r\n            grid[r-1][c] = 2\r\n            q.append((r-1,c,time+1))\r\n        if c-1 >= 0 and grid[r][c-1] == 1:\r\n            goodOrange -= 1\r\n            grid[r][c-1] = 2\r\n            q.append((r,c-1,time+1))\r\n        if c+1 < COLS and grid[r][c+1] == 1:\r\n            goodOrange -= 1\r\n            grid[r][c+1] = 2\r\n            q.append((r,c+1,time+1))\r\n\r\n    if goodOrange > 0:\r\n        return -1\r\n    return maxTime\n\nAs always great video, thank you for the explanation!', 'Thanks man. Very great Video!', 'Amazing explanation sir. Greetings  from India', 'I\'m a month and a half into my LeetCode grind. I can\'t believe a company would say: ""Yeah, I need you to do LC 994, no aide, of the top of the dome."" Really? smdh.', ""dfs works for this algorithm. You can use a minute variable to check if the value is not empty or rotten and if it's bigger than current minute we can make it smaller.\n\nclass Solution {\n    public int orangesRotting(int[][] grid) {\n        for(int i=0;i<grid.length;i++){\n            for(int j=0;j<grid[i].length;j++){\n                if(grid[i][j]==2)\n                dfs(grid,i,j,2);\n            }\n        }\n        int minute = 2;\n        for(int i=0;i<grid.length;i++){\n            for(int j=0;j<grid[i].length;j++){\n                if(grid[i][j]==1) return -1;\n                minute = Math.max(minute, grid[i][j]);\n            }\n        }\n        return minute-2;\n    }\n    private void dfs(int[][] grid, int row, int col, int min){\n        if(row<0||col<0\n        ||row>=grid.length\n        || col>=grid[row].length \n        || grid[row][col]==0\n        ||(grid[row][col]>1 && grid[row][col]<min) //this line to check if the \n                                                    //orange already  has a smaller\n                                                    // duration to get rotten\n        ){\n            return;\n        }\n        grid[row][col] = min;\n        dfs(grid,row+1,col,min+1);\n        dfs(grid,row-1,col,min+1);\n        dfs(grid,row,col+1,min+1);\n        dfs(grid,row,col-1,min+1);\n    }\n}"", 'Thanks!']"
105,s8p8ukTyA2I,"[""Hey, NeetCode or Viewers,\nI have a doubt, according to the code 16:30\nAfter we push elements to the heap, don't we have to heapify it?"", 'Hey...your explanation is excellent and very intuitive. But it is not the most optimized solution. Can you please help me by explaining the optimized approach to solving this problem?', 'Seriously dude, don’t you have a better solution than this ?', 'How does Leetcode come up with these questions lol', 'damn. This question is hard af hahaha', 'Thank You So Much for this wonderful video...............🙏🏻🙏🏻🙏🏻🙏🏻🙏🏻🙏🏻', 'I like how you say ""this is pretty efficient solution"" while showing 18% faster result xD', 'Please solve this problem leetcode 855. Exam Room', 'You are amazing...!!! Thanks for making this content available for free. Really helps a lot...!!!', '2 3 months before, I could not understand your videos and referred to Indian creators, but once I reached a certain level, I can now understand your solutions and code it up in C++.']"
106,Tuc-rjJbsXU,"['Java code for this -\nclass Solution {\r\n    public int findNumberOfLIS(int[] nums) {\r\n        int n = nums.length;\r\n        int dp_len[] = new int[n]; //store length of LIS starting at each index\r\n        int dp_count[] = new int[n]; //store count of such LIS of length starting and each index.\r\n        Arrays.fill(dp_len, 1);\r\n        Arrays.fill(dp_count, 1);\r\n        int lenLIS = 0; //length of longest LIS\r\n        int totalCount = 0; //total no. of longest LIS\r\n\r\n        for(int i = n - 1; i >= 0; i --) { //start from right to left\r\n            int curMax = 1;\r\n            int curCount = 1;\r\n\r\n            for(int j = i + 1; j < n; j ++) { //for each ele, check if LIS exists on right\r\n                if(nums[j] > nums[i]) { //increasing order\r\n                    int len = dp_len[j];\r\n                    int count = dp_count[j];\r\n                    if(len + 1 > curMax) {\r\n                        curMax = len + 1;\r\n                        curCount = count;\r\n                    } else if(len + 1 == curMax) {\r\n                        curCount += count;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if(curMax > lenLIS) {\r\n                lenLIS = curMax;\r\n                totalCount = curCount;\r\n            } else if(curMax == lenLIS) {\r\n                totalCount += curCount;\r\n            }\r\n            dp_len[i] = curMax;\r\n            dp_count[i] = curCount;\r\n        }\r\n        return totalCount;\r\n        \r\n    }\r\n}', 'Great problem!', 'so I think this is a bottom up dp?', 'You github link is not working anymore', 'nice explaination and and way you update maxLen and maxCnt in 1 loop, never though of that because I afraid something wrong and not clear, so I do 2 seperated loops.', 'I dont do a leetcode question if there is no NeetCode video for it LOL', ""Whenever I can't follow official editorial, I go for Neetcode. You're superb in explain algorithm thought flow, and more importantly, you code according!"", 'Best explanation!! Thank you so much for this!', ""There is a O(n logn) solution for this using patience sort but it is considerably trickier to code. Also, you can store a tuple, instead of a list as dp's value."", 'Appreciated']"
107,rW4vm0-DLYc,"['Excellent Solution, Easly Understood', 'The top() could be implemented much simpler by reusing pop() and push()\n\n    def push(self, x: int) -> None:\r\n        self.q.append(x)\n\n    def pop(self) -> int:\r\n        for i in range(len(self.q) - 1):\r\n            self.push(self.q.popleft())\r\n        return self.q.popleft()\r\n\r\n    def top(self) -> int:\n        res = self.pop()\r\n        self.push(res)\r\n        return res', 'this question is so fucking dumb', 'Amazing explanation', 'System design interview simplified - https://www.youtube.com/@productmanagd', 'For any one who is saying that the top() function is implemented properly, the idea behind using the index of [-1] as he did was that there is already a function for queues called ""peek"" that you could use that gives you the last element directly, so it is safe to say that it is implemented, and we always have an idea of what the top element would be. \nHowever, if anyone faces an issue in interview where the interviewer still wants an implementation for the top() function, you could make sure to keep O(1) for it by using a value that always tracks the top value, which would be always the last one pushed, or the 2nd to last one after popping\n\nCode Example:\nfrom collections import deque\n\nclass MyStack:\n\n    def __init__(self):\n        self.q1 = deque()\n        self.peek = None\n\n    def push(self, x: int) -> None:\n        self.q1.appendleft(x)\n        self.peek = x \n\n    def pop(self) -> int:\n        n = len(self.q1)\n        for i in range(n - 1):\n            poped = self.q1.pop()\n            self.q1.appendleft(poped)\n\n            if i == n-2:\n                self.peek = poped\n        \n        return self.q1.pop()\n\n\n    def top(self) -> int:\n        return self.peek\n\n    def empty(self) -> bool:\n        return len(self.q1) == 0', 'Here, we are using deque funtionality in case of getting top element \nBut we should use it as queue\nSo we cannot directly get element from rear\nSo it is wrong i think\nFor that we should first perform operation like pop then we can get top element without popping', ""Hello can anyone please clarify if this a valid solution the time complexity is good and it beats 92% but just don't know if it is right way to do.\n\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.num = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        self.num.append(x)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        return self.num.pop(0)\r\n\r\n        \r\n\r\n    def peek(self) -> int:\r\n        return self.num[0]\r\n        \r\n\r\n    def empty(self) -> bool:\r\n        return len(self.num) == 0"", 'For pop when cant we just use self.q.popleft() thats it', 'Dear Neet, can you teach us about 232. Implement Queue using Stacks as well?   232 is on the Grind 75 list']"
108,UbyhOgBN834,"[""#this is my first solution. i didn't think of this * 26 hashmap. i keep my size of s2Set same with s1Set size. i always remove left \nthrough pop if value is 1 and decrease by 1 if it's larger than 1 (means it has duplicate in the body or the current addition) and add right into s2Set#\n\n\ns1Set = {}\r\ns2Set = {}\r\nleft = 0\r\nif (len(s1) > len(s2)):\r\n    return False\r\nfor ch in range(len(s1)):\r\n    s1Set[s1[ch]] = 1 + s1Set.get(s1[ch], 0)     \r\n    s2Set[s2[ch]] = 1 + s2Set.get(s2[ch], 0)\r\nfor right in range(len(s1)-1, len(s2)):\r\n    if right > len(s1)-1:\r\n        s2Set[s2[right]] = 1 + s2Set.get(s2[right], 0)\r\n        if s2Set.get(s2[left]) == 1:\r\n            s2Set.pop(s2[left])\r\n        else:\r\n            s2Set[s2[left]] -= 1\r\n        left+=1\r\n    if s1Set == s2Set:\r\n        return True\r\nreturn False"", 'Weird enough, my leetcode submission shows hashmap one faster than this one every time, by around 30ms', 'i think this solution is very confusing', 'Can someone see if my solution is any good: \n\nclass Solution:\r\n    def checkInclusion(self, s1: str, s2: str) -> bool:\r\n        length = len(s1) - 1\r\n        currmap = collections.Counter(s1)\r\n        l = 0\r\n\r\n\r\n        for r in range(len(s2)):\r\n            if s2[r] in currmap:\r\n                currmap[s2[r]] -= 1\r\n            if r > length:\r\n                if s2[l] in currmap:\r\n                    currmap[s2[l]] += 1\r\n                l += 1\r\n            if all(n == 0 for n in currmap.values()):\r\n                return True\r\n        \r\n        return False', 'Please correct me If I am wrong !\nBefore removing the character from the window , We have to check if your current matches equals 26 and return there , before proceeding to remove the character and updating the matches ?', ""yup yet another Neetcode's github solution destroyed by some random contributor."", ""The explanation is spot on but this is one of those very few times where the code is not neat:\n\nif len(s1) > len(s2): return False\n        \n        s1_count = [0] * 26\n        s2_count = [0] * 26\n        \n        for i in range(len(s1)):\n            s1_count[ord(s1[i]) - ord('a')] += 1\n            s2_count[ord(s2[i]) - ord('a')] += 1\n    \n        for j in range(len(s1), len(s2)):\n            if s1_count == s2_count: return True\n            \n            s2_count[ord(s2[j-len(s1)]) - ord('a')] -= 1\n            s2_count[ord(s2[j]) - ord('a')] += 1\n\n        return s1_count == s2_count\n\nThis makes the code much neater :)"", 'heres a troll solution for everyone\n\n   def checkInclusion(self, s1, s2):\r\n\r\n        windowLength = len(s1)\r\n        l = 0\r\n\r\n        for r in range(windowLength, len(s2) + 1):\r\n            if sorted(s1) == sorted(s2[l:r]):\r\n                return True\r\n            l+=1\r\n\r\n        return False', ""For those who were following along with left and right pointers and checking if the frame is valid. Here is the code. I found my implementation to be easier as it looks very similar to other sliding window problems.\npublic boolean checkInclusion(String s1, String s2) {\n        if(s1.length()>s2.length()) return false;\n        int[] freq1 = new int[26];\n        int[] freq2 = new int[26];\n\n        for(int i = 0; i<s1.length();i++){\n            freq1[s1.charAt(i) - 'a']++;\n        }\n\n        int l = 0;\n        int r = 0;\n\n        while(r<s2.length()){\n            freq2[s2.charAt(r) - 'a']++;\n\n            if((r-l+1)>s1.length()){\n                freq2[s2.charAt(l) - 'a']--;\n                l++;\n            }\n\n            if(Arrays.equals(freq1,freq2)){\n                return true;\n            }\n\n            r++;\n        }\n        return false;\n    }"", ""I didn't understand shit, watched the video 5 times now! The comment section makes me look like the only dumb living person. :(""]"
109,7pnhv842keE,"['NeetCode is essential for leetcode', ""My implementation of the 2nd solution ended up using slightly more memory(20mb) than my hashmap solution (19.9mb)\n\nIs that because the test cases didn't push the hashmap to its worst case O(n) or is that just leetcode being leetcode"", 'Would I not require an O(n) algorithm to assert that the majority element exists in the array?', ""Don't think I could have come up with the algorithm on the fly in an interview. Is there a list of esoteric algorithms that we should brush up on just in case? XD"", 'Beautiful explanation as always.', 'Amazing solution as always !!!', ""My mind is blown seeing this solution. I initially started with HashMap & didn't know about Boyer-Moore algorithm at all. Thanks NeetCode for putting up the explanations crystal clear!!! You have my respect."", 'great ! Thank you ! Dictionary solution was pretty obviuous', 'Ive just started leetcode and dealing with time complexities and such, I came up with this solution: \nfrom collections import Counter\r\nclass Solution:\r\n    def majorityElement(self, nums: List[int]) -> int:\r\n        nums_list = dict(Counter(nums))\r\n        for num in nums_list.items():\r\n            if num[1] > len(nums) / 2:\r\n                return num[0]\n\nI was just wondering would this also not be O(1) or would it be O(n) and if so why is the solution in the video o(1) not O(n)?', ""I couldn't optimize my original solution, and I wasn't sure how to improve it further. So, I searched for help on needcode. How do you manage to come up with such highly optimized solutions?\n\n\nclass Solution:\r\n    def majorityElement(self, nums: List[int]) -> int:\r\n        nums.sort()\r\n        \r\n        check = len(nums) // 2\r\n\r\n        for i in range(len(nums) - check):\r\n            if nums[i] == nums[i + check]:\r\n                return nums[i]\r\n\r\n                \r\n        return nums[0]""]"
110,hUe0cUKV-YY,"['Honestly, I just came to your video to see a bit more optimized solution, like using DP 😭!\nIf you have time pls explain that approach, \nThank you.', 'Added memoization to prevent repeated work. Trick here is to store the index and the _sorted_ sides array as the key. We sort as two different states such as [4, 2, 4, 3] at index i would ultimately do the same work as [2, 3, 4, 4] at that index given we iterate through all 4 values in the sides array. This significantly improves runtime if an interviewer potentially asks for further optimisation beyond sorting the matchsticks array in descending order:\n\n        def get_hashstring(i):\n            return f""{i}_{\'_\'.join([str(side) for side in sorted(sides)])}""\n\n        def backtrack(i):\n            if i == len(matchsticks):\n                return True\n\n            if get_hashstring(i) in memo:\n                return memo[get_hashstring(i)]\n            \n            for j in range(4):\n                if matchsticks[i] + sides[j] > target:\n                    continue\n                sides[j] += matchsticks[i]\n                if backtrack(i + 1):\n                    memo[get_hashstring(i)] = True\n                    return True\n                sides[j] -= matchsticks[i]\n                \n            memo[get_hashstring(i)] = False\n            return Fals', 'previously my java solution was getting passed through all test cases but now its showing time exceeding . please someone suggest me how to improve.\nclass Solution {\n    public boolean dfs(int i, int left, int top, int right, int bottom, int target, int[] sticks){\n        if(i == sticks.length && left == target && top == target && right == target && bottom == target){\n            return true;\n        }\n        if(i == sticks.length) return false;\n        boolean res = false;\n        for(int j = 0; j < 4; j++){\n            if(j == 0){\n                left = left + sticks[i];\n                res  = res || dfs(i+1, left, top, right, bottom, target, sticks);\n                left = left - sticks[i];\n            }\n            else if(j == 1){\n                top = top + sticks[i];\n                res = res || dfs(i+1, left, top, right, bottom, target, sticks);\n                top = top - sticks[i];\n\n            }\n            else if(j == 2){\n                right = right + sticks[i];\n                res = res || dfs(i+1, left, top, right, bottom, target, sticks);\n                right = right - sticks[i];\n\n            }\n            else{\n                bottom = bottom + sticks[i];\n                res = res || dfs(i+1, left, top, right, bottom, target, sticks);\n                bottom = bottom - sticks[i];\n            }\n\n            if(res) return res;\n        }\n\n        return res;\n    }\n    public boolean makesquare(int[] matchsticks) {\n        Arrays.sort(matchsticks);\n        int sum = Arrays.stream(matchsticks).sum();\n        if(sum % 4 != 0) return false;\n        int target = sum / 4;\n        return dfs(0,0,0,0,0,target,matchsticks);\n    }\n\n    \n\n}', ""This is totally a simplified leetcode 698-partition to K equal sum subsets.\nFor this problem, k == 4. Needcode implement that by the O(k^n) algorithm. But there still be another one which has been posted in 698's video. And the time complexity is O(k * 2^n).\nIn this algorithm, the main thing is for each side of the square, can we include the matchstick or not. Therefore, there are 2 decisions. Also, we cannot use each matchstick twice. So we have to create an array to memorize the state.\ndef makesquare(self, matchsticks: List[int]) -> bool:\r\n        # if sideSum cannot be integer, it won't be created to a square\r\n        if sum(matchsticks) % 4:\r\n            return False\r\n        # target is each side sum\r\n        target = sum(matchsticks) / 4\r\n        matchsticks.sort(reverse = True)\r\n        used = [False] * len(matchsticks)\r\n        def backtrack(i, k, sideSum):\r\n            # base case: if we finish each side, then it works.\r\n            if k == 4:\r\n                return True\r\n            # if one sideSum = target, then do the next side.\r\n            if sideSum == target:\r\n                return backtrack(0, k + 1, 0)\r\n            for j in range(i, len(matchsticks)):\r\n                '''\r\n                since we have sorted, so if the previous matchstick is skipped, then the next one also should be skipped. But we need to conform it is not out\r\n            of bound and not be used.\r\n                '''\r\n                \r\n                if j > 0 and not used[j - 1] and matchsticks[j] == matchsticks[j - 1]:\r\n                    continue\r\n                if used[j] or sideSum + matchsticks[j] > target:\r\n                    continue\r\n                used[j] = True\r\n                if backtrack(j + 1, k, sideSum + matchsticks[j]):\r\n                    return True\r\n                used[j] = False\r\n            return False\r\n        return backtrack(0, 0, 0)\n\nAnd it is pretty efficient of 72 ms implementing time.\nHope this would be helpful, if you never watched needcode's 698 solution."", 'if you are getting TLE ,\nadd if not sides[j]: break\nafter s[j]-=matchsticks[i]', 'informative vid!', ""Why don't we start solving this problem by trying to fill the four sides, side by side? \nIf any side failed to be fulfilled, then we are done. \n\nThis will reduce the time complexity to O(2^n+2): as we have to traverse the matchsticks array 4 times and in each iteration, we check if the current stick fits in the current subset or not.\nEdit:\nMy proposed solution is not correct. Assuming 1 set is correct and final and should only consider the other 3 sets is in correct, as 1 set could be filled correctly with more than one way."", 'Nice Explaination', ""For those of y'all getting TLE, I'll just paste what I wrote to another guy on how to fix it. TLDR, you need to memoize. \n\nHi met the same problem as it's today's daily. It's not enough to backtrack blindly. For me it TLE all the time with naive backtracking, even after optimizing by sorting first. \n\r\nSo to avoid TLE, you need to memoize the sides array, kind of like the state (memoizing the index i is useless because it does not prevent any recalculation so using python's caching decorator shortcut @cache wouldn't help). \n\r\nFinally of course, you have to transform the sides array into a tuple before memoizing because arrays are immutable and hence not hashable into a set or dict. \n\r\n```\n# add extra base case in the backtracking function\r\nif tuple(sides) in memo: \r\n    return memo[tuple(sides)]\n...\n\r\n# outside of the sides backtracking for loop\r\nmemo[tuple(sides)] = False  # we only need to memoize the False case because if it's ever True, we've finished the problem\r\nreturn memo[tuple(sides)]\r\n```"", 'this ans seems to be TLE now']"
111,dDokMfPpfu4,"['This is a great problem to show recursion in an easy way! Thank you!', 'GOAT', 'Perfect explaination, thank you!', 'This was the best explanation 👏🏽  thank you.', 'This is not efficient. Can be optimized by memoization. By storing the visited node in the object/hash/dict. Result as the key, node as the value', 'do a DS and algo series on YT!!!', 'neetcode has best explanation technique 🔥🔥🔥', 'Great content keep it up!', 'Thank you so much for starting this series for beginners like me! You rock!', 'NettCode is a WH1TE SUPREMACIST']"
112,in6QbUPMJ3I,"['Let me know if you prefer drawing & code at the same time or separately!', 'side by side is really good', 'There is just no way to figure out the true DP solution directly. This problem is hard.', 'i saw the solution but i coded it in c++... so its not full cheating :)', ""I know it's about coding, but I found a math solution that is easier to understand and to  code."", 'Not the most optimized solution. It can be solved in constant time.\nJust try to break n into 2 equal halves. The product of those numbers will be the max possible products.\nIf n is even, for example, n=6, max product = n/2*n/2 i.e. 3*3 = 9\nIf n is odd, for example, n=5, max product = int(n/2)*int(n-n/2) i.e. 2*3 = 6', 'but your code here only breaks an integer n into two pieces? val = dp[i] *dp[num-i]? what if the optimal break has more than 2 pieces', 'After doing a ton of CP with C++, it is pleasant to look at python code', 'Great explanation, although I preferred previous format - first explanation than code. I think the second loop could end earlier at num//2 + 1 because of symmetry.', ""Thank you for the solution !! It was very intuitive.\nI do have a question tho, if dp was an array rather than a dictionary it actually significantly slows down  the time complexity. However, we are only obtaining the element so shouldn't the time of retrieval both be O(1) for both array and dictionary? Why the choice of dictionary?""]"
113,JoF0Z7nVSrA,"['Code on Github: https://github.com/neetcode-gh/leetcode/blob/main/28-Implement-strStr.py\nI recommend using the timestamps and watching this at 1.5x Speed, at least the LPS portion, which turned out longer than I expected.', 'Clean and precise, thanks @NeetCode', 'best explanation on KMP on yt ❤', 'Awesome work, ! thank u for putting in so much effort and thanks to me also for making 1/5th effort to make it to the end of this video. good to see that u covered so many test cases, which made the explanation more clear.', '😘', 'this is the best video on youtube for this question', 'I have never been this confused in my life ever before.... F*** this algorithm...', 'I have a love-hate relationship with your channel.', 'The explanation of lps array is bit confusing in the above video, \nbetter explanation can be found here -> https://www.youtube.com/watch?v=ziteu2FpYsA', 'first time in neetcode history* bro made it wild']"
114,Gjkhm1gYIMw,"['Solving this with KMP Algorithm: https://youtu.be/JoF0Z7nVSrA', 'what about:\n        if needle not in haystack:\r\n                return -1\r\n        else:\r\n            return haystack.index(needle)', 'lass Solution:\r\n    def strStr(self, haystack: str, needle: str) -> int:\r\n        l,r = haystack.index((needle[0])), haystack.index((needle[0]))\r\n\r\n        while l<=r:\r\n            if haystack[l:r+1] == needle:\r\n                return l\r\n            else:\r\n                l+=1\r\n            r+=1\r\n        return -1\n\nIs this algorithm correct as well?', 'This came to my mind immediately🤣(and it works!):\n try:\n      return haystack.index(needle)\n except:\n      return -1', 'Solution does pass on leetcode as of 9/14/23', 'I think they fixed the time limit issue. I did a nested for loop and it beats 89% in time and 67% in memory with 34ms and 16.2mb.  Well, it definitely varies, but stays in the 33ms - 44ms range.\n```\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        for l in range(len(haystack) - len(needle) + 1):\n            if haystack[l] == needle[0]:\n                k = 1\n                r = l+1\n                while k < len(needle) and r < len(haystack) and haystack[r] == needle[k]:\n                    k += 1\n                    r += 1\n                if k == len(needle):\n                    return l\n        \n        return -1\n```', 'I passed this problem and beat 83.22% of users by just typing ""return haystack.find(needle)""\n.find() returns an index, or -1 if not found; exactly what the question asks for', 'why its i: i+ len(needle)? please explain', ""Can't this problem be done with a fixed sliding window implementation? Wouldn't that give a better run time than the nested for loop approach?"", 'why in the leetcode it says that for haystack as hello and the needle as ll , the output should be -1 and not 2 , my code returns 2 but leetcode expects the solution as -1 , why?']"
115,u_by_cTsNJA,"[""Why is this more optimal (according to Leetcode) than doing a regular level order traversal and updating the result with the first value in the queue every time? Here's my Java implementation: \n\n    public int findBottomLeftValue(TreeNode root) {\n        if (root.left == null && root.right == null) return root.val; \n\n        TreeNode res = root; \n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root); \n        while (!q.isEmpty()) {\n            int size = q.size();\n            res = q.peek(); \n            for (int i = 0; i < size; i++) {\n                TreeNode curr = q.poll();\n                if (curr.left != null) q.offer(curr.left);\n                if (curr.right != null) q.offer(curr.right); \n            }\n        }\n        return res.val; \n    }"", ""One quick question, In BFS solution like in the video, why dont we consider the base case of ' if not root'? Then we should return 0.\nif not root:\n    return 0\nThe description does not say the root is not None."", ""why solving such easy problems lol? just do basic BFS (level order traversal) and return first element of last list. it's not that hard, do some real problems! this is for little kids."", 'Hello neetcode could you please do questions to hard problems  on daily leetcode challenge.It would be very helpful for us if you do that', ""Hi yesterday, i had an interview with Amazon, may I pass you the question and solutions. My solution didn't pass all test cases."", 'This is essentially the same problem as computing right hand side view of binary tree. Except you are doing left hand side view and printing the last element on that path.', ""I solved it with the first approach you mentioned i.e doing the LOT L->R and keeping track of the levels. It got accepted with 97 % TC and 67 %  SC. Isn't it strange that the second approach seems to be more efficient  but still leetcode tags it as not so efficient.(as compared to other Python solutions). BTW as usual really good video sir! I am learning a lot from your videos."", 'Could we also solve with DFS', 'I tried to get the depth of my tree and then traverse it again and decrementing the depth at each node until the depth == 0 and if there is a value i return it once i return to the parent i return the left if left is not None else r, you may be asking why not just use the statement return l or r , it is because the l could be zero so the or operator will trait it as False.\n\ndef findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        depth = self.depth(root)\r\n        return self.findBottomLeftValHelper(root, depth - 1)\r\n    \r\n    def findBottomLeftValHelper(self, root, depth):\r\n        if not root: \r\n            return\r\n        \r\n        if depth == 0:\r\n            return root.val\r\n        \r\n        l = self.findBottomLeftValHelper(root.left, depth - 1)\r\n        r = self.findBottomLeftValHelper(root.right, depth - 1)\r\n        return l if l is not None else r\r\n    \r\n    def depth(self, root):\r\n        if not root:\r\n            return 0\r\n        return 1 + max(self.depth(root.left), self.depth(root.right))', 'BFS ?...also we can keep track of the levels ...the max level can be used to find the value right ?']"
116,G8xtZy0fDKg,"[""Folks is there anyone like me who first sees the question, thinks a lot about it and have absolutely no idea how to even approach the problem, and then later checks neetcode just see the solution? \nI'm afraid that I can't even think of solutions to basic problems"", 'Another similar approach:\nCreate two pointers L and R\nCheck both the maps:\nIf you find any freq lesser than the other map-> Increment R\nIf you find any freq greater than the other map-> Increment L\nIf all are eqaul -> Updater answer and increment both L and R', '10:44 why did we pop s[l] ?', 'wow', 'def findAnagrams(self, s: str, p: str) -> List[int]:\n        if len(s) < len(p):\n            return []\n        c=Counter(p)\n        res=[]\n        for i in range(len(s)-len(p)+1):\n            temp=Counter(s[i:i+len(p)])\n\n            if temp==c:\n                res.append(i)\n        return res', 'This solution avoids using sCount == pCount to check whether it is an anagram or not since it can be costly if there are a lot of unique keys to be checked. Instead it uses diffCount to keep track the number of characters which have different count. Hopefully it helps :3\n\nclass Solution:\r\n    def findAnagrams(self, s: str, p: str) -> List[int]:\r\n        from collections import Counter\r\n        results = []\r\n\r\n        # Parse the strings using counter\r\n        pCounter, sCounter = Counter(p), Counter(s[:len(p)])\r\n\r\n        # Count number of differences\r\n        diffCount = 0\r\n        pKeys, sKeys = list(pCounter.keys()), list(sCounter.keys())\r\n        uniqueKeys = list(set(pKeys + sKeys))\r\n        for key in uniqueKeys:\r\n            if sCounter[key] != pCounter[key]:\r\n                diffCount += 1\r\n        \r\n        # Check is it an anagram\r\n        if diffCount == 0:\r\n            results.append(0)\r\n\r\n        # Iterate\r\n        for i in range(1,len(s)-len(p)+1):\r\n            oldChar, newChar = s[i-1], s[i+len(p)-1]\r\n\r\n            if oldChar == newChar:\r\n                if diffCount == 0:\r\n                    results.append(i)\r\n                continue\r\n\r\n            sCounter[oldChar] -= 1\r\n            sCounter[newChar] += 1\r\n\r\n            if sCounter[oldChar] == pCounter[oldChar]:\r\n                diffCount -= 1\r\n            elif sCounter[oldChar] + 1 == pCounter[oldChar]:\r\n                diffCount += 1\r\n\r\n            if sCounter[newChar] == pCounter[newChar]:\r\n                diffCount -= 1\r\n            elif sCounter[newChar] - 1 == pCounter[newChar]:\r\n                diffCount += 1\r\n\r\n            if diffCount == 0:\r\n                results.append(i)\r\n\r\n        return results', 'There can be also one more optimisation we can do if we found a char which is not present in p then we can simply move the left pointer to the position of that char in s +1 and apply the same algo from there...please let me know if it can be considered as a optimisation or not', 'How is this any different from this : https://www.youtube.com/watch?v=UbyhOgBN834', 'Thanks Man , good one :)', 'Thank You']"
117,ZGxqqjljpUI,"[""Was stuck on the final edge case for a good while. Adding the 0's makes so much sense!"", 'why is range excluding last element as len(f) -1 when last element is not inclusive already please  ? thanks.', 'here is my overcompilcated code \nclass Solution {\n    public boolean canPlaceFlowers(int[] flowerbed, int n) {\n        int count = 0;\n        for(int i =0;i<flowerbed.length;i++)\n        {\n            System.out.println(i);\n            if(flowerbed[i]==1)\n            {\n                i=i+1;\n                continue;\n            }\n            else{\n            if(i<flowerbed.length-1 && i>=1)\n            {\n            if (flowerbed[i+1] != 1 && flowerbed[i-1] !=1 )\n                {\n                    count ++;\n                    i++;\n                }\n            }\n            else if( flowerbed.length!=1 && i==0 )\n            {\n                if( flowerbed[i] ==0  && flowerbed[i+1]!=1  )\n                {\n                    i++;\n                    count ++;\n                }\n            }\n            else if( flowerbed.length!=1 && i == flowerbed.length - 1)\n            {\n                if (flowerbed[i] == 0 && flowerbed[i-1]!=1 )\n                {\n                    count++;\n                }\n            }\n            if(flowerbed.length==1 && flowerbed[0] == 0)\n            {\n                return true;\n            }\n\n            }\n        }\n        System.out.println(count);\n        return count>=n;\n    }\n}', 'will this work for  0,[0,0],0? \nfor n =1 only it should return true\ni think your code will return true even for n=2', 'This is soooo ammmmazing content', 'Just handle the edge in the if block instead of random math.\n\n        if n == 0:\r\n            return True\r\n        for i in range(len(flowerbed)):\r\n            if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and (i == len(flowerbed)- 1 or flowerbed[i+1] == 0):\r\n                flowerbed[i] = 1\r\n                n -= 1\r\n                if n == 0:\r\n                    return True\r\n        return False', 'This problem had some crazy annoying edge cases. \n\nIf you want to avoid O(n) space, just modify the original array (or keep a prev/next vals)\n\nOtherwise, I used O(n) space with a temp array just like you. Makes the problem much easier', 'nice solution NC', 'Hmm.. I was trying to use decimal values for 3 digits binary.. Got fed up solving that way.  Thanks for explaining.', ""Leetcode's editorial solution is imo simpler and more intuitive.""]"
118,iJGr1OtmH0c,"['🚀 https://neetcode.io/ - A free resource to prepare for Coding Interviews', ""Hey @NeetCode,\nFirst you said it's similar to LC200 Number of Islands and there you used BFS, not DFS. I wonder why is that and what did you mean by similar in this case? I used slightly modified version of LC200 BFS in this problem and it worked fine, also ran quicker than 150ms and it seems to be more straight forward solution for me to be honest (this is a matter of opinion though). Cheers!"", 'Quick Question: How does this solution differentiate to count Spaces that have ""1"" vs ""0"" . In the Number of island problems you had this check? @NeetCode', 'How do we solve this if we are also allowed to change the order of the columns?', ""Instead of using hashmap for visited  land we can just change the value of visited land from '1' to '2'\nSo that way code will use less space and also by doing this you won't have to check if the land is visited or not"", 'Thank you. I could solve the problem by myself less than 15min using the same approach.', 'Done thanks\nTrivial, same as number of islands problem but keep track of largest island', 'I have solved this question using the same code as your  no. of islands video  (using bsf), It works ! \n\nclass Solution:\r\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\r\n        if not grid:\r\n            return 0 \r\n\r\n        rows = len(grid)\r\n        cols = len(grid[0])\r\n        maxArea = 0 \r\n        visited = set()\r\n\r\n        # bfs function \r\n        def bfs(r, c):\r\n\r\n            nonlocal maxArea\r\n\r\n            area = 1 \r\n            queue = collections.deque()\r\n\r\n            visited.add((r,c))\r\n            queue.append((r,c))\r\n\r\n\r\n            while queue:\r\n                for _ in range(len(queue)):\r\n                    row, col = queue.popleft()\r\n\r\n                    directions = [[1,0], [-1,0], [0, -1], [0 , 1]]\r\n\r\n                    for dr, dc in directions:\r\n                        if ((dr + row) in range(rows) and \r\n                            (dc + col) in range(cols) and\r\n                            grid[dr + row][dc + col] == 1 and \r\n                            (dr + row, dc + col) not in visited):\r\n                            visited.add((dr + row, dc + col))\r\n                            queue.append((dr + row, dc + col)) \r\n                            area += 1 \r\n            maxArea = max(maxArea , area)\r\n \r\n        #for each and every position , call bfs\r\n        for i in range(rows):\r\n            for j in range(cols):\r\n                if (i,j) not in visited and grid[i][j] == 1:\r\n                    bfs(i , j)\r\n        return maxArea', ""Thanks for the video, but i don't get why this one is in the Graph category on your website🥴"", 'I think you missed `+` between the all dfs calls. \nreturn 1 + dfs(r+1, c) + dfs(r-1, c) + dfs(r, c+1) + dfs(r, c-1)']"
119,mBk4I0X46oI,"['Correction: The time complexity of the 2nd solution is actually O(2^ (k*n)), because if we have K trees stacked on top of each other, the new height of the tree is K * n.', 'Use a visited set in DFS, hum...', 'def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\n        """"""\n            dfs(subsetsum, k)\n        \n            dfs(0,4)\n            /\n        dfs(4,4)\n        /\n    dfs(0,3)\n\n        - we need visisted array to avoid to take used num\n        -\n\n        O(subsetsum*k*n)\n        """"""\n        n = len(nums)\n        total_sum = sum(nums)\n        target_sum = total_sum // k\n        # edge case\n        if total_sum % k != 0:\n            return False\n\n        self.memo = {}\n        def dfs(subset_sum, k):\n            """"""\n            use s\n            """"""\n            if k == 0:\n                return True\n            if subset_sum == target_sum:\n                return dfs(0, k-1)\n\n            key = tuple(used)\n            # key = (subset_sum, k)\n            if key in self.memo:\n                return self.memo[key]\n\n            for i in range(n):\n                if used[i]:\n                    continue\n                if subset_sum + nums[i] > target_sum:\n                    break\n                used[i] = True\n                if dfs(subset_sum+nums[i], k):\n                    key = tuple(used)\n                    # key = (subset_sum, k)\n                    self.memo[key] = True\n                    return True\n                used[i]= False\n\n            key = tuple(used)\n            # key = (subset_sum, k)\n            self.memo[key] = False\n\n        used = [False for _ in range(n)]\n        nums.sort(reverse=True)\n        return dfs(0, k)\n\nIt works for all the test cases/TLE shit. \n\nDoes anyone can explain why we used used array as key of cache instead of (subset_sum, k)', 'In neetCode Pro can we get the bitmask solution ?', 'You should never tell time complexity before explaining the solution.', 'My only issue with this solution is that what if k == 0 and not all the numbers have been used? Why is this not a possibility?', 'Finally found someone who could explain me this problem.', ""if you're getting TLE its means you're calling duplicates backtrack we need to skip duplicate backtrack \n\nsort the array \nadd if(visited[i] || i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) continue;  inside for loop  or you can use dp with bitmask because max length is 16"", ""java solution \n\n\n```java\nclass Solution {\r\n    public boolean canPartitionKSubsets(int[] nums, int k) {\r\n    int n= nums.length;\r\n    int target = 0;\r\n\r\n     for(int i = 0 ; i < n ; i++)\r\n     { \r\n         target += nums[i];\r\n     }\r\n       \r\n       // if sum of the array cannot be divided into k buckets then return false.\r\n      if(target%k != 0) return false;\r\n      else  target = target/k ;\r\n\r\n//Array to keep track of what elements we have used\r\n      boolean[] arr = new boolean[n];\r\n      Arrays.fill(arr , false);  \r\n \r\n        return solve(arr , nums , 0 , 0 , target , k);\r\n    }\r\n\r\n //k = number of subsets to be made\r\n //target is the desired sum of each subset (sum for each bucket)\r\n    public boolean solve(boolean[] arr , int[] nums , int subsetSum , int i , int target ,int k)\r\n    { \r\n        //base condition 1: No more subsets to be made\r\n       if(k == 0) \r\n       return true;\r\n      \r\n      // base condition 2: 1 subset made then do k-1 and set subSet sum back to zero.\r\n       if(subsetSum == target)\r\n       {\r\n          return solve(arr ,nums , 0 , 0 , target , k -1);\r\n       }\r\n\r\n      for(int j = i ; j < nums.length ; j++)\r\n      { \r\n          if(arr[j] == true || (subsetSum + nums[j]) > target)\r\n          continue;\r\n\r\n          arr[j] = true; //mark the value we have used\r\n          //recursive call\r\n          if (solve(arr ,nums , subsetSum + nums[j] , j+1 ,target, k))\r\n          return true;\r\n\r\n\r\n          //backtracking\r\n          //unmarking the value we have just used\r\n          arr[j] = false;\r\n\r\n      }\r\n\r\n        // our loop through every possible decision and doesn't find decision so return false\r\n      return false;\r\n    }\r\n}\r\n\r\n\r\n// NeetCode -- https://www.youtube.com/watch?v=mBk4I0X46oI\n```"", ""can bit masking be applied their, as i saw in some solution but didn't get  it""]"
120,jwt5mTjEXGc,"['What the hell, tree problems knock me out!', 'My thought process was exactly same as yours, but while coding I was not able to write the algo , but I can say after following your videos I have learned a lot and improving everyday.', 'This solution is genius. I am wondering if you came up with it from the first time? My initial solution was a lot longer in terms of lines of code. Thanks NeetCode', 'I art search has no duplicates of elements', 'Your explanations are spectacular and easy to understand', 'Spent an hour trying to solve this just to end up coming here to watch you kill me with 10 lines of code', 'A good day kicked off by the awesome solution and your explanation. Thank you so much!', 'best video', 'Here\'s how I solved it. I did it similar to how you did ""Flatten Binary Tree"". It\'s similar because this way we solve each subtree in post order DFS and then decide which nodes to return based on the conditions (build it from ground up). The solution in this video is a little too elegant and hard to understand\n\nvar trimBST = function(root, low, high) {\n  if (root == null) {\n    return null\n  }\n    \n  let left = trimBST(root.left, low, high)\n  let right = trimBST(root.right, low, high)\n\n  root.left = left\n  root.right = right\n  \n  if (root.val < low || root.val > high) {\n    // remove current node\n    if (left == null && right == null) {\n      return null\n    }\n    \n    if (left == null) {\n      return right\n    }\n    \n    if (right == null) {\n      return left\n    }\n  }\n  \n  return root\n};', 'Why have you returned the root node?']"
121,p10f-VpO4nE,"['Java solution: class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode current = head;\n\n        if(head == null) return head;\n        while(current.next !=null){\n            if(current.val == current.next.val){\n                current.next = current.next.next;\n            }else{\n                current = current.next;\n            }\n        }\n\n        return head;\n    }\n}', 'idk why am i getting a time limit exceeded msg when my solution is literally the same as few solutions in the solutions section, anyone?', 'thanks', 'Your videos literally show that programming is not just about coding. \nThank you.', 'i love you', ""I have a question... In the code , we didnt change the 'head', why it will be changed and be the final answer at the end?   Anyone?"", 'Can you clear why while loop didn’t change anything on head. But head had changed???', 'In worst case, if the Sorted List has no duplicates, could we assume the big O is O(n^2) instead of O(n)? Because head node will be through all nodes which is O(n) at least. The big O should definitely higher than O(n)? However, we know it would not be more than O(n^2) for sure. Please let me know if my understanding is on the right track.', 'Nested while loops work just fine but I prefer just one:\n\n        current = head\r\n        \r\n        while current.next:\r\n            if current.val == current.next.val:\r\n                current.next = current.next.next\r\n            else:\r\n                current = current.next\r\n        return head', 'With all due respect, imo, this code is a bit simpler to read:\n        if (head is null) return null;\r\n        \r\n        ListNode back = head;\r\n        ListNode front = head.next;\r\n        \r\n        while (front is not null)\r\n        {\r\n            if (front.val != back.val)  back = back.next;\r\n            \r\n            front = front.next;\r\n            back.next = front;\r\n        }\r\n        \r\n        return head;']"
122,B7m8UmZE-vw,"['Thanks and could you please explain leetcode 769?', 'Thankyou again for your explanation. These videos are really helpful and they are helping people like us study!!', 'You are a life saver, keep being Neet!', 'Thank you so much for the explanation', 'Great', 'NNEEEEEEETTTTT', 'Man you’re so good, I don’t even have to get to the end of the video to grasp the algorithm. Well done', ""Could just use a regular int[] rather than a hashmap to keep track of your end position... endPos[c-'a'] = i"", 'thank you very much for your explanation', 'Amazing explanation!!']"
123,3OamzN90kPg,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'inefficient, but sort() -> unique(), compare size', 'print(not (len(nums) == len(set(nums))))', 'Do we not need to declare the user input here?', ""I understand that hash sets don't allow duplicates but for this problem why is it necessary to use it (not that it is better not to, just for my own understanding).If you had created an empty list and used the same method would it not have worked the same?"", 'Hi good men!\n\n👍Thanks a lot for your videos about algorithms.\n\nCould you tell me please what programs on 💻 you use to make video like this one ?', '@neetcode I have a question: will it be at 2:56 Complexity O(N*logN + N) because N*logN for sorting and then +N for comparison?', ""wait, checking the number in the hashset again takes O(n) time, doesn't it ? so, whats the improvement from brute force?"", 'can expline why you use  set and not dict ?', 'I had the efficient solution from the start . feels good.']"
124,hOjcdrqMoQ8,"['🎯 Key Takeaways for quick navigation:\n\n00:00 🎯 Introduction to Problem\n- Introduction to the problem of finding the kth largest element in a stream of numbers.\n- Explanation of the problem requirements, including the definition of ""kth largest element in sorted order.""\n02:13 🤔 Problem Solving Approach\n- Discussion of the naive approach: sorting the input array, binary search, and its limitations.\n- Introduction of the optimal approach: using a min heap of size k to efficiently find the kth largest element in the stream.\n- Explanation of the advantages of using a min heap and the reasoning behind its implementation for this problem.\n08:20 💻 Implementation in Python\n- Detailed walkthrough of the Python implementation of the problem solution.\n- Explanation of the constructor function, initializing the min heap, and ensuring its size is k.\n- Description of the add function, including how new elements are added to the min heap and maintaining its size.\n- Demonstrated the efficient time complexity of the implemented solution and the significance of using a min heap for this problem.\n\nMade with HARPA AI', 'But how. In the min heap 2 should be in the very beggining if we use 4, 5, 8,  2 values', '4:26 Cannot understand\n\nIf we are using mi heap, it means that in the beggining of the array we will have smaller values, how can we choose the largest ones among them?', 'heapq object comes in clutch', 'Well they have changed this question from easy to medium.', 'Thanks.', 'how does self.minHeap[0] return the k largest element? The root of the min-heap should return the smallest element', ""can't we have count logic and we can do in O(n)?"", 'The problem is disliked because the way it is written is far from ""Clear Explanation"". Sometimes authors of Leetcode problems take very heavy drugs', 'How is pop not a O(1) operation?']"
125,g0npyaQtAQM,"['GOOD VIDEO', 'no tabulation for this problem?', 'why is the time complexity O(m*n) and not O(m + n) since if there are two factors influencing the time complexity of a method we take the one with the highest complexity?', ""A way to massively reduce the memory complexity (at a small price of 10 milliseconds more runtime) is for some reason using all the problem's parameters (plus the cache hashmap) as inputs to our helper function's parameters:\n\nclass Solution:\r\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\r\n        cache = {}\r\n\r\n        return self.dp(nums, 0, 0, target, cache)\r\n\r\n    def dp(self, nums, index, sum, target, cache):\r\n        if (index, sum) in cache:\r\n            return cache[(index, sum)]\r\n\r\n        if (index == len(nums)):\r\n            if (sum == target):\r\n                return 1\r\n            else:\r\n                return 0\r\n        \r\n        cache[(index, sum)] = self.dp(nums, index + 1, sum + nums[index], target, cache) + self.dp(nums, index + 1, sum - nums[index], target, cache)\r\n\r\n        return cache[(index, sum)]\n\nSolution in video: 264 ms, 37.6 mb\nThis solution: 274 ms, 17.4 mb"", 'Is it possible to do this using a bottom up approach like you do with alot of other DP problems?', ""I understand these videos but when it is time to solve on my own, I won't get the intuition at all.\nAnybody else in the same boat as me?"", 'f(x, curr_sum) = {\r\n    1,                                      if x == len(nums) and curr_sum == target,\r\n    0,                                      if x == len(nums) and curr_sum != target,\r\n    f(x + 1, curr_sum + nums[x]) + f(x + 1, curr_sum - nums[x]),     otherwise\r\n}', 'What is line number 11 and 12 doing?', ""Hey does someone know if we can implement a tabulation solution to this problem? If not, how do we determine if a problem can or can't have tabulated solution??"", 'Backtracking works since nums size <= 20; DP would be better for this kind of problem. Start with  2D then can be optimized to 1D.']"
126,gVUrDV4tZfY,"['ok fine, I will compromise and start doing my videos in C 😉', 'Love your dislike to the question', 'Thank you really! Your course is the best of all😃', 'I ignored the ""dislike"" when you said so. But when I actually started doing this question i really disliked it.', ""did yo u just  use java coz you don't want to explain mask?"", 'why shift the output of a & b by 1 ?', 'How the hell this is marked as a medium? It’s easier than most of the “easy” ones that I’ve seen', 'Helpful, thank you!', 'It does not work for -1 and 1', ""Any chance of explaining the python version you've uploaded to you site?""]"
127,9UtInBqnCgA,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'I am a dumb in data structure 😂.\nBut recently my professor taught BST and i gone several sorting videos ( bubble , selection ,insertion sort).\nI m planning to do reverse way( from problem to concept building), shall i process to do?', 'does anyone know why in java the hashmap solution is considerably slower than the sorting one?\n4ms vs 14ms', ""print (''.join(sorted(list(s)))  ==  ''.join(sorted(list(t))) )"", ""Doesn't the (2nd)sorting method result in a worse time complexity of O(nlogn)?"", 'I am a bit confused on how dictionaries work in Python. I have read some articles that say a Python dictionary is both an ordered and unordered collection. Does this characteristic matter in this type of question?', 'For the solution you provided, why would the time complexity be O(s + t)? How are we iterating through both of the strings in the following code?\n\nI see us iterating though all of the characters in string ""s"" and then iterating again through countS which is a hash map storing all of the unique keys in string ""s"". Someone please explain where I am going wrong in my understanding.\n\ndef isAnagram(s: str, t: str) -> bool:\n  if len(s) != len(t):\n    return False\n\n  countS, countT = {}, {}\n\n  for index in range(len(s)):\n    countS[s[index]] = 1 + countS.get(s[index], 0)\n    countT[t[index]] = 1 + countT.get(t[index], 0)\n\n  for character in countS:\n    if countS[character] != countT.get(character, 0):\n      return False\n  return True', 'I really appreciate the work you do! I really do! Thank you so much, these videos are very helpful.', 'Can you use C++ or Java or C#?', ""🤕🤕🤕In the code you provided, the letters from the words s and t are not stored in the same order in the respective smap and tmap maps. The order in which letters are added to the maps is not preserved because std::unordered_map containers in C++ do not guarantee the preservation of a specific order of elements based on keys. Or I don't; understand the concept of hash map.... :(""]"
128,Pr6T-3yB9RM,"[""You don't even need to sort the array, you can just use the initial car positions as as the index to an array that maps to how long it takes each car to arrive at the destination. making it O(n). This problem would definitely fit better on the arrays and hashing section."", ""Doesn't accessing the second from the top (stack[-2]) go against the whole idea of the stack data structure? Calling this a stack solution seems forced."", 'Very difficult concept but easy and short for codes, amazing.', ""You can do list(zip(position, speed)) to convert the zip iterator to a list, which is a bit shorter. Although you don't really need it because you can call sorted() directly on the zip iterator."", 'This medium problem feels like hard one.', 'this is a great way to look at this problem.', 'It is a increasing stack.', 'So there is no actual linear time solution to this problem? I initially implemented pretty much like this, not looking at the data in detail and just assuming that the cars would be already in the order of which they appear on the road because why would anyone collect the data in a random order. Then when my solution failed due to lack of sorting, I realized the issue but assumed there must be a more superior solution to sorting it first. Why else would they just randomly offer the cars out of order and then you have to then just sort it yourself.', 'Awesome, great explanation! However, I think this can be done without using the stack as well.', 'Damn, this marks the first time I failed to understand your solution even after multiple watches, so I had to look elsewhere. Turns out this problem is just a pain to implement in C++.']"
129,5Km3utixwZs,"['this would actually be another cool way to increment count since it uses bit operators end to end for the solution count += n&1', 'definitely difficult to come up with the optimal solution by yourself', ""I had my intuition clear but for some reason this won't work in java."", 'the second method can just use n&1 to get the ending bit is 1 or 0\n\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        count = 0\n        while n:\n            count += (n & 1)\n            n = n >> 1\n        return count', 'please make some video in indian accent', '1st method:  (easy peasy)\ndigit = 0\r\n        while n:\r\n            if n % 2 == 1:\r\n                digit += 1\r\n            n = n // 2\r\n        return digit', 'Cool. What a creative solution 😀', '*does the exact same thing just with &, time limit exceeded', 'your first decision doesn’t work in kotlin with max int value: 11111111111111111111111111111101', 'This is so smart. I re-watched this video and it still helps me a lot. Thank you!']"
130,7yF-U1hLEqQ,"['⭐ BLIND-75 PLAYLIST: https://www.youtube.com/watch?v=KLlXCFG5TnA&list=PLot-Xpze53ldVwtstag2TL4HQhAnC8ATf', 'such an easy solution, i was reading this problem and just had no idea what isomorhpic was or how to even remotely solve it. thanks bro', 'in 3:29 you could just use this example : \ns\xa0=\n""badc""\nt\xa0=\n""baba""', 'Hey, you missed one Condition i.e. ""No two characters may map to the same character"" for BAR you mapped (a-> o and r->o).', 'More optimized solution:\n\nclass Solution:\r\n    def isIsomorphic(self, s: str, t: str) -> bool:\r\n        \r\n        map = {}\r\n\r\n        for i in range(len(s)):\r\n            if s[i] not in map:\r\n\r\n                if t[i] not in map.values():\r\n                    map[s[i]] = t[i]\r\n                    \r\n                else:\r\n                    return False\r\n\r\n\r\n            else:\r\n                if t[i] != map[s[i]]:\r\n                    return False\r\n\r\n        return True', 'Thanks!', 'you can do it without reverse map. if you do check both strings:  isIsomorphic(s,t) && isIsomorphic(t,s) - makes impl simpler!', 'here is my solution \ndef isomerphic(a,b):\r\n    map1=[]\r\n    map2=[]\r\n    for idx in a:\r\n        map1.append(a.index(idx))\r\n    for idx in b:\r\n        map2.append(b.index(idx))\r\n    print(map1)\r\n    print(map2)\r\n    if map1==map2:\r\n        return True\r\n    return False\r\na=(""bar"")\r\nb=(""foo"")\r\nprint(isomerphic(a,b))', 'you are a life saver!', 'Using this code it seems to return true for ""babc""/""baba"". If I\'m reading this right, it doesn\'t seem to do a check on the last character.']"
131,nONCGxWoUfM,"['You keep saying ""remove the one that ends first"" when you mean ""keep the one that ends first""', 'I think the logic should always remove the one end last, so it should have less chance of overlapping with the next interval.', 'If anyone needs a simpler and more straightforward code, see if this helps:\n\ndef eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        intervals = sorted(intervals, key = lambda x : x[0])\n        res = 0\n        for i in range(1, len(intervals)):\n            if intervals[i][0] < intervals[i-1][1]:\n                res += 1\n                intervals[i][1] = min(intervals[i-1][1], intervals[i][1])\n\n        return res', 'how about this simple code\n def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n    ans = 0\n    currentEnd = -math.inf\n\n    for interval in sorted(intervals, key=lambda x: x[1]):\n      if interval[0] >= currentEnd:\n        currentEnd = interval[1]\n      else:\n        ans += 1\n\n    return ans', 'Hey Neet, I noticed you keep saying ""remove the one that ends first"" when you are not pointing to the one that ends first. I believe you meant ""keep the one that ends first""?', ""This is such an amazing explanation. I can't thank you enough for all that you've done for us students."", 'Thankss', 'your explanation are always great. Just one thing I noticed you said at 7:30, ""removing the one that ends first"", I think you meant keeping the one that ends first', 'Great explanation', 'ohh  i was thinking about removing part but we just need to update the last value which is smaller between previous and current interval']"
132,I7j0F7AHpb8,"['Damn it I almost got this one, I missed  i+2 for sell. I still think it is i+1.', 'I managed to solve this problem with just a 1-D DP memo. However, it seems to run much slower than your solution. Could someone explain the differences and why this is?\n\nCode:\n\nclass Solution:\r\n    def maxProfit(self, prices: List[int]) -> int:\r\n        \r\n        memo = [None for _ in range(len(prices))]\r\n        \r\n        def dp(i):  # func assumes we are ready to buy!\r\n            if i >= len(prices):\r\n                return 0\r\n            if memo[i] is not None:\r\n                return memo[i]\r\n            \r\n            maxProfit = dp(i + 1)  # represents not buying\r\n            for j in range(i + 1, len(prices)):  # j is a location we can sell at\r\n                maxProfit = max(\r\n                    maxProfit,\r\n                    prices[j] - prices[i] + dp(j + 2)  # j + 2 is a location we can think abt buying again\r\n                )\r\n\r\n            memo[i] = maxProfit\r\n            return maxProfit\r\n        \r\n        return dp(0)', ""14:55 for line 21, shouldn't cooldown be equals to dfs(i + 1, not buying) instead of dfs(i + 1, buying)? \nSince you have chosen to not sell and to have a cooldown instead, then as the index increments you CANNOT buy until you sell. dfs(i + 1, buying) would mean that you can choose to not sell, and then buy more stock before selling, which isn't allowed per the description rules."", 'very good video', ""good website and good explanation, but not-ideal naming, took me forever to figure out; should've just asked GPT to write a dfs memo version for me.\nalso I would think learning only-recursion solution is dangerous for anyone who want a good understanding. think for more."", 'Why is it included in 2d dp problems in neetcode?', ""my js solution:\n\nvar maxProfit = function (prices) {\r\n  const states = ['B', 'S', 'C'];\r\n\r\n  const memo = new Map();\r\n\r\n  function backtrack(step, index) {\r\n    if (index === prices.length) return 0;\r\n    const currState = states[step % 3];\r\n    const k = `${index}-${currState}`;\r\n    if (memo.has(k)) return memo.get(k);\r\n    let res = 0;\r\n\r\n    for (let i = index; i < prices.length; i++) {\r\n      let price = prices[i];\r\n      if (currState === 'B') {\r\n        price *= -1;\r\n      }\r\n      if (currState === 'C') {\r\n        price = 0;\r\n      }\r\n\r\n      const btr = backtrack(step + 1, i + 1) + price;\r\n      memo.set(k, Math.max(memo.get(k) || 0, btr))\r\n\r\n      res = Math.max(res, btr);\r\n    }\r\n    return res;\r\n  }\r\n \r\n\r\n  return backtrack(0, 0);\r\n};"", 'I really wish you went over the state machine DP solution. Would have loved to see your explanation of it.', ""I don't get why the cooldown for selling is not `cooldown = dfs(i+2,buying)'"", ""Damn, that's a nice way of thinking about it. I was trying to and able to solve it, but my solution wasn't as efficient and was only better than 10% of the solutions (O(n^2) complexity). Looked at this video and realized my way of caching/memoizing was the issue. Thinking about it in terms of just two decisions is so clever!""]"
133,jJXJ16kPFWg,"[""Can someone explain to me in more detail why at 13:10 why you need another set of L < R inside the already existing L < R while loop so that it doesn't go out of bound"", 'In this solution won\'t ""a!@#$"" return true and ""ab!@#$"" return false due to the nature of the inc/dec while loops? 🤔', 'Thanks u', 'Could someone elaborate on why he includes ""l < r"" and ""r > l"" in the internal while loops? My assumption is that the outermost while loop already accounts for that piece of logic (while l < r:...)', ""It's so damn satisfying having done a solution and seeing that Neetcode uses the absolute same method."", 'Hey Neet theres a slight error with the alphanum while statement for the right pointer in the python code on your site, just change it up later ig !', 'def isPalindrome(self, s: str) -> bool:\n        s = [c.lower() for c in s if c.isalnum()]\n        return s[:] == s[::-1]', 'Can anyone explain why do we have to put ""while l < r"" again inside of the first while loop? the loop bound is already assigned in the first while loop..', 'what is the reason for writing a custom alpha numeric function? how do you what you are writing is more optimized than boiler plate isalnum() function?', 'If s= ""AB{[BA""\nCode works but still it won\'t shift the r to 2nd position']"
134,fu2cD_6E8Hw,"['I am getting time limit exceeded with this solution or it is just me? thanks', ""My dumbass didn't read the fineprint and just went with SortedDict from sortedcontainers 😭"", '""I don\'t want to make it too easy""', 'this is the answer that chatgpt gave me, and its shorter and 95% faster than every other answer... \n\nimport bisect\r\nfrom collections import defaultdict\r\n\r\nclass TimeMap:\r\n    def __init__(self):\r\n        self.data = defaultdict(list)\r\n\r\n    def set(self, key, value, timestamp):\r\n        self.data[key].append((timestamp, value))\r\n\r\n    def get(self, key, timestamp):\r\n        values = self.data[key]\r\n        index = bisect.bisect_right(values, (timestamp, chr(127)))\r\n        if index:\r\n            return values[index - 1][1]\r\n        return """"\n\nedit: I understand why he didnt do it this way now, he said ""he didnt want to abuse java"" and wanted it to be more similar to other languages', 'The goat fr', 'understood', 'I think there is no need to use binary search because according to the condition, the timestamps are strictly set in increasing order, so the right most index has the max timestamp which you can compare it with the current timestamp, so you could condense the get function like:\n    def get(self, key, timestamp):\r\n        res = "" ""\r\n        values = self.store.get(key, [])\r\n\r\n        if values[-1][1] <= timestamp:\r\n            res =  values[-1][0]\r\n\r\n        return res', ""I don't wanna abuse Python too much to make everything so easy. lol"", 'of course for lists that are much much bigger in size the binary search option is still better with a time complexity of O(log n), but i feel like there\'s a much simpler approach that is O(n) at worst. since the timestamps are always in increasing order, we can iterate through the timestamps backwards and return the value whose timestamp is less than or equal to the input timestamp, otherwise return an empty string.\n\nclass TimeMap:\r\n    def __init__(self):\r\n        self.pairs = {}\r\n\r\n    def set(self, key: str, value: str, timestamp: int) -> None:\r\n        if key in self.pairs:\r\n            self.pairs[key].append((value, timestamp))\r\n        else:\r\n            self.pairs[key] = [(value, timestamp)]\r\n\r\n    def get(self, key: str, timestamp: int) -> str:\r\n        if key not in self.pairs:\r\n            return """"\r\n        else:\r\n            for values in reversed(self.pairs[key]):\r\n                if values[1] <= timestamp:\r\n                    return values[0]\r\n            return """"', ""I was racking my brain with this, didn't read or realize that timestamp was in increasing order, I even implement a sort method in the set so that the array was sorted and the get could be done in log n time, but it wasn't enough some test failed because the time keep running out, then I saw that part of the video expecting some fancy algorithm and was like ._. oh? it's already sorted.""]"
135,E36O5SWp-LE,"[""Great video / solution as always. I took a slightly different approach with same time complexity that felt a bit more intuitive to me than recursing with isSubtree. I used a breadth first search on S and for each node I processed in S, I checked if the value of that node was equal to the root of T. If yes, I ran sameTree (which I implemented recursively similar to the solution provided). If sameTree returned True at any point, I ceased my BFS and returned True.\n\nAlso note: the problem definition specifies that S and T will each have >= 1 node. So you don't need to actually check the edge cases that you check regarding S or T being completely null.\n\nHere's my code:\n\nclass Solution {\npublic:\n    bool isSubtree(TreeNode* root, TreeNode* subRoot) {\n\n        deque<TreeNode*> nodes { root };\n        bool subTree { false };\n\n        while (!nodes.empty())\n        {\n            TreeNode* currNode { nodes.front() };\n            nodes.pop_front();\n\n            if (currNode->left != nullptr)\n            {\n                nodes.push_back(currNode->left);\n            }\n\n            if (currNode->right != nullptr)\n            {\n                nodes.push_back(currNode->right);\n            }\n\n            if (currNode->val == subRoot->val)\n            {\n\n                subTree = sameTree(currNode, subRoot);\n\n            }\n\n            if (subTree)\n            {\n                return subTree;\n            }\n        }\n\n        return subTree;\n        \n    }\n\n    bool sameTree(TreeNode* a, TreeNode* b)\n    {\n        if (a == nullptr && b == nullptr)\n        {\n            return true;\n        }\n\n        if (a == nullptr || b == nullptr || a->val != b->val)\n        {\n            return false;\n        }\n\n        return sameTree(a->left, b->left) &&\n        sameTree(a->right, b->right);\n    }\n};"", 'They may have updated this, but t has to be at least size 1, so no need for if not t: return True', 'Not sure if O(S*T) would be the most efficient solution, \nSince if all nodes have the same numbers, the algorithm would effectively call sameTree() for all S nodes.\n\nI solved it by using postorder (In-order would also do fine) on both S and T and compare the list of these post order by using two pointers. It is much longer solution than the suggested one by Neetcode but the overall time and space complexity is O(max(S, T)). Neetcode also has the same space complexity due to recursion stack.', ""since the t is always going to be checked on its root, isn't it unnecessary to have a case for t == null in isSubtree function?"", 'What is Space complexity? I think its O(no. of root nodes * no. of subRoot nodes).', ""Nice solution but I swear theres something with the python community that loves making code as short and unreadable as possible which is a horrible habit.  \nIf you're going to abbreviate tree and subtree why not at least give Tree the t and Subtree the s...seems logical. \nReplacing tree with s and subtree with t is just a truly strange thing to do  \nHaving your code a few more characters long if it severely improves readability is actually a good thing\nanyways nice solution."", 'Curious, why is this N*M time complexity? in the SameTree video, the time complexity is N+M. Can someone elaborate? My educated guess is that calling another recursive func inside of our recursive func would make this exponential.', 'thank you', 'great explanation!! but im just a little confused on why we return true if t == null, would t ever be null ?', 'i just got a job making $1million/month, all thanks to NeetCode']"
136,uhgdXOlGYqE,"['correct solution\n\n\nclass Solution:\r\n    def stoneGame(self, piles: List[int]) -> bool:\r\n        dp={}\r\n\r\n        def dfs(l,r):\r\n\r\n            if l>r:\r\n                return 0\r\n            if (l,r) in dp:\r\n                return dp[(l,r)]\r\n            alice_turn=True if (r-l+1)%2==0 else False\r\n            left=piles[l] \r\n            right=piles[r]   \r\n            if alice_turn:\r\n                  dp[(l,r)]=max(dfs(l+1,r)+left,dfs(l,r-1)+right)\r\n            else:       \r\n                  dp[(l,r)]=min(dfs(l+1,r)-left,dfs(l,r-1)-right)\r\n            return dp[(l,r)]\r\n        return  dfs(0,len(piles)-1)>0', 'INCORRECT SOLUTION!!! \nYou can try with this array [5, 2, 100, 6]\nYou defined dfs(l, r) as what alice will get at the end of the game. It should be 105. But running through your code, we will get 106 instead.\nI think your solution is just greedily looking for max returns.', ""I don't get it why we are narrowing the choices between first + third, second + fourth piles. It says Alice will always pick third one if she picks first pile initially.\nPile 1, 2, 3 , 4. Alice can pick first pile. Say Bob picks fourth pile. Alice can pick second pile at the next turn. So it is first+second for Alice."", 'Apparently, there are some solutions that are faster than just returning True.', ""I couldn't do the Stone Game ii in daily challenge. So I came to review the Stone Game. And This is literally the best intuitive explanation that was ever possible. I look up to you man!"", 'Alice is to pick first so she can decide to pick all the odds or all the even.  Pick left for odd and pick right for even.  The rest can just follow Bob, if Bob pick left she pick left, if Bob pick right she pick right.  So she only need to calculate if sum(odd) > sum(even).', ""This question is flawed so result verification cannot identify bugs.\nHowever, I think the solution presented is also flawed, because Bob does not make any choice at all. \nThis is because *left* and *right* are going to be 0 for Bob and the *max()* expression is just going to channel Alice's next choice. If Bob did not make a choice, then you can't tell what Alice would be left with to pick from.\nAlso, *even* is incorrectly calculated, should be *l - r + 1*\nA better approach is to have dfs() return a tuple of (player1, player2) sum, but then alternate every dfs call to a different player making the choice. In this way, you do give Bob a choice to pick a pile."", 'for once, i think your solution is not exactly correct. \nYou can try with this array [5, 2, 100, 6]\nYou defined dfs(l, r) as what alice will get at the end of the game. By inspection, it should be 105. But running through your code, we will get 106 instead.\nI think your solution is just greedily looking for max returns, but happen to be ok for leetcode as they are only asking for true/false. (its always true)\n\nPlease double check !!\n\nI think the right solution should be considering Alice and Bob turn to be min-max problem.', 'I like the fact that over 2% of solutions is still faster than your ""return True"" 😁', 'We can create a 2D array, which is L * R size.\nWhen l = r, means there is only one pile to choose. So dp[L][R] should be same as the piles\nWhen L > R, non sense\nWhen L < R, we compute:\n\n        dp = [[0] * len(piles) for _ in range(len(piles))]\r\n        for i, pile in enumerate(piles):\r\n            dp[i][i] = pile\r\n        for l in range(len(piles) - 2, -1, -1):\r\n            for r in range(l + 1, len(piles)):\r\n                even = True if (r - l) % 2 else False\r\n                left = piles[l] if even else 0\r\n                right = piles[r] if even else 0\r\n                dp[l][r] = max(dp[l + 1][r] + left, dp[l][r - 1] + right)\r\n        return dp[0][len(piles) - 1] > (sum(piles) / 2)\n\nAnd the 1D array, is similar with 2D solution. Since we know the new DP is only related with dp[l + 1][r] and dp[l][r - 1]. We do not need to create a new nextDP array, you will see in the code.\nThen we get below:\n\n        dp = piles.copy()\r\n        for l in range(len(piles) - 2, -1, -1):\r\n            for r in range(l + 1, len(piles)):\r\n                even = True if (r - l) % 2 else False\r\n                left = piles[l] if even else 0\r\n                right = piles[r] if even else 0\r\n                dp[r] = max(dp[r] + left, dp[r - 1] + right)\r\n        return dp[len(piles) - 1] > (sum(piles) / 2)\n\nActually, the graph is like a reversed triangle. And they are much more efficient.']"
137,61tN4YEdiTM,"['Actually because you are doing string slicing at each step. The time complexity is 3 ^ 4 * N where N is the length of string', 'bro why are you always saying 4 dots when it is crystal clear that we need 3 dots to bifurcate string to 4 part', 'The integer validation checking condition should be     int(s[i:j+1]) <=255', 'Another way: O(n^4) by iterating the possible locations of the 3 dots.', 'I’m sure there’s some way I’m doing it wrong but, even when I try to recreate your solution perfectly, it for some reason doesn’t seem to work. I’ve gone through it several times and, at this point, I’m not sure what to do', 'Inner loop should be replaced by if conditions', 'Java Code:\n:: LC All Passed ::\n\nclass Solution {\r\n    public List<String> restoreIpAddresses(String s) {\r\n        ArrayList<String> ans = new ArrayList<>();\r\n        if(s.length() > 12) return ans;\r\n        helper(s,0,0,"""",ans);\r\n        return ans;\r\n    }\r\n    private void helper(String s, int i, int dots, String res, ArrayList<String> ans){\r\n        if(dots == 4 && i == s.length()){ // Base\r\n            ans.add(res.substring(0,res.length()-1));\r\n            return;\r\n        }\r\n        if(dots > 4){\r\n            return;\r\n        }\r\n        \r\n        for(int j = i; j < Math.min(i+3,s.length());j++){\r\n            int currnum = Integer.parseInt(s.substring(i,j+1));\r\n            if(currnum <= 255 && (i == j || s.charAt(i) != \'0\')){\r\n                helper(s,j+1,dots+1,res + s.substring(i,j+1) + ""."",ans);\r\n            }\r\n        }\r\n    }\r\n}', 'Anybody has java code for this??? I am getting some error, when I write code like his. Must be some java error.', 'Isnt it 3^3? you are placing 3 dots, and each dot position can have 3 choices', 'How do you decide when to build a decision tree with 2 choices vs. a decision tree with more than 2 choices? I ended up going the 2 choices route (put a dot at a position vs not putting a dot at a position which is a technique you have used in other backtracking problems) which has a time complexity of O(2^n)? That 2 choice solution runs slower than your O(3^n / 3^4) solution. I drew out both the decision trees for input ""101023"" and the O(2^n) solution has 41 total recursive calls while your O(3^n / 3^4) solution only has 30 total recursive calls. I  thought O(2^n) was always faster than O(3^n / 3^4) but that doesn\'t seem to be the case. What am I not understanding here? \n\nThank you so much for your videos btw. <3 Hope to see you at Google one day :)']"
138,ktmzAZWkEZ0,"['💡 DYNAMIC PROGRAMMING PLAYLIST: https://www.youtube.com/watch?v=73r3KWiEvyk&list=PLot-Xpze53lcvx_tjrr_m2lgD2NsRHlNO&index=1', 'nice one', 'Beautiful', 'This IS NOT an EASY problem for everyone!! should be marked as MEDIUM', 'TABULATION (Bottom Up)\n---------------------------------------------------------------------------------------------------------------------\ndef minCostClimbingStairs(self, cost: List[int]) -> int:\r\n        cost.append(0)\r\n\r\n        for i in range (len(cost)-3, -1, -1):\r\n            cost[i] = min((cost[i]+cost[i+1]), cost[i]+cost[i+2])\r\n\r\n        print(cost)\r\n        return min(cost[0], cost[1])', 'your brute force solution misses the fact that we can start at either position 0 or position 1, we can run two seperate stack traces from each poisiton and get the min, or we can start jumping from position -1. the cost there is 0, and it can either jump to position 0 or position 1. \nmy bruteforce code:\ndef minCostClimbingStairs(self, cost: List[int]) -> int:\n        minC = 10000000000000\n\n        def jump(n, c, minC):\n            if n >= len(cost):\n                minC = min(minC, c)\n                return minC\n            if n > -1:\n                c += cost[n]\n            return min(jump(n + 1, c, minC), jump(n + 2, c, minC))\n        \n        return jump(-1, 0, minC)', 'for i in range(2,len(cost)):\r\n        cost[i]+=min(cost[i-1],cost[i-2])\r\nreturn min(cost[-1],cost[-2])', 'It\'s weird that the problem is called ""climbing stairs"".\nI mean, what stairs have one step being 100 times more expensive to climb that the previous one?\nWhy didn\'t they call the problem ""saving fuel on an airplane"" or something.', 'Simply the Best!', 'Quite misleading explanation']"
139,86yKkaNi3sU,"['you cud have just used this\n[6]*(n//6)+[ n%6]', ""At 3:56 how could we roll a 3 and a 7? (I mean it's a 6 sided dice right) I think it's a mistake some people might get confuse by it. Actually I god confuse by it. Thanks for the video though."", 'Distributing as evenly as possible among the n dices leads to an O(1) solution.', 'Hey there. Can u plz make a video about <Maximize the Confusion of an Exam> problem from the save contest.', 'Hey NeetCode, were you able to finish in top 10% from Leetcode Weekly contest? Are you currently faang  engineer? Thanks for the quality instructions!', 'We need Max no. of ways to partition an array pls.', 'Hi neetcode, could you please cover the stone game series of problems?', 'Very nice ..Already solved the question but still waited for your video  to learn something new and my time get paid off thank you😍😊', 'wish me luck to get a job at fang. I hope everyones gets a job in fang', 'May be forgot to edit the video 😂🙂😂🙂. Finally got the secret behind it.']"
140,RF_M9tX4Eag,"['💡 LINKED LIST PLAYLIST: https://www.youtube.com/watch?v=G0_I-ZF0S38&list=PLot-Xpze53leU0Ec0VkBhnf4npMRFiNcB&index=2', 'Dude, I have nothing but admiration for how you approach various problems. Every time you do it clear, simple and smooth.', 'I like this style of explaining where you go back and forth between the drawing and the code. It helps me mentally map the concept directly to implementation', 'Breaking it into 3 parts helped a lot. Thank you', 'FIRST FIND AND UNDERSTAND HOW TO REVERSE A LINKEDLIST IN-PLACE, AFTER IT WILL BECOME WAY MORE EASIERR PROMISEE', 'best solution😌', 'Thank you so much sir', 'Those who can reverse a Linked List, they can easily solve this.', 'Best video explanation for it... thnx for the effort 😇', 'This problem is more obnoxious than it is challenging']"
141,TC_xLIWl7qY,"['⭐ EASY PLAYLIST: https://www.youtube.com/watch?v=KLlXCFG5TnA&list=PLot-Xpze53lfQmTEztbgdp8ALEoydvnRQ', 'Neetcode is the best!', ""Hey all, I have a question:\nWhy are things called a 'hash _' when they don't have a hashing function?\nI noticed Neetcode calls what i'd call a 'map' a 'hashmap' and in this example, what I'd call just a 'set' a 'hashset'.\n\nAFAIK, for it to be a 'hashset' the input would have to be converted to a hash before being stored in a set data structure.\n\nIf anyone can let me know I'd appreciate it!"", 'Brilliant', 'easy but the problem description has many gotchas', 'i wrote like 50 lines of and you wrote just 10 lol', 'res=set()\r\n        for em in ems:\r\n            el=""""\r\n            f=0\r\n            for i,c in enumerate(em):                               \r\n                if c==\'.\':\r\n                  continue\r\n                elif c==\'+\':\r\n                  f=1\r\n                  continue\r\n                elif c == \'@\':\r\n                  break\r\n                elif f!=1:\r\n                  el+=c                                                 \r\n            \r\n            res.add(el+em[i:])\r\n                \r\n        return len(res)', 'The way you clear the question is really brilliant.', 'Brilliant', 'hi can you do question 92 (reverse linked list2)? Thanks']"
142,N4wDSOw65hI,"['i think 1st robot is mean', 'No need to store preRow1, preRow2 lists.\nYou can instead calculate the values directly inside the loop. For row 0, just keep adding the values, for row 1, sum the row first then keep decrementing values from it.', ""you can do it in O(n) time and O(1) memory like this. No need for the prefix sums and extra for loop.\n\ntop = 0\nbottom = sum(grid[1])-grid[1][-1]\nres = float('inf')\nfor i in range(len(grid[0])):\n            res = min(max(top,bottom),res)\n            bottom -= grid[1][len(grid[0])-i-2]\n            top += grid[0][len(grid[0])-i-1]\nreturn res"", 'The corner case(for second robot) is what , even I forgot to in to account', 'Java Solution:\n\nclass Solution {\r\n    public long gridGame(int[][] grid) {\r\n      int c=grid[0].length;\r\n      long [] prefixsum_r1 = new long[c];long [] prefixsum_r2 = new long[c];\r\n      prefixsum_r1[0]=grid[0][0];prefixsum_r2[0]=grid[1][0];\r\n      for(int i=1;i<c;i++){\r\n          prefixsum_r1[i] = prefixsum_r1[i-1]+grid[0][i];\r\n          prefixsum_r2[i] = prefixsum_r2[i-1]+grid[1][i];\r\n      }\r\n      long bottom=0,res=Long.MAX_VALUE;\r\n      for(int i=0;i<c;i++){\r\n          long top = prefixsum_r1[c-1]-prefixsum_r1[i];\r\n          bottom = prefixsum_r2[i]-grid[1][i];//- grid[1][i] to remove that index and cal befores\r\n          long robot2 = Math.max(top,bottom);\r\n          res = Math.min(res,robot2); \r\n      }\r\n      return res;\r\n    \r\n    }\r\n    \r\n\r\n}', 'woah ... amazing.', 'Solution in Java\n public long gridGame(int[][] grid) {\r\n        int [] t=Arrays.copyOf(grid[0],grid[0].length);\r\n        int [] b=Arrays.copyOf(grid[1],grid[1].length);\r\n        long [] top=Arrays.stream(t)\r\n                        .mapToLong((i) -> (long) i)\r\n                        .toArray();\r\n        long [] bottom=Arrays.stream(b)\r\n                        .mapToLong((i) -> (long) i)\r\n                        .toArray();\r\n        long upSum=0l;\r\n        long downSum=0l;\r\n        long result=Long.MAX_VALUE;\r\n        for(int i=1;i<grid[0].length;i++)\r\n        {\r\n            top[i]+=top[i-1];\r\n            bottom[i]+=bottom[i-1];\r\n        }\r\n        \r\n        for(int j=0;j<grid[0].length;j++)\r\n        {\r\n            upSum=top[top.length-1]-top[j];\r\n            if(j!=0)\r\n            {\r\n               downSum=bottom[j-1]; \r\n            }\r\n            result=Math.min(result,Math.max(upSum,downSum));\r\n            \r\n        }\r\n        return result;\r\n    }', 'Request: Solve Squid Game. 🦑', 'absolutely superb explanation ,good job keep doing🎈🎈🎈', 'Since you used copies of the grid for the prefix lists, you can simply code your last for loop as:             result = min(result, max(prefix1[-1] - prefix1[i], prefix2[i] - grid[1][i])) this takes care when the index i = 0']"
143,d4SPuvkaeoo,"['💡 BACKTRACKING PLAYLIST: https://www.youtube.com/watch?v=pfiQ_PS1g8E&list=PLot-Xpze53lf5C3HSjCnyFghlW0G1HHXo', 'can we use dp in this', 'My Java Solution: Main trick is to not add in original Hashset in helper function.\n\nclass Solution {\r\n    public int maxLength(List<String> arr) {\r\n        HashSet<Character> set= new HashSet<>();\r\n        return backtrack(arr,0,set);\r\n    }\r\n    public int backtrack(List<String> arr,int i, HashSet<Character> set){\r\n        if(i==arr.size()) return set.size();\r\n        int res=0;\r\n            if(!overlap(arr.get(i),set)){\r\n            for(int k=0;k<arr.get(i).length();k++){\r\n                set.add(arr.get(i).charAt(k));\r\n                }    \r\n            res = backtrack(arr,i+1,set) ; \r\n            for(int k=0;k<arr.get(i).length();k++){\r\n                set.remove(arr.get(i).charAt(k));\r\n                }\r\n            }\r\n        return Math.max(res,backtrack(arr,i+1,set) );\r\n    }\r\n    public boolean overlap(String str, HashSet<Character> set){\r\n             HashSet<Character> prev = new HashSet<>();\r\n            for(int k=0;k<str.length();k++){\r\n                char c = str.charAt(k); \r\n                if(set.contains(c)||prev.contains(c)){return true;}\r\n                prev.add(c);\r\n            }\r\n            return false;//not in set already\r\n    }\r\n}', 'Wow... You made this problem so simple... Below is the java implementation of the same\n\nclass Solution {\n        public int maxLength(List<String> arr) {\n        if(arr.size()==1){\n            if(checkValidity(new HashSet<>(),arr.get(0)))\n                return arr.get(0).length();\n            else return 0;\n        }\n\n        return maxLength(arr,0,new HashSet<>());\n    }\n\n    public int maxLength(List<String> arr, int index, Set<Character> set) {\n        if(index==arr.size())\n            return set.size();\n\n        int incIdx = 0;\n        if(checkValidity(set,arr.get(index))) {\n            incIdx = maxLength(arr, index + 1, set);\n            String s = arr.get(index);\n            for (int i = 0; i < s.length(); i++)\n                set.remove(s.charAt(i));\n        }\n        return Math.max(incIdx,maxLength(arr,index+1,set));\n    }\n\n    private boolean checkValidity(Set<Character> set, String s) {\n        for(int i=0;i<s.length();i++){\n            if(set.contains(s.charAt(i))){\n                for(int j=0;j<i;j++)\n                    set.remove(s.charAt(j));\n                return false;\n            }else{\n                set.add(s.charAt(i));\n            }\n        }\n        return true;\n    }\n}', '@NeetCode  What is the time complexity for this solution', 'thanks your decision tree is so powerful, I using that concept to my c++ code and let me easy to understand how backtracking run thanks for your help!', 'Thank you so much for this video, but I\'m having a hard time understanding ""Counter"" here in line 6. says ""name Counter is not defined"" in my case', 'U a God. Python simpler implementation with DFS/backtracking:\n\nclass Solution(object):\n    def maxLength(self, arr):\n        """"""\n        :type arr: List[str]\n        :rtype: int\n        """"""\n        self.ans = 0\n    \n        def hasDuplicates(s):\n            return len(s) > len(set(s))\n        \n        \n        def backtrack(idx, s):\n            self.ans = max(self.ans, len(s))\n            \n            if idx >= len(arr):\n                return\n            \n            for i in range(idx, len(arr)):\n                if not hasDuplicates(s + arr[i]):\n                    backtrack(i + 1, s + arr[i])\n                    \n        if not arr:\n            return 0\n        backtrack(0, """")\n        return self.ans', 'Wow this is hard', 'Very nice use of backtracking! I actually concatenated the strings in my solution, but I think using the set like you did would be faster. Also I like the use of counter; I don’t use that one enough 😅 I always feel clever when I use a data structure from the standard library that’s not a built-in']"
144,ohBNdSJyLh8,"['This is more math than programming', 'I have a different solución, but tours is good to me too.', 'how to handle 400 , the output is ""CCCC"" but expected is ""CD"". I think To handle the case of 400, we need to add an additional condition to check if the num is equal to the current val. If that condition is true, we can directly append the symbol and subtract the value from num. This will ensure the code correctly handles cases requiring subtractive notation.', 'sexjhvhj', 'Hermosa solución. Simple y efectiva.', 'You explained it like a peice of a cake', 'Your explanations are excellent! After watching many of your videos, one suggestions I would make is better variable naming for clarity. Your variable names tend too be too concise and generic/unclear. In this video for example, ""sym, val"" would be clearer as ""roman, decimal"". I see you also use ""res"" a lot in many of your videos. Sometimes, I have to re-read the code a few times to keep track of what the variables mean. Other than that, awesome, and thank you so much for helping us!', 'Why nest these solutions inside a class? Why not just make the scope the py script?', 'Thank you a lot, from France !', 'The only thing I can say is: Thank you, thank you, thank you!!!']"
145,nZtrZPTTCAo,"['⭐ MEDIUM Playlist: https://www.youtube.com/watch?v=jzZsG8n2R9A&list=PLot-Xpze53lfOdF3KwpMSFEyfE77zIwiP', 'apple', ""One simple observation that will help is if n=even we can't create FBT so we can add a check in first condition if n%2==0 rather than n==0"", '@NeetCode: I guess at 8:20 what you mean to say is to iterate from 1 to n-1. Because the left should have at least 1 left node. Thank you for the solution. Its very easy to follow.', 'Amazing Introduction, thk you a lot', ""But how does this guarantee that we can have a FBT？ If we let left go from 0 - n-1, does this mean that a blank left subtree(not a BST) is accepted? First we know that a even number will return None as some friends. In this case I think the range of left should be range(1, n, 2) because we don't want either of the subtree to be empty and we don't want the even ones."", 'Awesome explaination !!!', ""3:56 'Don't try to be smart just try to figure out how to solve it at all'\nMe on every single leetcode problem:"", ""Why don't we get any duplicates here?"", 'why not use lru chache']"
146,bahebearrDc,"['⭐ MEDIUM Playlist: https://www.youtube.com/watch?v=jzZsG8n2R9A&list=PLot-Xpze53lfOdF3KwpMSFEyfE77zIwiP', 'Great video and your voice in this video is much more calm, which is great! easier to listen and follow.', 'we did not need list, we can go through dictionary and multiply what you are trying to by value\ncode:\nclass DetectSquares:\n\n    def __init__(self):\n        self.points = defaultdict(int)\n\n    def add(self, point: List[int]) -> None:\n        self.points[(point[0], point[1])] += 1\n\n    def count(self, point: List[int]) -> int:\n        result, px, py = 0, point[0], point[1]\n\n        for indices, val in self.points.items():\n            x, y = indices\n            if [x,y] != point and (abs(px-x) == abs(py-y)):\n                result += val * self.points.get((x, py), 0) * self.points.get((px, y), 0)\n        \n        return result', 'Bhai, kahase ho tum?\nMast channel he, awesome.', 'What about ""Positive area"", I don\'t think this solution covers this requirement', 'nice solution!', 'Time complexity O(1): using hash map of hash map.', 'I go this problem in an interview. I failed. Wish I watched your video before 😢', ""To avoid the extra list:\n\nclass DetectSquares:\r\n\r\n    def __init__(self):\r\n        self.pts = defaultdict(int)\r\n\r\n    def add(self, point: List[int]) -> None:\r\n        self.pts[tuple(point)] += 1\r\n\r\n    def count(self, point: List[int]) -> int:\r\n        res = 0\r\n        px, py = point\r\n        print('New')\r\n        for x, y in self.pts:\r\n            if (abs(px - x) != abs(py - y)) or x == px or y == py:\r\n                continue\r\n            if (px, y) in self.pts and (x, py) in self.pts:\n                # Multiply with the number of occurrences of the repeated point represented by self.pts[(x, y)]\n                res += self.pts[(px, y)] * self.pts[(x, py)] * self.pts[(x, y)]\r\n        return res"", 'Thanks!']"
147,rKnD7rLT0lI,"['🌲 TREE PLAYLIST: https://www.youtube.com/watch?v=OnSn2XEQ4MY&list=PLot-Xpze53ldg4pN6PfzoJY7KsKcxF1jg&index=2', ""This question is one of those that after watching the video 3 times, I'm still confused"", 'Problem before seeing Neetcode: Wth is this?!\nProblem after seeing Neetcode: Oh. Such a simple problem!', 'This was tough for me to solve on my own. It makes so much sense now thank you!', '""Return rightTail or leftTail or root"" is too hard to understand. It\'s not simply like the question wants us to return the tail.', 'Timestamp 13:05 - 13:06: Discord notification alert. :)', 'could oyu explain it again', 'Why we have to return the list tail?', 'no need for a helper function, can just write the same logic inside flatten :)', 'discord msg']"
148,Pcd1ii9P9ZI,"['❤', 'Thanks!', 'NeetCode you are the best I so much trust and believe you\nThanks for sharing all of this for free', ""# Take an easy solution for this problem\n\nclass Solution:\r\n    def removeElement(self, nums: List[int], val: int) -> int:\r\n        i = 0\r\n        l = len(nums)\r\n        while i < l:\r\n            if nums[i] == val:\r\n                # Just pop the element if it's equal to val\r\n                nums.pop(i)\r\n                l -= 1\r\n            else:\r\n                i += 1\r\n        return len(nums)"", 'Thank God, finally found someone who explains the concept so clearly', 'Thanks!', ""you're a legend, man"", 'The little disadvantage I see on this that is giving it such low score is exactly what was mentioned, that this is gonna perform the swap every time regardless of if its needed or not', 'thx！', ""i wrote it exactly like yours but my mistake was that i was returning ''nums'' and kept giving me errors""]"
149,aoHbYlO8vDg,"['Super cool algorithm', ""Very helpful video! so why was s[i] the same as s[N-i-1], that's the only thing I still cant wrap my head around"", ""It's actual hard-level instead medium-level for this problem"", 'Really Neat', ""this explanation was so good. I've never done bit masking before and understood everything clearly. Thanks!"", ""This is genius, I managed to do the backtrack way but couldn't figure out why it was in the bitmask category until seeing this"", 'jaw dropping solution', 'Hi neetcode, below code sometime gives tle, sometime not. please help\n\nclass Solution {\r\n    public int maxProduct(String s) {\r\n        var mask = (1 << s.length());\r\n        var hashMap = new HashMap<Integer, Integer>();\r\n        for (int num = 1; num < mask; num+=1) {\r\n            var l = isPalindrome(s, num);\r\n            if (l!=-1){\r\n                hashMap.put(num, l);\r\n            }\r\n        }\r\n        var maxProduct = 1;\r\n        var entrySet = hashMap.entrySet();\r\n        for (var e1: entrySet) {\r\n            for (var e2: entrySet) {\r\n                if ((e1.getKey() & e2.getKey()) == 0) {\r\n                    // they are disjoint\r\n                    maxProduct = Math.max(maxProduct, e1.getValue() * e2.getValue());\r\n                }\r\n            }\r\n        }\r\n        return maxProduct;\r\n    }\r\n    \r\n    int isPalindrome(String s, int mask) {\r\n        int leftIndex = s.length()-1;\r\n        int rightIndex = 0;\r\n        int length = 0;\r\n        while (rightIndex < leftIndex) {\r\n            if (((1 << rightIndex) & mask) == 0) {\r\n                rightIndex+=1;\r\n            } else if (((1 << leftIndex) & mask) == 0) {\r\n                leftIndex-=1;\r\n            } else if (s.charAt(leftIndex) == s.charAt(rightIndex)){\r\n                length+=2;\r\n                leftIndex -=1;\r\n                rightIndex +=1;\r\n            } else {\r\n                return -1;\r\n            }\r\n        }\r\n        if (leftIndex == rightIndex && (((1 << leftIndex) & mask) != 0)) {\r\n            length+=1;\r\n        }\r\n        return length;\r\n    }\r\n    \r\n}', 'This aint medium💀', ""What's the space complexity of this solution please?""]"
150,lEQ8ZlLOuyQ,"['get an array of ratios from rectangles-array then increment the output by the frequency whenever an instance of a ratio re-occurs', 'without using maths:\nclass Solution:\n    def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:\n        inter = defaultdict(int)\n        result = 0\n        for w, h in rectangles:\n            ratio = w/h\n            result += inter.get(ratio, 0)\n            inter[ratio] += 1\n\n        return result', 'How did you come up with this solution? is it your knowledge of Math?', ""I know I'm hella late, but I did something with less math:\n\nclass Solution:\r\n    def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:\r\n        ratios = {};\r\n        res = 0;\r\n        for pair in rectangles:\r\n            r = pair[0] / pair[1];\r\n            occurrences = ratios.get(r,0);\r\n            res += occurrences;\r\n            ratios[r] = 1 + occurrences;\r\n        return res;\n\nbasically, as we iterate through each rectangle, we check how many rectangles before it had the same ratio."", 'Is double rounding error a concern?', 'Could anyone explain to me why this code would return 0:\nI tried including prints to figure out the problem and the last time I call backtract c is indeed 6 for the first example. But it keeps returning 0.\nI\'ll edit if I figure out the problem. \n\n        d = {}\r\n        count = 0\r\n        for i, r in enumerate(rectangles):\r\n            d[i] = float(r[0])/float(r[1])\r\n        print(d)\r\n        \r\n        def backtrack(index, c):\r\n            if index == len(rectangles)-1:\r\n                return\r\n            for i in range(index+1,len(rectangles)):\r\n                if d[index] == d[i]:\r\n                    print(""index: "", index, ""c: "", c)\r\n                    c+=1\r\n            print(""before recall C: "", c)\r\n            backtrack(index+1, c)\r\n            \r\n        backtrack(0, count)\r\n        return count', ""Hi Neetcode! I noticed lots some problems by company tag you have done on the channel are no longer popular for that company (or no longer popular at all for the past few month). I can send you a list per company since I have lc premium. In this way, your videos will reach more audience and you won't waste your efforts."", 'I Saw the video in youtube home page and i went to leetcode to try before even start atching the video, this was my solution:\nseen = dict()\r\n        res = 0\r\n        for rect in rectangles:\r\n            width = rect[0]\r\n            height = rect[1]\r\n            ratio = width / height\r\n            print(ratio)\r\n            seen[ratio] = 1 + seen.get(ratio, 0)\r\n            \r\n        for num in seen.values():\r\n            if num != 1:\r\n                res += (num*(num - 1))//2\r\n        \r\n        return res', 'i am getting error with test case : [[4,5],[7,8]] could somebody explain i exactly did as you instructed', 'I wish the titles mention the level of the question (easy, med) so i can filter them more easily']"
151,KT9rltZTybQ,"['✅ EASY PLAYLIST: https://www.youtube.com/watch?v=KLlXCFG5TnA&list=PLot-Xpze53lfQmTEztbgdp8ALEoydvnRQ', '1 liner solution:\n\n\n\n\n\nclass Solution:\n    def lengthOfLastWord(self, s: str) -> int: return len(s.split()[-1])', 'class Solution:\r\n    def lengthOfLastWord(self, s: str) -> int:\r\n        x=""1"" \r\n        y=[]\r\n        for i in reversed (s):\r\n            if i>x:\r\n                y.append(i)\r\n            if len(y)>0:\r\n                 if i<x:\r\n                   break\r\n        return len(y)\r\n               \r\n            \r\n        \r\n\r\n         i have used the ascii values. Which is an point to catch in this case.', 'easy \n\nclass Solution:\n    def lengthOfLastWord(self, s: str) -> int:\n        temp = """"\n        # using strip method we are actually remove whitespace from lefft and right side\n        string = s.strip()\n\n        for i in string:\n            if i.isspace():\n                temp = """"\n            else:\n                temp = temp + i\n        \n        \n\n        return len(temp)', 'I answered this question by myself with no help and it was pretty awesome. I finally did a problem without help. I used a for loop and started from the end of the string to the beginning. The conditions were, if my counter variable is zero and next character is a space, continue, else if, increment counter variable by one and else is break. Hope that makes some senses but it worked!', ""My  solution:\nAt first we go trough every spaces from the end of the array. Once we reach not space element, this is a word start. After we add elements when non-space character is present. If we have more then one word_symbols saved it's the word that has already started and if we reach other space chracter it's actually an end.\n\n\nclass Solution:\r\n    def lengthOfLastWord(self, s: str) -> int:\r\n        word_symbols = 0\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == ' ' and word_symbols != 0:\r\n                break\r\n            if s[i] == ' ':\r\n                word_symbols = 0\r\n            else:\r\n                word_symbols += 1\r\n \r\n        return word_symbols"", 'class Solution:\r\n    def lengthOfLastWord(self, s: str) -> int:\r\n        length, prevLength = 0, 0\r\n        \r\n        for char in s:\r\n            if char == "" "":\r\n                if length != 0:\r\n                    prevLength = length\r\n                length = 0\r\n            else:\r\n                length += 1\r\n                \r\n        return length if length != 0 else prevLength', ""Hey Neet,\n\nI think I brute forced this with 1 for loop, but leetcode doesn't like my solution. Could you or anyone else help me evaluate my solution? and its efficiency in big o notation?\nclass Solution:\r\n\n    def lengthOfLastWord(self, s: str) -> int:\r\n\n        \r\n        maxStr = ''\r\n        \r\n        for i in range(len(s)):\r\n        \r\n            if s[i] != ' ':\r\n                maxStr += s[i]\r\n                continue\r\n            \r\n            if s[i:] == ' '*len(s[i:]):\r\n                return len(maxStr)\r\n            \r\n            \r\n            maxStr = ''\r\n                \r\n        return len(maxStr)\n\nThanks in advance!\n-Harris"", ""I have submitted this:\nclass Solution(object):\r\n    def lengthOfLastWord(self, s):\r\n        array = s.split(' ')\r\n        x = array[len(array)-1]\r\n        count = 0\r\n        while x == '':\r\n            count += 1\r\n            x = array[len(array) - count]\r\n        if  x != '':\r\n            counter = 0\r\n            for i in x:\r\n                counter += 1\r\n            return counter"", 'This code is not working on leedcode compiler. I getting time out errror']"
152,4pY1bsBpIY4,"['💡 DYNAMIC PROGRAMMING PLAYLIST: https://www.youtube.com/watch?v=73r3KWiEvyk&list=PLot-Xpze53lcvx_tjrr_m2lgD2NsRHlNO&index=1', 'thank you sir', 'Great explanation with decision tree', 'Simple Java DP:\n\n        int N = days.length, index = 0, lastDay = days[days.length - 1];\n        DP[0] = 0;\n\n        for (int i = 1; i <= lastDay; i++) {\n            if (days[index] == i) {\n                int c1 = DP[i - 1] + costs[0];\n                int c2 = (i >= 7 ? DP[i - 7] : 0) + costs[1];\n                int c3 = (i >= 30 ? DP[i - 30] : 0) + costs[2];\n\n                DP[i] = Math.min(c1, Math.min(c2, c3));\n                index++;\n            } else {\n                DP[i] = DP[i - 1];\n            }\n        }\n\n        return DP[lastDay];', 'my DP solution without recursion\n\n\nclass Solution:\r\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\r\n        dp = [min(costs)]\r\n        for i in range(1, len(days)):\r\n            seven = bisect.bisect_left(days, days[i]-6)\r\n            thirty = bisect.bisect_left(days, days[i]-29)\r\n            val = dp[-1]+costs[0]\r\n            if seven<=0:\r\n                val = min(val, costs[1])\r\n            else:\r\n                val = min(val, dp[seven-1]+costs[1])\r\n            if thirty<=0:\r\n                val = min(val, costs[2])\r\n            else:\r\n                val = min(val, dp[thirty-1]+costs[2])\r\n            dp.append(val)\r\n        return dp[len(days)-1]', ""Good algorithm ! But how to prove that it's optimal ? For instance (wrong example, but still good for an argument), I can argue that sometimes buying tickets in advance can lead to a more optimal solution."", 'Thnx man 🥺', ""I wonder. I can't implement my thought easily, but you make complex problems easy to understand and write in such a simple way! Hats off to you!"", 'Java solution for the same:\n\npublic int mincostTickets(int[] days, int[] costs) {\n        return dfs(0, days, costs, new HashMap<>());\n    }\n\n    public int dfs(int i, int[] days, int[] costs, HashMap<Integer, Integer> dp) {\n        if (i == days.length) {\n            return 0;\n        }\n        if (dp.containsKey(i)) {\n            return dp.get(i);\n        }\n        int[] dayRow = new int[]{1, 7, 30};\n        for (int d = 0; d < 3; d++) {\n            int j = i;\n            while (j < days.length && days[j] < days[i] + dayRow[d]) {\n                j += 1;\n            }\n            int val = Math.min(dp.getOrDefault(i, Integer.MAX_VALUE), costs[d] + dfs(j, days, costs, dp));\n            dp.put(i, val);\n        }\n        return dp.get(i);\n    }', 'Love the picture form ⚡👁']"
153,M0Zay1Qr9ws,"['hi - is there a leetcode playlist for this as well?', ""I watch entire videos! Because I'm a beginner so the coding section is really helpful! Thank you for the great explanation :)"", 'Helpfull', 'but the test case says 20 is an ugly number.', '20 is not considered an ugly number. An ugly number must only be divisible by 2, 3, or 5, but 20 is also divisible by 4, which is not among the allowed prime factors. -source chatgpt', 'Actually that shows ""Time Limit Exceeded""\n\nA better solution can be:\n\nif (n < 0)\r\n                return false;\r\n            while (n > 1)\r\n            {\r\n                if (n % 2 == 0) n /= 2;\r\n                else if (n % 3 == 0) n /= 3;\r\n                else if (n % 5 == 0) n /= 5;\r\n                else return false;\r\n            }\r\n            return n ==1;', 'Thanks', '++subscribers', 'You just made it quick and easy.. Thanks!!', ""What happens if n is 1. This code seems like it return it as True even though the prime number of 1 is not 2 3 or 5. shouldn't it be if n<=1 return false? Or am i mistaking something""]"
154,DEJAZBq0FDA,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'def removeDuplicate(n):\r\n    l = 1\r\n    for r in range(1, len(n)):\r\n        if n[r] != n[l]:\r\n            l += 1\r\n            n[l] = n[r]\r\n\r\n    return l+1', 'This problem is written like shit. This comment helped solve it without watching the solution:\n\n""They don\'t really want you to remove the duplicates. They want you to sort the uniques at the front, then return the length of the sorted part. Then, behind the scenes, they slice the array at the length you give them and the result of that is what they check.\n\nJust FYI, this sh_t drove me crazy...""', 'If input is [1,1,2] it will do [1,2,2] and l=2\nSo print [1,2] \nBut expected output is [1,2,_] \nTo do this you need to create new array', 'It not delete just reassign value', '10:00 1 <= nums.length <= 3 * 104 empty array is not a valid test case !', 'if array like [0 1 2 2 3] and we are starting from index 1  then    r # r+1 so we lose the value 1 cuz 2#1, can someone explain me pls', ""when i put the same code you did I still didn't get the write answer"", 'In my opinion, how about we used sort function? Answer : unique_arr = list(set(arr))', ""Why is this code not working for the solution?\n\nclass Solution:\n    def removeDuplicates(self, nums):\n        uniqueset = set()\n        for n in nums:\n            uniqueset.add(n)\n        \n        return len(uniqueset)\n\nI've tried this outside of LeetCode's checkers and it returns an integer of the expected length. Doing print(uniqueset) returns a set of the expected values, but Leetcode's checker says it returns a completely different list of values. I'm very confused as to what has gone wrong, but I am new to Python3.""]"
155,qK4PtjrVD0U,"['you losed all my respecct by just showing the code and showing the least amount of explanan=ition for how we are gonna create the children array', 'Excellent', 'Hey man, can you upload the much hyped logN solution', '3:45 me when solving an easy question first try', 'I really appreciate your video!!! Can you please also do one on ""Remove K Digits""?', 'great stuff', 'amazing explanation', 'Tried weekly contest problems?', ""Sir today's weekly contest, problem 2. I was getting TLE. Was able to solve just 2"", 'Thanks!']"
156,0sWShKIJoo4,"['I came up with a solution, but with more optimization. Let me explain:\r\nTime complexity O(2n) \r\nSpace Complexity O(1)\r\n\r\n1. First, we find the shortest string in the array and store it in a variable called \'ans.\' We then remove this shortest string from the array.\r\n2. Next, we iterate through all the remaining strings one by one. For each string, we check if the last character of \'ans\' matches the character at the same index in the current string.\r\n3. If there is a match, we move on to the next iteration.\r\n4. If there is no match, we remove the character from our \'ans\' variable and enter a loop. In this loop, we continue checking the second-to-last character of \'ans\' and so on, until \'ans\' becomes empty.""', 'Did it work? Yes. Did it make sense? No.', 'im not sure how you added I == Len(s) *what purpose it serves', 'could you reiterate concept of inbound and outbound?', 'Why don\'t use sorted like others:\n\nclass Solution:\r\n    def longestCommonPrefix(self, v: List[str]) -> str:\r\n        ans=""""\r\n        v=sorted(v)\r\n        first=v[0]\r\n        last=v[-1]\r\n        for i in range(min(len(first),len(last))):\r\n            if(first[i]!=last[i]):\r\n                return ans\r\n            ans+=first[i]\r\n        return ans', 'Thanks for the video))', ""thanks for the code i was trying to do this but wasn't able to"", 'we are using for loop inside another for loop. isnt the time complexity n2? Exponential', 'how can you say its O(n) when you have nested loops lol. Its O(n*m)', ""Why isn't the time complexity O(n^2)? There's a nested for loop""]"
157,5eIK3zUdYmE,"['💡 GRAPH PLAYLIST: https://www.youtube.com/watch?v=EgI5nU9etnU&list=PLot-Xpze53ldBT_7QA8NVot219jFNr_GI', 'hope one day i reach your level♥', ""One small question, when we are assigning prices = tmpPrices aren't the two lists actually referencing to the same data? In this way if we make any change in tmpPrices down the line inside the loop then the same will be reflected in the original array right? Doesn't this defeat the whole purpose of using a tmpPrices array?"", ""Great explanation. I did it in a DFS way but don't know why it doesn't work. Maybe I'm missing some edge cases."", 'i went through the entire video to get the main idea but mostly it explains the steps in the code, i cant understand anything from the video, may be i am too dumb.', 'Its just too much man, How many problems are out there, and why should I learn all this, Fuck it man', ""How did you come up with this solution ? is there any resource ? it's simple , i agree the most"", 'Temp array isn’t still clear. You rushed it too quickly.', 'Unfortunately, I just don’t understand how applying the Bellman Ford algorithm, magically solves the problem. If there’s someone who can explain why it works, it’d be very helpful.', 'I tried to implement it by myself a week or two later with bellman ford and I struggled a lot, try it by yourself after some time, I had to revisit this video']"
158,q0s6m7AiM7o,"['💡 BACKTRACKING PLAYLIST: https://www.youtube.com/watch?v=pfiQ_PS1g8E&list=PLot-Xpze53lf5C3HSjCnyFghlW0G1HHXo', ""Could anyone explain why need to do comb.pop(), I'm quite comfusing, thanks"", ""There's an optimization you can do. Instead of looping till n+1, which results in some branches that don't have enough height to make a k-combination, you loop till the last number from which it is possible to make a k-combination.\n```\n# Number of elements still needed to make a k-combination.\nneed = k - len(comb)\n# The range of numbers is [i, n], therefore, size=n - i + 1\nremaining = n - i + 1\n# This is the last offset from which we can still make a k-combination.\noffset = remaining - need\nfor i in range(start, start + offset + 1):\n```"", 'That was so helpful...Thanks', 'Thank you brother...', ""At first I was having so much trouble understanding backtracking. I watched your videos for recursive tree problems and it helped me so much and I started watching your videos for backtracking and I'm beginning to see the pattern template for a majority of these problems. Thank you so much!"", 'I was struggling a lot with backtracking problems. Now  I can solve it without any help because of your videos. Thanks man!', 'You are really great in explaining', 'I have a question on the code. What prevents us from going past n+1 for the last value of the list comb for every single iteration.', '9:11 Thanks alot, I was eating. lol']"
159,3jdxYj3DD98,"['what is inbounce said by neetcode ?can someone explain me?', 'Did this yesterday. My solution was too complex, but faster. This is way easier to grasp.', 'I never thought I would be able to understand how this problem worked, thanks so much.', ""why does everyone keep saying it's easy? 🥲🥲"", ""dang I never knew the concepts of hashmaps before this, I kinda have the same logic but instead of hashmaps, I used an if else statement to convert each roman to its corresponding value and store it in another array to use that array for the main logic part of the code. if (s[i] == 'I') {arr[i]=1} etc."", 'Please provide cpp and java solution also. \nit is really helpful', 'this is the best explanation of this problem. clean and simple.', 'Thanks Neetcode for awesome explanations. Where can I find the code snippet to your solutions ?', '""I am getting this error, someone plz help""\nTypeError: None is not valid value for the expected return type integer\r\n    raise TypeError(str(ret) + "" is not valid value for the expected return type integer"");\r\nLine 37 in _driver (Solution.py)\r\n    _driver()\r\nLine 44 in <module> (Solution.py)\r\nDuring handling of the above exception, another exception occurred:\r\nTypeError: \'<\' not supported between instances of \'int\' and \'NoneType\'\r\nLine 12 in _serialize_int (./python3/__serializer__.py)\r\nLine 61 in _serialize (./python3/__serializer__.py)\r\n    out = ser._serialize(ret, \'integer\')\r\nLine 35 in _driver (Solution.py)', ""im so confused man, WHAT is the problem. like WHAT is the question? i don't see what they're asking us to do""]"
160,lRCaNiqO3xI,"['Everybody is saying to use a Min Heap with Kth Largest and a Max Heap with Kth Smallest yet your usage of Max heap for this seems more intuitive.', '3:22 is fine either way, even if original array have negative values', 'Why stoi() is not working here?', '3 line solution with O(nlog(n))\n\n        val = [ int(x) for x in nums ] \r\n        val.sort(reverse=True)\r\n        return str(val[k-1])', 'I found a bug. \n\nThe Problem Link is wrong :-)', 'Only explanation from neet code that was not immersive. Probably will look up heapify on my own and will come back here', 'Can you make videos on query based questions', 'Can we generally ignore the time complexity for converting string to an integer ?', ""why don't you do the hard problem?"", 'Cant we just use a k-sized min_heap so that we can get NLog(k) time complexity?']"
161,JU5XdBZZtlk,"['spent forever trying to solve it in O(n) lol', 'Why is this listed as a 2 pointer problem on your site and not sliding window? Took me forever trying to solve this lol', 'can we put an initial difference not ""Infinite"" but the difference between first and last elements of the sorted array? technically it will be the max difference possible in the array', 'Is it possible of O(n)?', ""What's the space complexity of sort?"", 'Sounds like you got a better mic. It sounds good.', 'Respect++ !\nPlease never stop uploading!', 'Thanks for uploading at night haha', 'Thanks a lot!']"
162,QfJsau0ItOY,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', ""it looks like you have to go through all the nodes to determine if tree is balanced. But in fact, it's enough to find out that one of the subtrees is not balanced to get the answer."", 'Thanks for an explanation! I think it may be more efficient if, instead of tracking the additional ""balanced"" variable, we raise a custom exception if an unbalanced pair of subtrees is found and immediately return False.\n\nE.g.\n\n       def height(root):\n            ...\n            if abs(leftHeight - rightHeight) > 1:\r\n                raise UnbalancedError\n\n\n            ...\n\n      try:\r\n            height(root)\r\n            return True\r\n      except UnbalancedError:\r\n            return False', 'When/where are the height values set?', 'I love when you explain something for the first time and it clicks even before seeing the code! Shows how great the explanation is', 'Can we create an exit condition here so that when we recieve a false the entire recursion tree stops and the final output is false. All options i considered just result in an early return instead of stopping the entire recursion tree.', 'class Solution:\r\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\r\n    \r\n    \r\n        res = True\r\n        def maxDepth(root):\r\n            nonlocal res\r\n            if not root:\r\n                return 0\r\n            left = maxDepth(root.left)\r\n            right = maxDepth(root.right)\r\n            if abs(left - right) > 1:\r\n                res = False\r\n            return 1 + max(left,right)\r\n        \r\n        maxDepth(root)\r\n        return res', 'this one is VERY difficult for me', 'You are just the best, thank you so much!', ""In case returning tuples in recursion is confusing to someone, here's a solution I did where the helper function returns just an integer that is either -1 or the max_depth:\n------\n\ndef isBalanced(self, root: Optional[TreeNode]) -> bool:\n        \n        def calc_depth(node):\n            if not node:\n                return 0\n            \n            left = calc_depth(node.left)\n            right = calc_depth(node.right)\n\n            if abs(left - right) > 1:\n                return -1\n            \n            if min(left,right) == -1:\n                return -1\n\n            return 1 + max(left, right)\n        \n        return calc_depth(root) != -1""]"
163,XEmy13g1Qxc,"['Received Time Limit Exceeded error for your solution.', 'Thanks about the time complexity!', ""Doing an example where you don't need to swap anything until there are only two elements is so frustrating. Like I'm looking to understand how quick select works and you give an example where you don't need to do anything. Oh my god why would you choose that example. From your drawing explanation it is so hard to actually understand how the algorithm works."", ""why can't we use heaps here?"", ""It's a pretty common case to have to work on data that is pre-sorted or near pre-sorted, so this implementation with using the last element as the pivot isn't a good choice. Many people have suggested picking a random element and switching it for the last element, but for arrays where every element has the same value that still leaves the input array sorted and still takes quadratic time. An additional improvement is to keep track of the last index < pivot and use that for the left window, instead of p-1. This eliminates processing duplicates of the pivot repeatedly. E.g.: \n\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        k = n - k\n\n        def quickselect(l, r):\n            pivotIndex = random.randint(l, r)\n            nums[pivotIndex], nums[r] = nums[r], nums[pivotIndex]\n\n            pivot = nums[r]\n            p = l\n            lessEnd = -1\n            for i in range(l, r):\n                num = nums[i]\n                if num < pivot:\n                    lessEnd = p\n                if num <= pivot:\n                    nums[p], nums[i] = nums[i], nums[p]\n                    p += 1\n            \n            nums[p], nums[r] = nums[r], nums[p]\n\n            if k > p:\n                return quickselect(p+1, r)\n            elif k > lessEnd:\n                return nums[p]\n            else:\n                return quickselect(l, lessEnd)\n\n        return quickselect(0, n-1)"", 'You should have taken any other example. In this example you get same result after arrangement', ""new test case is added and the quick select's O(n^2) is no longer passed now."", 'This now exceeds the time limit due to the last test case added by leetcode.', 'Sadly this method is no more available on leetcode now...\nThey added a testcase which leads to time limit...', 'Today quick select throws Time Limit Exceeded']"
164,Mjy4hd2xgrs,"['This one turned out pretty long, but I hope the timestamps are helpful. Also, the code for all 3 solutions is in the description. 😃', 'Very nice explanation. But I would like to suggest you (from a pedagogical point of view), that it would be better if you had the amounts in the ascending order (left = 0 to right = 5) instead of the other way around, as l2r is the way most people think about arrays.', 'terrible explaination, this video is trash', ""Instead of dp[coin][amount] why can't we just use dp[amount] = number of ways for change?\n\nWe can say we have all coins available, and it should give the answer still?"", '""And this path, will never have any(one)""  4:05😢', ""Hmm, the coins order have be ascending ordered (from lowest to highest), instead the DP solution won't pass test case where coins=[99,1]"", 'This explanation was very difficult for me to understand, as it sounded a bit disorganized. Appreciate the upload regardless', 'I fail to understand the table that is introduced at 8:05 .', 'Hi so I tried to do a memoization approach instead of a tabulation approach, where I made a function and in a for loop I went through each index, i, and made a subproblem with amount - coins[i], and starting at index i, for subproblem. I am able to complete this problem, but I realize my approach is very slow compared to a lot of the others I see. I was wondering, does anyone know why that is?', 'Great explanation! the only input that I want to add is that for the recursive top-down solution, while it can produce the correct answer,\nthe more accurate code that faithfully follows the top-down solution logic should be starting condition for ""dfs(0, amount)"", then change the base case in dfs(i, a) with following code:\n""if a == amount"" -> ""if a == 0""\n""if a > amount"" ->  ""if a < 0""\nand change the general case code as follows:\n""cache[(i,a)] = dfs(i, a + coins[i]) + dfs(i + 1, a)"" -> ""cache[(i,a)] = dfs(i, a - coins[i]) + dfs(i + 1, a)""\n\nThe complete code is as follows:\nclass Solution(object):\n    def change(self, amount, coins):\n        """"""\n        :type amount: int\n        :type coins: List[int]\n        :rtype: int\n        """"""\n        cache = {}\n        \n        def dfs(i, a):\n            if a == 0:\n                return 1\n            if a < 0:\n                return 0\n            if i == len(coins):\n                return 0\n            if (i, a) in cache:\n                return cache[(i,a)]\n            \n            cache[(i,a)] = dfs(i, a - coins[i]) + dfs(i + 1, a)\n            return cache[(i,a)]\n\n        return dfs(0, amount)\n\nthe reason why we start with dfs(0, amount) is because in top down approach, we start with the final result value then slowly build our solution from the value amount to value 0(base case)']"
165,Q2Tw6gcVEwc,"[""I created a second channel where I post the daily LC solutions 👉 https://www.youtube.com/@NeetCodeIO\n\nIn case you're interested!"", 'How can we come up with this type of solution in 45 min interview? 🤕', 'class Solution(object):\r\n    def convert(self, s, numRows):\r\n        """"""\r\n        :type s: str\r\n        :type numRows: int\r\n        :rtype: str\r\n        """"""\r\n        if numRows==1 : return s\r\n        n=k=0\r\n        l=[]\r\n        for i in range(numRows):\r\n            l.append([])\r\n        j=1  \r\n        for i in s:\r\n            l[n].append(i)\r\n            if n==numRows-1: j=-1\r\n            elif n==0: j=1\r\n            n+=j\r\n        r=""""\r\n        for i in range(numRows):\r\n            r+="""".join(l[i])\r\n        return r', 'HERE\'S THE EASY C++ CODE FOR THIS PROBLEM - \r\n\nstring Solution::convert(string s, int n) {\r\n    if (n == 1 || s.length() <= n) {\r\n        return s;\r\n    }\r\n\r\n    vector<string> str(n, """");\r\n    \r\n    int i = 0;\r\n    while(i < s.size()) {\r\n        int j = 0;\r\n        while(j < n && i < s.size()) {\r\n            str[j] += s[i++];\r\n            j++;\r\n        }\r\n        \r\n        j -= 2;\r\n        while(j > 0 && i < s.size()) {\r\n            str[j] += s[i++];\r\n            j--;\r\n        }\r\n    }\r\n     \r\n    string res = """";\r\n    for(int i = 0; i < n; i++) {\r\n        res += str[i];\r\n    }\r\n    return res;\r\n}', 'Can you explain the algorithm of (numRows - 1) * 2?', 'this problem humbled me real quick 😅', ""I Think this solution is really what comes to my head over the strings one, i couldn't break it down somehow. Thank you for the explanation"", 'Hey, i had a bit of confusion still can you help me out\nin explanation for 2nd and 3rd row you used formula as increment-2*rownumber, but in code you used + i I didn\'t catch that from where that ""i"" come from, so can you explain bit about it.', 'THANK-FUCKING-YOU!!!', 'So clean thought process👏']"
166,aHqn4Dynd1k,"[""wouldn't the worst case still be O(2^n), if we went through all possible combinations and only the last string is the answer?"", 'another simple solution, notice we have n elements of n length binary. In n-length binary, we can have 0, 1, ... n set bits (n+1) variation. So we just need to find which set bit variation is missing. I think this is better than backtracking and worse than cantor diagonal elements mentioned in top comment.', 'C# Equivalent code for above\n\n\n    public class Solution\r\n    {\r\n        string res = """";\r\n        public string FindDifferentBinaryString(string[] nums)\r\n        {\r\n            HashSet<String> set = nums.ToHashSet();\r\n            string[] arr = Enumerable.Repeat(""0"", nums.Length).ToArray();\r\n            return BackTrack(0, arr,nums, set);\r\n        }\r\n        private string BackTrack(int i,string [] arr,string [] nums, HashSet<string>set)\r\n        {\r\n            if(i==nums.Length)\r\n            {\r\n                res = String.Join("""", arr);\r\n                return set.Contains(res) ? null : res;\r\n            }\r\n            res = BackTrack(i + 1, arr, nums, set);\r\n            if(!string.IsNullOrEmpty(res))\r\n            {\r\n                return res;\r\n            }\r\n            arr[i] = ""1"";\r\n            res= BackTrack(i + 1, arr, nums, set);\r\n            if (!string.IsNullOrEmpty(res))\r\n            {\r\n                return res;\r\n            }\r\n            return """";\r\n        }\r\n    }', 'Here is a quick and easy way to generate all binary strings of length n using the native  _itertools.product_ iterator method\n\n\nclass Solution:\n    def findDifferentBinaryString(self, nums: List[str]) -> str:\n        nums = set(nums)\n        for seq in itertools.product(""01"", repeat = len(nums)):\n            binString = """".join(seq)\n            if binString not in nums:\n                return binString', 'No backtracking, O(N) space and time:\n\nN==len(nums)==len(nums[0]) is given.\nWe want to find a binary number up to \'1\'*len(nums[0])==\'1\'*N that isn\'t present in nums.\nWe can scan through all 2^N possibilities (00..00 to 11..111), and because we are guaranteed that nums is of size N -> we will need to check only N elements of that range, the worst case being where nums is constructed of 0 to N-1, for which we will return N as an answer. Otherwise - we will return a candidate smaller than N which would not be present in nums.\n\nclass Solution:\n    def findDifferentBinaryString(self, nums: List[str]) -> str:\n        present=set()\n        # O(N)=O(16)\n        for n in nums:\n            present.add(int(n,base=2))\n\n        # although we search through 2^N elements, since nums is of size N, and each element of nums in of size N, \n        # our worst case would be to encounter all N consecutive nums - O(N), and then a new num.\n        for i in range(2**len(nums)):\n            if i not in present:\n                ans=f""{i:b}""\n                return ""0""*(len(nums[0])-len(ans))+ans', 'For those who are looking for Java Solution\n\nclass Solution {\n    \n    HashSet<String> set = new HashSet<>();\n    public String findDifferentBinaryString(String[] nums) {\n        int n = nums.length;\n        char[] ans = new char[n];\n        for(int i = 0 ; i < n  ; i ++){\n            set.add(nums[i]);\n            ans[i] = \'0\';\n        }    \n        if(helper(ans,0)){\n            return String.valueOf(ans);\n        }\n        \n        return """";\n    }\n    \n    public boolean helper(char[] ans , int idx){\n        \n        if(idx == ans.length){\n            if(set.contains(String.valueOf(ans))){\n                return false;\n            }\n            return true;\n        }\n        \n        if(helper(ans,idx+1)){\n            return true;\n        }\n        ans[idx] = \'1\';\n        if(helper(ans,idx+1)){\n            return true;\n        }\n        \n        return false;\n    }\n}', 'Besides O(N) solution: what about building a trie from given strings and then doing a BFS? BFS will allow you to find a node with only 1 child and it is trivial to build a new binary string from this node.', 'Blessed, bit shifiting questions usually are hieroglyphics to me but you made it simple', 'I solved it using general backtracking template as we used to solve combinations , permutations-\nclass Solution:\n    def findDifferentBinaryString(self, nums: List[str]) -> str:\n        strSet = {s for s in nums}\n        k = len(nums)\n        def dfs(comb):\n            if len(comb) == k:\n                res = """".join(comb)             \n                return None if res in strSet else res\n            \n            for i in range(0,2):\n                comb.append(str(i))\n                res = dfs(comb)\n\n                if res is not None:\n                    return res\n                comb.pop()\n            \n        return dfs([])', 'I do not think that u need a set. Cause problem states that ""nums containing n UNIQUE binary strings "". so this works:\n""return None if res in nums else res""']"
167,g9YQyYi4IQQ,"['Thank you!', ""I wish I knew why leetcode didn't explicitly indicate x**n was an invalid answer. It actually passes for me."", 'return x**n 😄', 'What are the time and space complexity for this answer ?', 'I could solve the problem in one line using the pow function. Pow(x, n) and it passed all test cases.', 'If we remove this snippet from solution, it still works and passes all test cases: \n-->\nif x == 0:\n    return 0\n\nWe could write it to check 0 value at the first line of the solution.', ""Idk as dumb as I am I just randomly submitted return pow(x,n) and it beat 100%. I wonder why. Like it's tagged medium and if it's medium it's obvious that I wouldn't be able to solve it in a week"", 'change line 4, if x==0 and n==0, we return 1', 'class Solution:\r\n    def myPow(self, x: float, n: int) -> float:\r\n        if n == 0:\r\n            return 1\r\n        \r\n        elif n < 0:\r\n            return self.myPow(1/x, -n)\r\n        \r\n        if n % 2 == 0:\r\n            temp = self.myPow(x, n/2)\r\n            return temp * temp\r\n        \r\n        else:\r\n            return x * self.myPow(x, n - 1)\r\n\r\n#faster than 90% solution', 'Finally I could solve this problem in c# with less code than python 😂😂\n\npublic double MyPow(double x, int n) {     \r\n        if (x == 0 ) return 0;\r\n        if (n == 0 || x == 1) return 1;   \r\n        var res = MyPow(x * x, Math.Abs(n/2));\r\n        res = n % 2 == 0 ? res : x * res;\r\n        return n < 0 ? (1/res) : res;\r\n    }']"
168,yubRKwixN-U,"[""this one needs update, doesn't work on x0000xx"", 'Thank you!', 'Simple, efficient and straight to the point. Thanks for this answer.', 'we can simply change it to string?', 'Thank you!', 'why do you assume 21/10 rounds down to 2?', 'Will this work?\nx_str = str(x)\r\n    return x_str == x_str[::-1]', 'Nice Solution!\nWe can write the divider value in this way as well 8:37:\n        if x==0: return True\n        div = 10**int(math.log10(x))', 'Will this solution work for this testcase? \n\n1000021\n \nBecause, once we remove the first and the last letter and proceed to the next step, \nwe have\n000021   which is evaluated as 21', 'Anyone knows why do we need to divide div by 100? The condition div = div // 100.']"
169,A__UXuFjOrA,"[""I'm sorry to the 18% of you who are Java people - didn't mean to crap on your language 😭"", 'Rust?', 'what about rust?', 'What about the ones liying below\nneetcode: Ahh they dont deserve a tier anyway☘', 'I love how Java has .length for normal arrays, .length() for strings, and .size() for ArrayList lol', ""Lol talking trash on c#, you really don't know what you are talking about, sounding like some freshman kid"", ""My undergrad CS courses shoved Java down my throat, so I'm used to seeing data structures in that language despite Python being easier!"", ""Being a Java programmer, I'm surprised he didn't put it in F Tier"", 'now do the rest of the languages, php, ruby, groovy', 'I use Java in my interview and OAs, it definitely wasted tons of times. However, I managed it and got the offer. Now I start Leetcode again with Python, see how far I can go']"
170,HAgLH58IgJQ,"['The following is a much easier way, please have a look:\n\ndef reverse(self, x: int) -> int:\r\n        upper_limit = (2**31) - 1\r\n        lower_limit = (-2**31) \r\n\r\n        if x > 0:\r\n            x = str(x)\r\n            x = x[::-1]\r\n            x = int(x)\r\n            if x in range(lower_limit, upper_limit):\r\n                return x\r\n            else:\r\n                return 0\r\n        \r\n        elif x < 0:\r\n\r\n            x = str(x)\r\n            x1 = x[0]\r\n            x = x.replace(""-"","""")\r\n            x = x[::-1]\r\n            x1 += x\r\n            x1 = int(x1)\r\n            if x1 in range(lower_limit, upper_limit):\r\n                return x1\r\n            else:\r\n                return 0\r\n            \r\n        else:\r\n            return 0', ""```\nif res < MIN // 10 or (res == MIN // 10 and digit < MIN % 10):\n```\n\n`digit < MIN % 10` seems like *almost* bug since you're using regular % on the negative MIN, which will give a positive number (in this case `2`), whereas `digit` will always be zero or negative on this code path. However, It's not technically a bug because it's unreachable code. There's no case where `res == MIN // 10` is True where the digit will be invalid, so the condition will always be short-circuited. `digit < MIN % 10` could just be removed."", ""Crazy how like 90% of the most upvoted Python solutions on this problem didn't understand or just ignored the constraint on staying within 32 bits."", ""Here you mentioned bit manipulation, but it seems you didn't used bit manipulation. \n\nCan we do this problem using bit manipulation?\n\nAnyone please clarify this to me.\n\nThanks in advance!"", 'Why is this problem under Bit manipulation?', 'great explanation. thanks for all the efforts', ""Can't understand why we are using two different ways of mod:\nint(math.fmod(x, 10))\nMIN_INT % 10"", ""Java Code:\n\nclass Solution {\r\n    public int reverse(int x) {\r\n        StringBuilder s = new StringBuilder();\r\n        s.append(x);\r\n\r\n        char sign = '+';\r\n\r\n        if(s.charAt(0) == '-')\r\n        {\r\n            sign = s.charAt(0);\r\n            s.delete(0,1);\r\n        }\r\n        \r\n        s.reverse();\r\n\r\n        long val = Long.parseLong(s.toString());\r\n        if(val > Integer.MAX_VALUE || val < Integer.MIN_VALUE)\r\n            return 0;\r\n        \r\n        if(sign == '-')\r\n            return -1 * (int) val;\r\n        return (int) val;\r\n    }\r\n}"", ""I don't know if it's just me, but this looks more complicated than it needs to be 😅\n\nI would just treat both negative and positive cases with the same code and put all conditions into one if statement, like this:\n```\nclass Solution:\n    def reverse(self, x: int) -> int:\n        negative = x < 0\n        x = x if not negative else (-1) * x\n        limit = 2**31 - 1 if not negative else 2**31\n        res = 0\n        while x != 0:\n            if res > (limit - x % 10) // 10:\n                return 0\n            res = res * 10 + x % 10\n            x //= 10\n        return res if not negative else (-1) * res\n```"", 'Just finished this problem as the final problem of the NeetCode 150! Neetcode ALL TIME!']"
171,9z2BunfoZ5Y,"['💡 GRAPH PLAYLIST: https://www.youtube.com/watch?v=EgI5nU9etnU&list=PLot-Xpze53ldBT_7QA8NVot219jFNr_GI', 'Free Palestine', 'Not the answer shown here, but:\n\nAny ideas why this is incorrect?\n\nclass Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        i, j, visited = 0, 0, set()\n\n        def dfs(r, c, visited):\n            if (r, c) in visited:\n                return True\n            visited.add((r,c))\n\n            directions = [(r+1,c), (r-1,c), (r,c+1), (r,c-1)]\n\n            for direction in directions:\n                # check border cases\n                if (\n                    direction[0] == len(board) or\n                    direction[0] < 0 or\n                    direction[1] == len(board[0]) or\n                    direction[1] < 0\n                ): return False\n\n                if board[direction[0]][direction[1]] == ""O"" and not dfs(direction[0], direction[1], visited):\n                    return False\n\n            return True\n\n        while i < len(board):\n            while j < len(board[0]):\n                if board[i][j] == ""O"":\n                    shouldCapture = dfs(i, j, visited)\n                    if shouldCapture:\n                        for coord in visited:\n                            board[coord[0]][coord[1]] = ""X""\n                    visited = set()\n                j += 1\n            i += 1', 'Is it worth trying to avoid recursion and use heap-based stack (which is not easy)? Or really nobody cares?', ""it's fairly common in graph problems to have a solution to the inverse of the problem be much easier than the solution to the actual problem itself. The Algorithm book by dasgupta, used in UCB, also mentions this. The backbone idea behind why this works is because if A is reachable from B, then B is also reachable from A. This is why in connected components of a graph, the exploitation of this very simple idea leads to a fairly simpler solution. Pacific-atlantic water flow, 0-1 matrix, surrounded regions, and many more questions can be solved in a much simpler way if we carefully observe the inverse problem. Even when we try to find all the SCC in a graph, we try to find the sink SCC of the graph first, but since it cannot be calculated directly, we reverse the graph (G^-1), find it's source because source can be calculated easily, and this source becomes the sink of the actual graph. Again, calculating the solution to the inverse of a problem leading to an actual solution. I think it's called the kokuraja's algorithm or something."", 'I have a Google interview coming up. Wish me luck', 'Along the same thought process, I found it easier to 1.mark the ""O""s connected to any sides in a set, then 2.flip any ""O"" that aren\'t in that set to ""X"". Very similar to the Pacific Atlantic water flow question. Here is my code:\ndef solve(board):\r\n\r\n    ROWS, COLS = len(board), len(board[0])\r\n    noflip = set()\r\n\r\n    def dfs(r,c):\r\n        if r < 0 or r >= ROWS or c < 0 or c >= COLS or (r,c) in noflip or board[r][c] == ""X"":\r\n            return\r\n        noflip.add((r,c))\r\n        dfs(r+1,c)\r\n        dfs(r-1,c)\r\n        dfs(r,c+1)\r\n        dfs(r,c-1)\r\n\r\n    for r in range(ROWS):\r\n        dfs(r,0)\r\n        dfs(r, COLS-1)\r\n    for c in range(COLS):\r\n        dfs(0,c)\r\n        dfs(ROWS-1,c)\r\n\r\n    for r in range(ROWS):\r\n        for c in range(COLS):\r\n            if board[r][c] == ""O"" and (r,c) not in noflip:\r\n                board[r][c] = ""X""', 'one of the most unique solutions i have seen for this problem.........', 'Great video. Is anyone able to explain why we can’t just iterate through the matrix and see if, once we landed on a O “island”, we can connect that to an edge of the matrix - and return a boolean of whether the value should be “captured” accordingly? I initially tried doing this through DFS, but to no avail, and only then thought to try the approach in the video. However, I still cannot understand why the other method fails. Can anyone explain? Thanks!', 'Leetcode says TC O(N) and SC (ON), I think is O(N*M) like this video']"
172,Wmb3YdVYfqM,"['Looks like an O(N), O(1) solution exists. Make sure no 3 consecutive values are either strictly increasing or decreasing in value\n\n       # Rearange to not allow increasing or decreasing order. \n        for i in range(1, len(nums) - 1):\n            if nums[i - 1] > nums[i] > nums[i + 1] or nums[i - 1] < nums[i] < nums[i + 1]:\n                nums[i + 1], nums[i] = nums[i], nums[i + 1]\n        return nums', 'my solution using O(1) space and O(nlogn) time:\nedit: O(n) space because of .sort(). I just rearranged the array in place instead of using a separate [ ] for the solution \n\nclass Solution:\r\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\r\n        nums.sort();\r\n        for i in range(1, len(nums)-1):\r\n            if i % 2 == 1:\r\n                nums[i], nums[i+1] = nums[i+1], nums[i];\r\n        return nums;', 'pretty easy', 'Cant we do it O(N) like wriggle sort?', 'which is the tool u use to draw', 'plz, make a playlist for String.', 'I’m currently doing DP problems and some solutions start from the end of an array and build towards the front while others start from the front to the end. Should I do a certain direction for convention or is it just a matter of preference or does it depend on the problem?', 'Brother, if u have some time can u make videos of GFG interview series solutions too?  I love your way of explanation. This GFG interview series will be on every sunday 7-8 PM.', 'This channel is seriously under-appreciated. Thank you!', 'More efficient way to solve--\nStep-1 sort\nStep-2 swap pair wise\nDone.']"
173,izRDc1il9Pk,"['🌲 TREE PLAYLIST: https://www.youtube.com/watch?v=OnSn2XEQ4MY&list=PLot-Xpze53ldg4pN6PfzoJY7KsKcxF1jg&index=2', 'neet god!', 'Thank you so much for clear explanation', '7:36 Or r1 == r2 ;D', 'when you are comparing those 6 nodes,  you are drawing faces.', 'so smart', 'Hi, @Neetcode. I would suggest to include the burning of a node problem in this tress playlist', 'your explanations are goated bro wish you had more vids. puts every other LC solution video to shame', ""Beautiful explanation! I've always had trouble dealing with tree problems but your videos really help me a lot in understanding them!""]"
174,nPVEaB3AjUM,"['Absolutely stunning piece of code can i get a reference to Google or Amazon 😃', 'I Have added 1 at both ends and updated unfilled columns with two pointer solution\r\n\r\nList<List<Integer>> result = new ArrayList<>(numRows);\r\n\t\tif (numRows >= 1) {\r\n\t\t\tresult.add(Arrays.asList(1));\r\n\t\t}\r\n\t\tif (numRows >= 2) {\r\n\t\t\tresult.add(Arrays.asList(1, 1));\r\n\t\t}\r\n\t\tif (numRows > 2) {\r\n\t\t\tfor (int i = 3; i <= numRows; i++) {\r\n//\t\t\t\tSystem.out.println(""Processing row: "" + i);\r\n\t\t\t\tList<Integer> prev = result.get(i - 2);\r\n\t\t\t\tList<Integer> current = IntStream.of(new int[i]).boxed().collect(Collectors.toList());\r\n\t\t\t\tcurrent.set(0, 1); // set first\r\n\t\t\t\tcurrent.set(i - 1, 1); // set last\r\n\t\t\t\tint left = 1;\r\n\t\t\t\tint right = i - 2;\r\n\t\t\t\twhile (left <= right) {\r\n\t\t\t\t\tint temp = prev.get(left) + prev.get(left - 1);\r\n\t\t\t\t\tcurrent.set(left, temp);\r\n\t\t\t\t\tcurrent.set(right, temp);\r\n\t\t\t\t\tleft++;\r\n\t\t\t\t\tright--;\r\n\t\t\t\t}\r\n\t\t\t\tresult.add(current);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;', 'I did this problem by myself, however i used binomial distribution. Thank you for your video and explication', 'Your two-pointer hint made this easy. I was stuck on this for awhile\n\nSuper annoying problem', 'how does this question have anything to do with bfs it doesnt use a queue? seems like you just store each layer so you can use it to calculate the next...', 'why have we took res[-1]?', 'Correction maybe :\nfor i in range(1,numRows): #should be the first loop', 'Dynamic Programming :\nInitialize all the elements of the Pascal triangle to 1 and update the triangle excluding the start and end:\n\n\n        result = [ [1]*x for x in range(1,numRows+1)]\n\r\n        for row in range(2, numRows):\r\n            for col in range(1, len(result[row])-1 ):\r\n                result[row][col] = result[row-1][col-1] + result[row-1][col]\n        return result', 'I use dynamic programming and its faster', '#My solution \n\nclass Solution:\r\n    def generate(self, numRows: int) -> List[List[int]]:\r\n        answer = [[1], [1,1]]\r\n        if numRows == 1: return [answer[0]]\r\n        if numRows == 2: return answer\r\n        for i in range(numRows-2):\r\n            answer.append([1])\r\n        for i in range(2, len(answer)):\r\n            for j in range(1, i):\r\n                answer[i].append(answer[i - 1][j - 1] + answer[i - 1][j])\r\n            answer[i].append(1)\r\n        return answer']"
175,utDu3Q7Flrw,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'Does topological sort use dfs or bfs? From explanation it’s describing bfs 😮', 'I know bfs ,dfs,topo sort dijkasta and uninon find little bit too should i start solving questions ?', 'Because of your content..I feel confident while giving interview...huge respect❤', 'this content is gold, man', 'We need a video for LeetCode 1319!', 'i only hear mouth sounds on this video....', ""Great set of problems! Are the problems sorted in order of importance/frequency encountered (IE DFS most important/frequent, Djikstra's algo least important/frequent)?"", ""shouldn't topological sort be BFS and not DFS? (minor error?)"", ""time complexity of dfs isn't O(V+E)?""]"
176,3YDBT9ZrfaU,"[""It's wrong on many levels to ask such a question in an interview"", 'What happens if I just take open brackets. Won’t your solution return 0', ""I just did this:\n\nclass Solution:\r\n    def minSwaps(self, s: str) -> int:\r\n        flips, cSum = 0, 0;\r\n        for b in s:\r\n            if b == '[':\r\n                cSum += 1;\r\n            else:\r\n                cSum -= 1;\r\n            if cSum < 0:\r\n                flips += 1;\r\n                cSum = 1;\r\n        return flips;\n\nBasically, if we ever have a negative sum, it means we have more closed brackets than we do open, so we have to make a swap and turn the ] into [, which means the current sum will be 1 again."", 'its quite similar to Minimum Add to Make Parentheses Valid', 'Mera dimaag kb chlega🥺🥺', 'How did you come up with that?\ngreat solution 🤟', 'A good question for a contest but a bad one for an interview. It such a difficult solution to come to on your own.', ""class Solution:\r\n    def minSwaps(self, s: str) -> int:\r\n        stack = [] \r\n        \r\n        for ch in s:\r\n            if ch == '[':\r\n                stack.append(ch) \r\n            elif stack:\r\n                stack.pop()\r\n        \r\n        return (len(stack)+1)//2\r\n    \r\n    \r\n    \r\n    #approach_2:\r\n    class Solution:\r\n    def minSwaps(self, s: str) -> int:\r\n        size = 0 \r\n        \r\n        for char in s:\r\n            if char == '[': size += 1\r\n            elif size != 0 : size -= 1\r\n        \r\n        return (size+1)//2"", ""you are parrot and i think that's what google wants now a days .. mug up soln"", 'I am confusing why u did divide instead of minus since u said every swap remove 2.  what I know so far is every swap will reduce by two because it will turn to be balanced and only left the unbalance one to swap/solve. For example, 3 -> 1 could be achieved by minus 2 why divide by two. i am stucking at there. pls help']"
177,KxK33AcQZpQ,"['i see a thumbnail of amazon,google and facebook is any of this companies really asked this question?', 'not very interesting question i would say', 'very nice!!! Now i am searching NeetCode first for any search result of problem...', 'wow! brilliant logic.', 'Hi! You are amazing! If I get placed into any company, large part of it will be because of your videos! I love you and keep up the amazing work!', 'Bruh, is it just me or there is some changes to your voice/ its not you.', 'Very well explained!!!👍👍👏👏', 'You are awesome teacher, I wish you had millions of subscribers!!!\nPlease also make videos on leetcode daily challenge and codeforces contest problem...\nThank you so much', 'How many did you manage to complete this time around?', 'Please elaborate 2nd test case, Still I didnt get the question']"
178,B-QCq79-Vfw,"['Great example! After running through the algorithm thoroughly, there is no need for the conditional ""if"" because the Max Heap will always maintain the top 2 highest values.\n\n    def lastStoneWeight(self, stones):\r\n        """"""\r\n        :type stones: List[int]\r\n        :rtype: int\r\n        """"""\r\n        stones = [-s for s in stones]\r\n        heapq.heapify(stones)\r\n\r\n        while len(stones) > 1:\r\n            num1 = heapq.heappop(stones)\r\n            num2 = heapq.heappop(stones)\r\n            heapq.heappush(stones, num1 - num2)\r\n        return abs(stones[0])', ""Isn't it O(1) to pop a max from the heap?"", ""python's amazing... in JS, you need to write your own Heap first..."", 'the second will always be greater right ? i mean why is the if second> first even required?', ""Instead of working with flipped negative values, for the sake of clarity, I've implemented my code to convert these values each time.\nPython code:\n\n\nclass Solution\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        #implement a maxheap\n        negativeHeap = [-x for x in stones]\n\n        heapq.heapify(negativeHeap)\n\n        while len(negativeHeap) > 1:\n            largest = -1 * heappop(negativeHeap)\n            largest2 = -1 * heappop(negativeHeap)\n\n            if largest2 < largest:\n                heappush(negativeHeap, -1 * (largest - largest2))\n        \n        return -1 * negativeHeap[0] if negativeHeap else 0"", 'abs() call is unnecessary because all stones have negative weight. So it is more clear to use ""return -stones[0]"" to be in sync with weights negation at start.', 'class Solution {\r\npublic:\r\n    static int lastStoneWeight(vector<int>& stones) {\r\n        // heapify -> O(n)\r\n        make_heap(stones.begin(), stones.end());\r\n        while (stones.size() > 1){  // O(n)\r\n            int first = stones.front();\r\n            pop_heap(stones.begin(), stones.end()); // log n\r\n            stones.pop_back();\r\n            int second = stones.front();\r\n            pop_heap(stones.begin(), stones.end());  // log n\r\n            stones.pop_back();\r\n            if (first != second){\r\n                // Note that the push_heap function assumes that the heap property is already satisfied for all elements except the last one.\r\n                stones.push_back(first - second);\r\n                push_heap(stones.begin(), stones.end()); // log n\r\n            }\r\n        }   // Total time ==> n * (log n + log n + log n) === O (n log n)\r\n        if (stones.size() == 1){\r\n            return stones[0];\r\n        }\r\n        else{\r\n            return 0;\r\n        }\r\n\r\n\r\n\r\n    }\r\n};', 'more understandable for me\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        stones = [-s for s in stones]\n        heapq.heapify(stones)\n \n        while len(stones) > 1:\n            first, second = heapq.heappop(stones), heapq.heappop(stones)\n\n            diff = - abs(first-second)\n            heapq.heappush(stones, diff)\n        \n        return abs(stones[0])', ""Thank you for sharing this solution.\nI am working on my clarity of code.\nHere are what I learned from your code.\n\n1. use a list initializer to store negative values.\n2. use heapq.heapify , O(N), instead of in a for loop to heapq.heappush, O(NlogN)\n3.  pop the items out first, then compare them to decide whether to push or not. I compare them first, which results in redundant code.\n4. last 2 lines are smart. append(0) in case the heap is empty.   It's okay for me to use` return 0 if not heap else abs(stone[0])` though."", 'My interview prep starts here !!! Thanks a lot :)']"
179,qB0zZpBJlh8,"['can any one explain the time complexity of it', 'A very excellent problem and explanation!', 'Your way of explanation awsome', 'This was asked in Zoho software developer role', 'Instead of concatenating to string, I appended them all to a list, and called list.reverse() 😅😅\np.s. Stop scrolling comments, and solve some probolems.', 'Amazing explanation but i cant think of why i cant solve it by myself', 'I solved this a different way in linear time by using two stacks; one of factors where the top of the stack is the last number for the characters and another stack containing the substrings. whenever a ] character is detected it pops the two from their respective stacks, multiplies them, then appends it to the next top of the characters stack.', 'every time he said ""IN PYTHON"", I was looking at my  Java code, it was like speaking to me: What? don\'t look at me like that, go and search on google.', 'Thank you so much sir for your great and clear explanation.\n\nHere the code in c++ :-\n\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string ans="""", substr="""", k;\n        int n=s.size();\n        stack<char> st;\n        for(int i=0; i<n; i++){\n            if(s[i]!=\']\'){\n                st.push(s[i]);\n            }\n            else{\n                substr="""";\n                while(st.top()!=\'[\'){\n                    substr = st.top() + substr;\n                    st.pop();\n                }\n                st.pop();\n                k="""";\n                while(!st.empty() && isdigit(st.top())){\n                    k = st.top() + k;\n                    st.pop();\n                }\n                for(int i=0; i<stoi(k); i++){\n                    for(int j=0; j<substr.size(); j++){\n                        st.push(substr[j]);\n                    }\n                }\n            }\n        }\n        while(!st.empty()){\n            ans = st.top() + ans;\n            st.pop();\n        }\n        return ans;\n    }\n};', 'One of the best solution availabe on YT. Great work sir. Huge fan of the way you break tough and/or complex problems into simpler versions!!😍😍']"
180,WnPLSRLSANE,"[""I've used a different approach. I got the maximum value in the list and sorted my list first then, I run the loop till (max val + 1) and checked whether i  != nums[nums[i]]. if that's not the case then i += 1and if we get if condition correct, then we return i which is the missing value \n\ntime - O(n)\nSpace - O(1)"", 'I used the Triangular number formula: ((n^2) + n) / 2, for calculating the total sum of the full range and then substracted the sum of the numbers in the given array. Ends up being O(n) for time and O(1) for space', 'same solution but I think a little less confusing, sum needs to be sum of [1,n] so just add 1 \n\ndef missingNumber(self, nums: List[int]) -> int:\r\n        res = 0\r\n\r\n        for i in range(len(nums)):\r\n            res += ((i + 1) - nums[i])\r\n        return res', 'I hate how sometime I just overthink 😤', 'Thank You for your work😍😍😍', ""I have solved this with the equation. BUT I am trying the codes at the end but that's giving me INCORRECT ANSWER. \nWhat am I missing here?\n\nNVM, Got it right finally while trying out with pen and paper! Thanks NeetCode"", 'class Solution:\r\n    def missingNumber(self, nums: List[int]) -> int:\r\n        f1 = sum(nums)\r\n        n = len(nums)\r\n        x = n*(n+1)/2\r\n        return int(x-f1)', 'interesting approaches', 'to be honest I did not understand why we initialize our res = len(nums) at the beginning?', 'because of you i am feeling addicted to these problems, now i am sure with some time and practice i will get in Big Tech']"
181,nKv2LnC_g6E,"['Thankyou again for all your videos and amazing explanation. This is the easiest explanation I ever saw to this problem!!', 'What a moronic fucking question to ask in an interview', ""whats wrong in this c++ code:\n    bool isRobotBounded(string instructions) {\n        \n        int dirX = 0, dirY = 1;\n        int x = 0, y = 0;\n\n        for(char ch: instructions){\n\n            if(ch == 'G'){\n                x = x + dirX;\n                y = y + dirY;\n            }\n            else if(ch == 'L'){\n                char temp = dirX;\n                dirX = -1 * dirY;\n                dirY = temp;\n            }\n            else{\n                char temp = dirX;\n                dirX = dirY;\n                dirY = -1 * temp;\n            }\n\n        }\n\n        return ((x == 0) && (y == 0)) || ((dirX != 0) && (dirY != 1));\n    }"", 'To think about which direction the robot is rotating, you can simply think about the 4 quadrant signs of quadrants I-IV learned in middle school algebra.', 'Watched thanks\nIdea is that if after applying the moves once, the robot is back at the origin then definitely stuck on a loop. If the robot is not at origin but the direction changed from the initial direction then the robot will be in a loop when we apply the instructions infinitely.\nWe return (x,y) == (0,0) || directionChanged after applying the instructions once', 'The solution using the inherent periodic nature by running the command string 4 times is cleaner and more intuitive.', '9:35 how did your application at freddie mac go? :p', 'For anyone having trouble with the direction thing : \nTake a vector (x,y) and note that the vector (-y,x) is perpendicular since their inner product is zero :  \n-xy+yx = 0.\nBut also (y,-x) is perpendicular since inner product is xy-yx=0. \n\nLeft rotation  means that your new vector points to the left and so its x coordinate decreases when walking to that direction and thus the - sign.', ""I wonder is there any way that makes a path spiral then what will be the case it will be return true by ur code because it will change direction but i don't think it is a circular"", 'Surprisingly it is failing when use this algo in Java on Leetcode for test case:""LLGRL""\n  public boolean isRobotBounded(String instructions) {\r\n    \tint x = 0;\r\n    \tint y =0;\r\n    \t\r\n    \tint dirX = 0;\r\n    \tint dirY = 1;\r\n    \t\r\n        for(int i =0;i< instructions.length(); i++) {\r\n        \tchar c = instructions.charAt(i);\r\n        \tif(c ==\'G\') {\r\n        \t\tx+=dirX;\r\n        \t\ty+=dirY;\r\n        \t} else if (c ==\'L\') {\r\n        \t\tint tmp = dirX;\r\n        \t\tdirX = -1*dirY;\r\n        \t\tdirY = tmp;\r\n        \t}else {\r\n        \t\tint tmp =dirX; \r\n        \t\tdirX = dirY;\r\n        \t\tdirY = -1*tmp;\r\n        \t}\r\n        }\r\n        \r\n        return ((x==0 && y ==0) || (dirX != 0 && dirY !=1));\r\n    }']"
182,A8NUOmlwOlM,"['is there a O(log(n)) time and O(1) space solution using binary search and working on the input list directly?', 'clever trick!', ""Wouldn't the space complexity be O(n^2) bc the result array is a List of Lists? Or does each list here only count as one element?"", ""I did the problem 'merge intervals' first so I kinda cheated on this one. I inserted the new interval into intervals, sorted intervals, and then reimplemented merge intervals. Beat 98% funnily enough.\nintervals.append(newInterval)\nintervals.sort()\n-- Reimplement merge intervals exactly --\ndone"", 'how to find if overlapping or not @5:00', 'You could do this and avoid returning twice\n\nres = []\ni, n =  0, len(intervals) \nwhile i < n:\n         if newInterval[1] < intervals[i][0]:\r\n                break\r\n         elif newInterval[0] > intervals[i][1]:\r\n                res.append(intervals[i])\r\n         else:\r\n                newInterval = [min(newInterval[0],intervals[i][0]),max(newInterval[1],intervals[i][1])]\r\n          i+=1   \nres.append(newInterval)\r\nreturn res + intervals[i:]', 'this problem needs a complex coding ability', ""Doesn't it append the newInterval to the end of the res? How is that working?"", ""You're the best !!!!"", 'Wow amazing way to code was stuck in this for long time best way to approach this problem!\nHere is my java code: \nclass Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n\n        int newS=newInterval[0];\n        int newE=newInterval[1];\n        ArrayList<ArrayList<Integer>> arr=new ArrayList<>();\n        int i=0;\n        for(i=0;i<intervals.length;i++){\n            if(newE<intervals[i][0]){\n                break;\n            }else if(newS>intervals[i][1]){\n                //add the given interval.\n                ArrayList<Integer> currA=new ArrayList<Integer>();\n                currA.add(intervals[i][0]);\n                currA.add(intervals[i][1]);\n                arr.add(currA);\n            }else{\n                //overlapping\n                newS=Math.min(newS,intervals[i][0]);\n                newE=Math.max(newE,intervals[i][1]);\n            }\n        }\n        //Inserted the required new intervals.\n        ArrayList<Integer> currA=new ArrayList<Integer>();\n        currA.add(newS);\n        currA.add(newE);\n        arr.add(currA);\n        //add all remaning interavls if exiits;\n        for(int j=i;j<intervals.length;j++){\n            ArrayList<Integer> currB=new ArrayList<Integer>();\n                currB.add(intervals[j][0]);\n                currB.add(intervals[j][1]);\n                arr.add(currB);\n        }\n        //conv to int[][].\n        int[][] ans=new int[arr.size()][2];\n        for(int m=0;m<arr.size();m++){\n            ans[m][0]=arr.get(m).get(0);\n            ans[m][1]=arr.get(m).get(1);\n        }\n        return ans;\n    }\n}']"
183,pGMsrvt0fpk,"['I think In for loop 4rth argument for range in unnecessary.', 'It took me a while to figure out that ""how many subproblems do we have"" - is really MxN and ""how many paths are from top-left to bottom-right"" is a different thing :D', ""I did a solution but suppose the walk can be FOUR-directional\nclass Solution:\n    def minPathSum(self, grid) -> int:\n        R,C = len(grid), len(grid[0])\n        queue = []\n        queue.append((R-1,C-1, grid[R-1][C-1]))\n\n        cache = [[float('inf')] * C for _ in range(R)]\n        cache[R-1][C-1] = grid[R-1][C-1]\n        while queue:\n            for _ in range(len(queue)):\n                i,j,cost = queue.pop(0)\n                if i-1 >= 0 and cost + grid[i-1][j] < cache[i-1][j]:\n                    cache[i-1][j] = cost + grid[i-1][j]\n                    queue.append((i-1,j,cost + grid[i-1][j]))\n                    \n                if i+1 < R and cost + grid[i+1][j] < cache[i+1][j]:\n                    cache[i+1][j] = cost + grid[i+1][j]\n                    queue.append((i+1,j,cost + grid[i+1][j]))\n                \n                if j-1 >= 0 and cost + grid[i][j-1] < cache[i][j-1]:\n                    cache[i][j-1] = cost + grid[i][j-1]\n                    queue.append((i,j-1,cost + grid[i][j-1]))\n                \n                if j+1 < C and cost + grid[i][j+1] < cache[i][j+1]:\n                    cache[i][j+1] = cost + grid[i][j+1]\n                    queue.append((i,j+1,cost + grid[i][j+1]))\n        return cache[0][0]"", 'I’ve thought this was a graph problem 😢😢', ""why can't we solve this problem with negative numbers?"", 'but bro the arguments in the min() is wrong right? it should be below and right of the element.', ""Hey Neet. It's tagged as an Amazon question in the github link,  just wonder where do you get the info that it's also a Google question?"", 'Hey NeetCode, with your drawing, I think the third line should be res[rows][cols -1] = 0, right?', ""it's also possible to do it in place"", 'thank you so much!']"
184,B1k_sxOSgv8,"['Dont know man i wrote this and it worked.\ndef encode(self, strs):\n        rs = \'\'""\n        for str in strs:\n            rs += str\n            rs += \':;\'\n        rs = rs[:-2]\n        return rs\ndef decode(self, str):\n\n        list = str.split(\':;\')\n        return list', ""im just wondering why we using # and an integer while encoding the string. Is it allowed? Maybe I'm sounding dumb rn but while reading the problem my understanding was that when we encode that string we cant add anything to it, if that makes sense. Thanks fam"", ""What if the string has a digit followed by the # sign? Forexample, 'six2#to'"", 'Who else thought that they can do it without ""#"" symbol? :)', ""Convert string size to byte array and put it into the encoded string, you don't need separator and you will use less space. But that also works!"", 'and how about if the word start with the same n# that you chose as delimiter?', 'what if 4# was a part of the given word', 'You have used two while loops, one inside of the other. That means the time complexity is: O(n^2)', ""what if an item contains # sign? for example strs = ['neet', 'co#de','solution'] -> I wrote a better solution for decode: \ndef decode(str):\r\n    decoded_list = []\r\n    # first iteration\r\n    output = []\r\n    start = 0\r\n    offset = 2\r\n    start = offset\r\n    split = int(str[0]) + offset\r\n    item = str[start:split]\r\n    output.append(item)\r\n    # end of first iteration\r\n\r\n    while True:\r\n        if len(str) == split:\r\n            break\r\n\r\n        start = split + offset\r\n        split = start + int(str[split]) \r\n        item = str[start:split]\r\n        output.append(item)\r\n    \r\n    return output"", 'Turing Machine Tapes Vibe']"
185,rSA3t6BDDwg,"['💡 BACKTRACKING PLAYLIST: https://www.youtube.com/watch?v=pfiQ_PS1g8E&list=PLot-Xpze53lf5C3HSjCnyFghlW0G1HHXo', 'Very well worded, thanks. This skip all ones trick is a difference between TLE and accepted.', 'For those looking for a solution that is still python, but commented with easy to grasp rationale:\n\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates.sort()\n        combos = []\n        combo = []\n        \n        def backtrack(i=0, localSum=0):\n            # Base cases\n            if localSum == target:\n                combos.append(combo.copy())\n                return\n            if i == len(candidates) or localSum > target:\n                return\n            \n            # Spawn decision tree for choosing current index.\n            # Reset the decision after (pop)\n            combo.append(candidates[i])\n            backtrack(i+1, localSum + candidates[i])\n            combo.pop()\n            \n            # Advance index to the next non-equal digit to avoid duplicates,\n            # then spawn a tree with the null decisiong (same target).\n            while i+1 < len(candidates) and candidates[i+1] == candidates[i]:\n                i = i + 1\n            backtrack(i+1, localSum)\n        \n        backtrack()\n        return combos', ""im pretty sure the code is different from the decision tree he showed lol. The decision tree he showed is a binary tree but his code isn't."", ""If you continue to extend the tree you made in your drawing explanation, won't you find duplicates?"", 'I solved it using the patterns of both Combination Sum and Subsets II \n\nclass Solution {\r\n    public void dfs(int i, List<Integer> combination, List<List<Integer>> combinations, int[] candidates, int sum, int target) {\r\n        if (sum == target) {\r\n            combinations.add(new ArrayList<>(combination));\r\n            return;\r\n        }\r\n        if (sum > target || i >= candidates.length) \r\n            return;\r\n\r\n        combination.add(candidates[i]);\r\n        dfs(i + 1, combination, combinations, candidates, sum + candidates[i], target);\r\n\r\n        combination.remove(combination.size() - 1);\r\n        while (i + 1 < candidates.length && candidates[i + 1] == candidates[i]) i++;\r\n        dfs(i + 1, combination, combinations, candidates, sum, target);\r\n    } \r\n    \r\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\r\n       List<List<Integer>> combinations = new ArrayList<>();\r\n       Arrays.sort(candidates);\r\n\r\n       dfs(0, new ArrayList<>(), combinations, candidates, 0, target);\r\n\r\n       return combinations; \r\n    }\r\n}', 'God Im so terrible at this rip', 'can be solved just by adding one condition in combination sum I problem --\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n\n\n        res = []\n        candidates.sort()\n\n        def dfs(i, cur, total):\n\n            if total == target:\n                res.append(cur.copy())\n                return\n\n            if i >= len(candidates) or total > target:\n                return\n\n            cur.append(candidates[i])\n\n            dfs(i+1, cur, total+candidates[i])\n\n            cur.pop()\n\n            #to avoid duplicate\n            while (i+1 < len(candidates) and candidates[i] == candidates[i+1]):\n                i = i+1\n\n            dfs(i+1, cur, total)\n\n        dfs(0, [], 0)\n        return res', ""Thanks a lot for the video. I love it. I just got a question: isn't the tree to illustrate your code should be like, first level: [], second-level [1] [1] [2]...[7][10], and then, the children of first left child of second-level be [1][2]...[7][10] ? Note that the for loop starts with all the elements in the range, instead of a take or not take binary tree."", 'If there were two options at every spot, why is there just one backtrack function in the code and not two ? In the final code, it seems like the only backtrack function used will skip over similar values but I do not see the one that should use the same values ?']"
186,BHr381Guz3Y,"['could you proove that this algorithm give the solution ?', 'simply:  if k > len(nums):\n                   k = k%len(nums)\n               nums[:] = nums[len(nums)-k:] + nums[:len(nums)-k]', ""Its kind of suprising to me, that this problem is set as medium difficulty. I thought it was pretty simple. Honestly, I've seen wuite a few easy problems that were more complex."", 'for space O(n), the shifting formula is, ans[i] = nums[(i + size - k)%size];', '#TC : O(n), space:O(1) inplace\r\ndef rotate(nums, k):\r\n    k %= len(nums)\r\n    # nums[-k:] = [5, 6, 7]\r\n    # nums[:-k] = [1, 2, 3, 4]\r\n    nums[:] = nums[-k:] + nums[:-k]\r\n\r\nnums,k = [1, 2, 3, 4, 5, 6, 7],3\r\nrotate(nums, k)\r\nprint(nums)  # Output: [5, 6, 7, 1, 2, 3, 4]', ""can't we solve this using two pointers?"", 'Thanks you, I was stuck trying to do the O(1) solution. Great explanation!', 'IMPRESSIVE', 'what changes do we need to make if we want to rotate the array left side the same way', 'hey! this was a really heplful vedio but how did you figure out you have to mod it I mean the math part to solve the out of bounds part. I cant  figure how to do this stuff while solving . it will be very helpful if you replied.']"
187,3THUt0vAFLU,"['Note to myself: Even if it is weird but one can have two hashsets, one in left and other in right. Now it can be anything set, list, linkedlist, BST anything', 'Nice explanation', 'Note to self: Can have a hashmap on both sides (left / right)', 'Instead of checking all the 26 characters,  you can check all the characters in the left whether they are in the right.. but in worst case, it is going to 26*n', 'O(N + (char set size)* logN) solution with unordered_map<char, vector<int>> m and binary search for index.', 'Another optimization: once res.size() == (char set size)^2, return.', 'Dont need to check all 26 characters as we need to match with right at the end. So better to check left only.\n        res = set()\n        left = set()\n        right = Counter(s)\n\n        for mid in range(len(s)):\n            right[s[mid]]-=1\n            if right[s[mid]] == 0:\n                right.pop(s[mid])\n            \n            for c in left:\n                if c in right:\n                    res.add(c+s[mid]+c)\n            \n            left.add(s[mid])\n        \n        return len(res)', 'It appears easier to use hash map c->list[firstindex, lastindex] since any char in between forms a parlendrome. This method also O(n*26)and passed all tests.', ""Hi, NeetCode. People only see how good you are at speaking and how you can solve problems, but they don't know how much effort you put in behind. Could you talk about how you learned such knowledge and how you learned to speak out such knowledge?"", 'Idea: We can generate all unique palindromes of length 3 (26*26 of them, as first and last character must be the same) and binary search in s for respective positions of each unique combination (preprocess in O(N), process O(A^2 * log(N)) - A being the alphabet size']"
188,UcoN6UjAI64,"['so complicated...', ""why won't left shifting the one work"", 'My Solution:\n\ndef reverseBits(self, n: int) -> int:\r\n        res = 0\r\n        \r\n        for i in range(32):\r\n            res = res << 1\r\n            res = res | (n & 1)\r\n            n = n >> 1\r\n        \r\n        return res', ""So, if we want to shift the 1 value to the left and perform AND with n , we should do this line right?   (but this one doesn't work, produces wrong result. Why might that be? ) \n\nbit = (1 << i) & n"", 'this is the best explanation. Thanks.', 'stop blabbering dude...', '8:33', '# Alternate solution to this:\ndef rev_bits(n):\n    \n    res = 0\n    \n    for i in range(32):\n    \n        res = res << 1\n\n        res = (n & 1) | res\n\n        n = n >> 1\n        \n    return bin(res)\n\nrev_bits (0b00000000000000000000000000010111)', ""Despite the input being specified to always be 32 bits long, wouldn't the solution's time complexity be O(n) and not O(1)?\n\nA O(1) solution would have the same worst-case performance independent of the size of n. Meanwhile, this solution would scale with the size of n, making it linear."", 'You can get another O(1) solution (simpler to understand for me) by going through n from the first digit to the last, and multiplying it by the powers of 2 starting at 2^31\n\n    def reverseBits(self, n: int) -> int:\r\n        res = 0\r\n        for i in range(31, -1, -1):\r\n            if n % 2 == 1:\r\n                res += pow(2, i)\r\n            n >>= 1\r\n        return res']"
189,1vZswirL8Y8,"['Leetcode be like: ""There\'s a reason why u were taught these in elementary school. How dare you forget these"" :)', 'First condition is wrong', ""if we are not allowed to use typecasting or inbuilt function then the following solution is more good: \ndict_num = {'0': 0,\n            '1': 1,\n            '2': 2,\n            '3': 3,\n            '4': 4,\n            '5': 5,\n            '6': 6,\n            '7': 7,\n            '8': 8,\n            '9': 9}\n        flag1,flag2=1,1\n        if s1[0]=='-':\n            s1 = s1[1:]\n            flag1=-1\n        if s2[0]=='-':\n            s2 = s2[1:]\n            flag2=-1\n        num1,num2 = 0,0\n       \n        for i in s1:\n            num1= num1*10 + dict_num[i]\n        for i in s2:\n            num2 = num2*10 + dict_num[i]\n        \n        return num1*num2*flag1*flag2"", ""why didn't we used ->  return int(s1)*int(s2) instead???"", ""I thought the point of this question was to implement Karatsuba's or some other purely typographical algorithm. However, doing something like that would require you to implement addition and maybe subtraction too which I am too lazy to do."", ""if u dont wanna use int function\n\nuse \n\ndigit = Mmap[num1[i1]] * Mmap[(num2[i2])]\n\nwhere Mmap mapes every char 1-9 to it's corresponding integer."", 'I think you are better off using a dict mapping strings to ints for each digit 0-9 and then multiplying by 1*10^n for obtaining an int. multiply the 2. then use % 10 and / 10 to extract each digit and then return the string (reversed)\n\ncode in python3:\ndef multiply(self, num1: str, num2: str) -> str:\r\n        if num1 == ""0"" or num2 == ""0"":\r\n            return ""0""\r\n        out = """"\r\n        int1, int2 = 0, 0\r\n        intmult = 1\r\n        digits = {""0"": 0, ""1"": 1, ""2"": 2, ""3"": 3, ""4"": 4, ""5"": 5, ""6"": 6, ""7"": 7, ""8"": 8, ""9"": 9}\r\n        for i in range(len(num1) - 1, -1, -1):\r\n            # back to front\r\n            int1 += intmult*digits[num1[i]]\r\n            intmult *= 10\r\n        intmult = 1\r\n        for i in range(len(num2) - 1, -1, -1):\r\n            # back to front\r\n            int2 += intmult*digits[num2[i]]\r\n            intmult *= 10\r\n        intout = int1 * int2\r\n        while intout > 0:\r\n            out += str(intout % 10)\r\n            intout //= 10        \r\n        return out[::-1]', 'what is the complexity of this?', 'I dont think you can use type casting to int, you have to use a dict to map strings to integers. Otherwise you could have a one line solution:\n\nreturn str(int(num1) * int(num2))', 'Here is a much cleaner solution i just came up with:\n\ndef multiply(self, num1: str, num2: str) -> str:\r\n        res = 0\r\n        num1 = num1[::-1]\r\n        num2 = num2[::-1]\r\n        for i in range(len(num1)):\r\n            for j in range(len(num2)):\r\n                res += (int(num1[i]) * 10**i) * (int(num2[j]) * 10**j)\r\n        return str(res)']"
190,6aEyTjOwlJU,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'Usually you get ir right and explain it perfectly, but this one is very difficult to understand what is going on even when visualizing it', 'Just a small correction in the DFS approach you are implementing Memoization but not using it under base conditions in DFS, you should                       if i in memo:\n                return memo[i]', 'Thanks for the explanation! I just have one question: why did you start from the end of string and not from the beginning?', 'nothing annoys me most when i cant code my solution...', ""Can someone explain to me what he meant by cache and what it mean specifically in the context of this solution? I'm really stupid sorry couldn't follow the rest of the vid once he introduced the term at 8:19?"", 'this one is confusing', '3:53 oneworatwoadjkfsqer', 'Why is base case {len(s):1} ???? when """""" is zero?', 'Doesn\'t work for ""06"".']"
191,nIVW4P8b1VA,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'Is the EQUAL SIGN in ""(nums[l] >= nums[m])"" ONLY for the case of an input like [2,1] where l=0, m=(0+1)//2 = 0 but we randomly need to check the other index value too ""just because"" (outside of our actual defined rules we\'ve outlined)... just to make sure?', 'I have a simpler alternative that allows you to not keep track of the minimum, here it is:\n\nclass Solution:\r\n    def findMin(self, nums: List[int]) -> int:        \r\n        start, end = 0, len(nums) - 1\r\n        while start - end > 1: # if middle exists \r\n            mid = (start + end) // 2\r\n\r\n            if nums[mid] > nums[end]:\r\n                start = mid + 1\r\n            else:\r\n                end = mid\r\n        return min(nums[start], nums[end])', 'The most effective I suppose would be:\nconst foo = nums => {\r\n    // [4,5,6,7,0,1,2,3]\r\n\r\n    let [l, r] = [0, nums.length - 1]\r\n    while (l < r) {\r\n        let m = Math.floor((l+r) / 2)\r\n        if (nums[m] >= nums[r]) l = m + 1;\r\n        else r = m;\r\n    }\r\n\r\n    return nums[l];\r\n}', 'My solution:\n\n    def findMin(self, nums: List[int]) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l < r:\n            m = (l + r) // 2\n\n            if nums[m] < nums[r]:\n                r = m\n            else:\n                l = m + 1\n\n        return nums[l]', ""My gawd, every one of these binary search problems I get some edge cases wrong due to these tiny but important details of settings r = m (instead of m - 1) or having l start from 1 instead of 0 (koko eating bananas). It's super frustrating"", ""Is it safe to assume that if a search requires O(log n) time and the list is ordered. It's most likely a binary search in some flavor or another?"", 'You state the rules:\n\n""If our middle pointer happens to be in the right sorted portion, then we want to search to the left; **if our middle is in the left sorted portion we want to search to the right**"". \n\nAnd later state:\n\n""If we ever got to a portion of the array that\'s completely sorted we would just **take the leftmost value and see if it\'s smaller than the current result and stop our binary search.**""\n\nThis statement completely conflicts with the algorithm of focus, which says **if the leftmost value is smaller we search to the right**.  So do we search to the left or ""stop our binary search""?\n\nSo are there two algorithms rules at play here or what?  I\'m guessing yes, but you said an entirely conflicting rule pretty flippantly without clarifying this is an important rule caveat and consideration.', '2:29\n3:18\n8:05', 'My problem with these videos is he assumes we all arrive at the same intuition and do it quickly. For example the part where he casually starts talking about pivoting inside an array might not be an observation that a lot of people are able to make instantly. From there the rest of the video is a crapshoot.']"
192,mBNrRy2_hVs,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'I think  you talk too much bullshit.', 'you are the best teacher', 'I feel so stupid watching these videos.', 'Thank you neetcode', 'Love it~', 'Another category that might be helpful here is probably matrix/maze problems', 'From your Dynamic Programming Patterns sheet, I think Fibonacci Number is kind of Linear DP problem whereas House Robber is more of a Decision Making kind of problem so they should not be falling in the same bucket in case you are categorizing them. Any thoughts?', 'very good video! thanks so much.', 'Thanks!']"
193,TjFXEUCMqI8,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'I didnt get the integer division square', 'The operations of a HashSet are not O(1), they are O(n). A HashMap has a bound of O(1)', 'This is incredible', 'boolean arrays instead of set would be much efficient\n        boolean[][] squares = new boolean[9][9]; \n        squares[i / 3 * 3 + j / 3][c]', 'the (row, col):set() default dictionary is insane', 'such an elegant solution. makes it so easy!', ""Naaaaaahhh I'm here to say it NeetCode is all time top 1 teacher when it comes to explaining and solving algorithm and data structure problems. My guy is HIM!!!"", ""I did it exactly the same way but I opted for just using 1 hashmap where the key was the number and the value  was a tuple of (row, column, box number), then at every value I can just look up if it exists in the hashmap and compare each value in the tuple. I can't tell which solution would be better in terms of time complexity though since I would have to iterate all 3 values of my tuple after the constant lookup."", 'great solution']"
194,6QQRayzOTD4,"[""Hey Guys just a quick question. So we don't have to wait for the monster to come to us we can go wherever they are and if our weapon is charged we can eliminate this? I thouth we are at a point waiting for the monster to come to us one by one. so I faild some test cases on leetcode. I think we can go to the monster and eliminate them so  for this example [4,2,3] [2,1,1] we can fist go to the first monster eliminate it. we have two min before the second monster reaches the city, now after one minute we can eliminate the second one. and then we have 2 min before the 3rd monster reaches so we can eliminate them all. Am I right?"", 'O(n)  approach !!\n\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) \r\n    {\r\n        int n=dist.size();\r\n        int fre[100001]={0};\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            int t=(dist[i]/speed[i])+(dist[i]%speed[i]!=0);\r\n            fre[t]++;\r\n        }\r\n        int i;\r\n        for(i=1;i<n;i++)\r\n        {\r\n            fre[i]+=fre[i-1];\r\n            if(fre[i]>i)\r\n                break;\r\n            if(fre[i]==n)\r\n                break;\r\n        }\r\n        return i<n?i:n;\r\n    }', 'How many solved today', 'Contest is ongoing..', 'Chill out the contest is still running', ""the contest hasn't ended it's 5 more mins lol""]"
195,-w67-4tnH5U,"['💡 DP PLAYLIST: https://www.youtube.com/watch?v=73r3KWiEvyk&list=PLot-Xpze53lcvx_tjrr_m2lgD2NsRHlNO&index=1', 'wow. just wow', 'Would you consider this problem under 0/1 knapsack pattern?', 'I solved this in codechef', 'Best Explanation I have ever come across. Subscribed.', 'Brilliant as always!', ""Hey man, first of all, thank you very much for making these! I just wanted to ask why is this algorithm correct? I can't wrap my brain around it"", ""Hey dude. you explain things nicely. Let's do leetcode 2158 too if possible. Thanks"", '// Javascript, accepted solution\n\nfunction minCost(costs) {\n    let preRow = costs[0];\n    for(let h = 1; h < costs.length; h++) {\n        let currRow = [];\n        const l = costs[0].length;\n        for (let c = 0; c < l; c++) {\n            currRow[c] = costs[h][c] + Math.min(preRow[(c+1)%l], preRow[(c+2)%l]);\n        }\n        preRow = currRow;\n    }\n    return Math.min(...preRow);\n}', 'thanks']"
196,rI2EBUEMfTk,"[""Can you explain how heapify is O(n)? To build a binary heap, don't you need to call heap reorder n times making it O(nlog(n))?"", ""How did python automatically use min heap? Didn't you say in another video that Python only supports max heap, and to use min heap we have to use the negative values?"", '5:31 why did you re-draw the circle', ""I don't understand the running time of this. Adding an element to a heap is O(log N). Doing this for N elements is O(N log N). Popping from the Heap K times is O (K log N). Since K < N, the total running time should be O(N long N)"", 'Hey can we just use lambda function to store the key value than sort it and then just remove elements after bigger then k\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\r\n        points.sort(key = lambda x: x[0]**2 + x[1]**2)\r\n        return points[:k]', 'Quick Select with Random Selects, O(N) average time. I chose quick select here because all data was present (no stream) and we are not performing any transformative operations on the actual inputs (as in last stone weight).  \n\n""""""\nWe have points Xi, Yi, and an integer k. \nWe want the K-closest points to the origin. \n\nWe could use a heap to solve this problem in O(NLogN) (heapify plus popping...)\n\nHowever a better solution will be to use quick select which gets an average case runtime of O(N) time! \nThe closests points will have smallest euclidean distances ... \n\n""""""\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        def partition(l,r):\n            \n            #choose a random pivot \n            pivot = random.randint(l,r)\n            pivot_distance = euclidean_distance(points[pivot])\n            \n            #move pivot to end \n            points[pivot], points[r] = points[r], points[pivot]\n            \n            #store idx for swapping \n            store_idx = l \n            \n            for i in range(l,r):\n                if euclidean_distance(points[i]) < pivot_distance: \n                    points[i], points[store_idx] = points[store_idx], points[i]\n                    store_idx += 1 \n            \n            #switch store_idx with pivot\n            points[r], points[store_idx] = points[store_idx], points[r] \n            return store_idx \n        \n        \n        def quick_select(points,k):\n            \n            left, right = 0, len(points)-1 \n            pivot_idx = len(points) \n            \n            #continue parititoning while pivot != k \n            while pivot_idx != k:\n                pivot_idx = partition(left, right)\n                \n                #k smallest lie to the left \n                if pivot_idx > k: \n                    right = pivot_idx - 1 \n                \n                #the k smallseet lie to the right & to the left of pivot_idx all values smaller, so left = pivot_idx \n                else: \n                    left = pivot_idx \n                    \n            #return k closest points \n            return points[:k]\n        \n        def euclidean_distance(point):\n            x,y = point\n            return math.sqrt(x**2+y**2)\n        \n        #perform quick select and return k smallest \n        return quick_select(points, k)', 'I just realize you sound like daily dose of internet', 'If we replace the append heap line with heappush and remove the heapify completely, time complexity for that for loop will be O(nlogn) i.e n times heappop is nlogn. Right?\n\nSo this following logic this worse than appending and heapify, right? Kinda counter-intuitive!\n\nheap = []\r\n        # for loop is n time logn\r\n        for p in points:\r\n            x,y = p\r\n            d = x**2 + y**2\r\n            heappush(heap,[d,x,y])\r\n        res = []\r\n        # k time logn\r\n        while k:\r\n            d,x,y = heappop(heap)\r\n            res.append([x,y])\r\n            k-=1\r\n        return res', 'such a bizarre problem. they might as well just give you an array of ints and ask you to heap sort it', 'Got the N*log(K) solution. But remember not to apply leetcode style programming in real life, especially not in python. Exploit numpy parallelism/vectorization instead of using sequential loops:\n\n        points = np.array(points)\n        dists = np.linalg.norm(points, axis=1)\n        k_indices = np.argpartition(dists, k-1)[:k]\n        return points[k_indices].tolist()\n\nFaster than 95% of leetcode solutions, although with huge variance since their timing system is broken.']"
197,S5bfdUTrKLM,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'intelligent', 'Your explanation of the fast pointer was misplaced by one I believe. On first iteration, slow pointer is the 2nd element, fast is the 3rd. Fast then moves to the 6th, which would be one beyond the last, not the last. slow would be the 3rd element.', 'Great explanation. Thanks for also mentioning the array approach to solving this problem.', 'If it helps you to better visualize this problem, instead of fast and slow pointer you can just count all the elements first, than iterate until the size/2 or size/2+1 th element (depends if the size is even or odd).', 'If we used recursion, would it still count as extra memory?', 'My initial O(n) space/time solution was 1/ push all nodes onto a stack 2/ if the stack size is even divide by 2 and add 1, else if the stack size is odd divide by 2 and take the ceiling and store this as the ""stackStopSize"" (you will pop from the stack while the stack is greater than this size in step 3)  3/ once you have those value run the following while loop and after termination make sure to update the new top stack node\'s next node to nullptr\n\nwhile (nodeStack.size() > stackStopSize)\n        {\n\n\n            temp = curr->next;\n            curr->next = nodeStack.top();\n            nodeStack.top()->next = temp;\n            nodeStack.pop();\n\n            curr = temp;\n\n        }\n\n        nodeStack.top()->next = nullptr;\n\nThe intuition is for an even list [1, 2, 3, 4, 5, 6] the median positions of the list are [3,4] and for an odd list [1, 2, 3, 4, 5, 6, 7] the median position of the list is [4]. And to find a match for a value on the right of the median position(s), it must go into a slot to the left of the median position(s). So we calculate how many nodes are on the right of the median position, and stop popping once we hit the median position.', 'I like this problem. A good one to refresh easy subproblems for linked list. \nAlso, as usual - great explanation!🔥', 'Where are subtitles?', ""The key to understand this problem is to identify it’s a merging problem, basically the desired sorting can be achieved by splitting the linked list into 2 halves, reverse the second half then merge it in the first half.\nWouldn't want to be asked this in an interview tbh :D""]"
198,OVgPAJIyX6o,"['Alien Dictionary (HARD) - https://youtu.be/6kTZYvNNyps', 'I did this in Go, turns out not using a hashmap is faster because the order string is just 26 bytes lol', ""bro, i think you put this problem in the wrong category on your website. don't think it belongs in the graphs section!"", 'How this is a graph problem?', 'Best Explanation possible.', 'a little tricky thing is this solution does not use minLen of w1 and w2. But that is an excellent trick to solve the pre-work.', 'Bro this solution just perfect !!!', 'thanks', 'Awesome explanation', 'class Solution:\n    def isAlienSorted(self, words, order: str) -> bool:\n\n        order_list = {order[i]: i for i in range(len(order))}\n\n        def helper(word1, word2):\n            # check if word1 is lexicographically smaller than word2\n \n\n            for i in range(min(len(word1), len(word2))):\n                if order_list[word1[i]] < order_list[word2[i]]:\n                    return True\n                elif order_list[word1[i]] > order_list[word2[i]]:\n                    return False\n            # if same prefix, check length\n            return True if len(word1) < len(word2) else False\n        for i in range(len(words)-1):\n            # if same word , continue\n            if words[i] == words[i+1]:\n                continue\n            if not helper(words[i], words[i+1]):\n                return False\n\n        return True']"
199,TsA4vbtfCvo,"['Using Prefix Sum array:\n\nclass Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        forwardPrefixSum = [None] * len(cardPoints)\n        backwardPrefixSum = [None] * len(cardPoints)\n\n        summ = 0\n        for i in range(len(cardPoints)):\n            summ += cardPoints[i]\n            forwardPrefixSum[i] = summ\n        \n        reversedCardPoints = cardPoints[::-1]\n        summ = 0\n        for i in range(len(cardPoints)):\n            summ += reversedCardPoints[i]\n            backwardPrefixSum[i] = summ\n        \n        maxx = max(forwardPrefixSum[k-1], backwardPrefixSum[k-1])\n        for i in range(1, k):\n            temp = k - i\n            t1 = forwardPrefixSum[i-1]\n            t2 = backwardPrefixSum[temp-1]\n            print(t1, end="" "")\n            print(t2)\n            summ = t1 + t2\n            maxx = max(maxx, summ)\n        \n        return maxx', 'Who and all directly jumped into recursive solution(there were decisions to take either left or right) like me??', 'Which is the other most frequently asked google question?', 'a very beautiful solution', 'thank you!', 'Your explainations are so good...Thanks...', 'my easy solution to this question. \ninitially i just consider first k integers from left. \nand then start deleting on element from left and adding one element to right side sum. \nand just check which is max sum.. \n\njava code below. \n\nclass Solution {\r\n    public int maxScore(int[] cardPoints, int k) {\r\n        \r\n        int len=cardPoints.length;\r\n        int sum=findsum(cardPoints,k);\r\n        int maxSum=Math.max(0,sum);\r\n        \r\n        for(int i=1;i<=k;i++){\r\n            int left=k-i;\r\n            int right=len-i;\r\n            sum-=cardPoints[left];\r\n            sum+=cardPoints[right];\r\n            maxSum=Math.max(maxSum,sum);\r\n        }\r\n        return maxSum;\r\n    }\r\n    public int findsum(int[] cardPoints,int k){\r\n        int sum=0;\r\n        for(int i=0;i<k;i++){\r\n            sum+=cardPoints[i];\r\n        }\r\n        return sum;\r\n    }\r\n}', 'The explanantion was detailed and clear. Amazing!! Thank you!', 'i thought of recursion', 'This solution does use extra k space but I feel its more intuitive  \n\nclass Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        left_card_sum = [0]*(k+1)\n        right_card_sum = [0]*(k+1)\n        max_score = 0\n        _sum_so_far = 0\n        for i in range(1,k+1):\n            _sum_so_far += cardPoints[i-1]\n            left_card_sum[i] = _sum_so_far\n        _sum_so_far = 0\n        for i in range(1,k+1):\n            _sum_so_far += cardPoints[len(cardPoints) - i]\n            right_card_sum[i] = _sum_so_far\n        for i in range(len(right_card_sum)):\n            max_score = max(max_score,left_card_sum[i]+right_card_sum[len(right_card_sum)-1-i])\n        return max_score']"
200,7cp5imvDzl4,"['🌲 TREE PLAYLIST: https://www.youtube.com/watch?v=OnSn2XEQ4MY&list=PLot-Xpze53ldg4pN6PfzoJY7KsKcxF1jg&index=2', 'Can be done easily with BFS as well. There is also no rule against updating the node values, so I used BFS and every time I added a new node to the queue I updated that nodes value if it was < root->val', 'So simple and easy the way you did it! I was using a Set and adding each good node to my set, but counting good node is so much easier the way you did it. Thanks for the vid as always!', 'I did the same, but I used extraspace. Used a array to store the path and update count only if the last element of the array is the max element. It pretty much runs the same!\nclass Solution:\r\n    def goodNodes(self, root: TreeNode) -> int:\n        count = 0\n\n        def dfs(root,res):\r\n            nonlocal count\r\n            if not root: return res\r\n            res.append(root.val)\r\n            if max(res) == res[-1]: count += 1\r\n            dfs(root.left,res)\r\n            dfs(root.right,res)\r\n            res.pop()\r\n            return res\r\n        \r\n        dfs(root,[])\r\n        return count', 'RecursionError: maximum recursion depth exceeded in comparison', 'The another one problem I could come up with myself. But as always I watch your videos to find more smart solution', ""I always feel like if you use nonlocal in helper functions, it'll make your life a ton easier...\n\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        cnt=0\n        def helper(root,max_val):\n            nonlocal cnt\n            if not root:\n                return\n            max_val=max(max_val,root.val)\n            if root.val>=max_val:\n                cnt+=1\n            helper(root.left,max_val)\n            helper(root.right,max_val)\n\n        helper(root,root.val)\n        return cnt"", 'Hi, NeetCode, Just curious, was your website created by using html, css and js, or you created by using website builder? If you build it by using html etc, how long will it take you to finish this? thank you', 'wow i am speechless, crazy ! You a god!', 'I think this question should be labeled as ""Easy"" instead of ""Medium"" .']"
201,fei4bJQdBUQ,"['you are great sir', '(0 -> 1): -1\n(0 -> 0): 0\n(1 -> 1): 1\n(1 -> 0): 2\n1st loop:\n    if board[nei_row][nei_col] > 0: count += 1 (loop all valid direction)\n    if board[row][col] == 1 and (count < 2 or count > 3): board[row][col] = 2\r\n    elif board[row][col] == 0 and count == 3: board[row][col] = -1\n2nd loop:\n    if board[row][col] == 2: board[row][col] = 0\r\n    elif board[row][col] == -1: board[row][col] = 1', 'Would using something like 5,6,7,8 as the mapping would make it a bit easier to understand and explain to the interviewer?', ""I had no idea you were supposed to use the original numbers, I thought you were supposed to do something insane like try to update the value, it's neighbors recursively.. which wouldn't make any sense"", 'Like it is shown in the video, we can go ahead with the mapping:\n0: 0,0\n1: 1,0\n2: 0,1\n3: 1,1\n\nBut one neat trick to check neighbouring initial alive cells, is we can just take whatever value we have and do \'%2\'. say, a visited cell would have been ""1"" when its updated cell value%2==1. (From above mapping, 1 and 3 would get ""1"" on ""%2""). For an unvisited cell, the initial alive value would be 1 which also when you do ""%1"" you get 1.\n\nOnce we populate the array with new values, just do integer ""/2"" on all the values and you will get correct final states.', 'No.1 leetcode tutorial! someone who actually can explain the problem and solution very clearly. Good job and keep up good work', 'Maybe I am stupid, but I was having more problem writing the logic for the countNeighbours than the core logic required to solve this problem.', 'I did it for PCPC exam at UniSa', ""Really nicely explained man but why not simply map as follows:\n0|0->2\n1|0->3\n0|1->4\n1|1->5\nSo while checking if cell=0 OR 2 OR 4 , it means it's a dead cell cuz 2,4 were originally 0 i.e, dead AND\nIf cell=1 OR 3 OR 5 , it means it's a live cell cuz 3,5 were originally 1 i.e, live\n\nAND at end when we have updated each cell , if cell=2 OR 3 make it 0 cuz 2,3 are new 0s AND if cell=4,5 make it 1 cuz 4,5 are new 1s."", 'Sorry to hear you got covid. Hope you get better soon. btw this video is not there in your master list of coding solutions playlist.']"
202,4v42XOuU1XA,"['💡 DYNAMIC PROGRAMMING PLAYLIST: https://www.youtube.com/watch?v=73r3KWiEvyk&list=PLot-Xpze53lcvx_tjrr_m2lgD2NsRHlNO&index=1', 'Why do we need a tmpeven and tmpodd variable? And why it has to be reversed?', 'Learning with you has always been fun and exciting to me . Thanks a lot   and please keep going . You are helping lot of people', 'when you added -5 , how the path is a subsequence, its subset', 'The bottom up DP solution I believe doesn’t need to be reversed. In fact it seems it’s marginally faster actually if you don’t do that', '@NeetCode you explain it easier and more clear than top rated solutions at Leetcode!', 'Nice. There is even an easier solution. In every iteration we need to compare three things (there are three candidates for max sum):\n1. Previous max sum\n2. Number at the current index\n3. Previous max sum + current number - previous number. That is, if we want to add a new number in our subsequence, we have to add the previous number as well to keep the current number at an even position. Otherwise, it will be subtracted from the alternating sum.\n\nThe pseudocode of this algorithm is given below:\n\nsum = nums[0];\nfor (i = 0; i < nums.length; i++)\n       sum = max(sum, nums[i], sum - nums[i - 1] + nums[i]);\nreturn sum;', 'can anyone please tell me , how the dp solution is O(N) time ...\nAccording to me it should be O(N^2) as we are generating all the subsequences🙄😕', 'Instead of computing maimum with labels, i compute maximum and minimum with label ""even""\nclass Solution:\r\n    def maxAlternatingSum(self, nums: List[int]) -> int:\r\n        prior_max = 0\r\n        prior_min = 0\r\n        for n in nums:\r\n            temp = prior_max\r\n            if (prior_max < n - prior_min):\r\n                prior_max = n - prior_min\r\n            if (prior_min > n - temp):\r\n                prior_min = n - temp\r\n        return prior_max', ""I think returning sumEven works only b'coz nums are positive integers. Correct me if I am wrong\n\nIf someone is confused, like I was ;), about:\n    tmpEven = max(sumOdd + nums[i], sumEven)\n\nThink of it this way :\ntmpEven should always reflect the max subsequence if the index ending at that element is even.\nAnd what options do we have if nums[i] is the last even index:\n* Either add it to the subsequence ---> sumOdd + nums[i]\n* Skip including it coz the odd indexed num is too big with a -ve sign ---> sumEven\n\nHence tmpEven = max(sumOdd + nums[i], sumEven)""]"
203,h9iTnkgv05E,"['💡 GRAPH PLAYLIST: https://www.youtube.com/watch?v=EgI5nU9etnU&list=PLot-Xpze53ldBT_7QA8NVot219jFNr_GI', 'Thank you so much for your thorough and clear explanation! May I please request that you include space complexity analysis for this and future videos? Thanks!', 'I believe the overall runtime bound of O(nm^2) should be correct since while it possible to have O(n^2) edges in a graph, in this problem, the maximum is bounded by O(260n).\n\nThis is because the words are at most length 10. In order for any one word to have an edge to another word, the other word must vary in only one of the 10 positions. But since all words in the wordlist are unique, there are only at most 26 (due to 26 letters) words that are the same as each other after changing one letter (i.e. for a pattern xyz*abc, only 26 variations exist). So each word has at most 26*10 other words it is connected to. \n\nPlz lemme know if I missed something', '13:50 ???', ""Just posted a O(m*n log n) solution (m=word length, n=list size). Would be suprised if nobody else has come up with the same approach, but I can't find anything. Forget brute forcing all letters of the alphabet or walking the list more than 'm' times :)"", 'A more precise upper bound on the max number of edges in a graph of n nodes is n(n-1)/2', 'Why not DP?', 'After Listening BFS , my brain cells starting working again !', 'can someone explain the space complexity of the adjacency list?', 'number of edges can be upper bounded by 25*m*n: \nin each word(n), and for each character in this word(m), 25 other words can be generated by changing this character.']"
204,Ber2pi2C0j0,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'why recalculate row?', 'Can anyone explain how ""if not(top < = bot): return False"" immediately returns True if the target value is not in the matrix?', ""7:58 WHYYYY GOOOOD I KNEEWW IIITT !!! :'D"", 'why c++ and java code is smaller than python :)', 'java solution\n\nclass Solution {\r\n    public boolean searchMatrix(int[][] matrix, int target) {\r\n        int rows = matrix.length; \r\n        int cols = matrix[0].length;\r\n\r\n        //find the row to look for\r\n        int topRow = 0;\r\n        int bottomRow = rows - 1;\r\n\r\n        while(topRow <= bottomRow) { \r\n            int midRow = (topRow + bottomRow) / 2;\r\n\r\n            //check if the element exists in the midRow - \r\n            if(target > matrix[midRow][cols - 1]) //check with last element in the row\r\n                topRow = midRow + 1;\r\n\r\n            else if(target < matrix[midRow][0]) //is it smaller than the smallest value of midRow\r\n                bottomRow = midRow - 1;\r\n\r\n            else //target lies within the midRow\r\n                break;\r\n        }\r\n        \r\n        if(!(topRow <= bottomRow)) //while loop exhausted. \r\n            return false; \r\n\r\n        //search the row\r\n        int left = 0, right = cols - 1;\r\n        int targetRow = (topRow + bottomRow) / 2; \r\n\r\n        while(left <= right) {\r\n            int mid = (left + right) / 2;\r\n\r\n            if(matrix[targetRow][mid] > target) //go left\r\n                right = mid - 1;\r\n            else if(matrix[targetRow][mid] < target) //go right\r\n                left = mid + 1;\r\n            else return true;\r\n        }\r\n\r\n        return false; //element not found\r\n\r\n    }\r\n}', 'soon i will crack google too.', 'Intuition\nThis problem will purely be solved on the core principles of how a 2D matrix works,its traversal and a few comparisons.\n\nApproach\nWe assign i=0 and j=n-1, means i is at start of the row and j is present at the start of the last column. We start comparing from j=n-1. Basically,the comparison is starting from the last element of the first row. Now,if observed closely, the last element of the first row, moving downwards from there will always result in a greater value as the 2D Matrix happens to be sorted. If target is smaller, there is no point moving down. Hence, we decrement j and move to the previous column. We check again, if target is still smaller (matrix[i][j]>target) we decrement j again.\n\nobserve one thing. As we move from the extreme right to left, we notice that values are eventually decreasing for the ith row. So we are bound to reach a point, where matrix[i][j] has a smaller value than target. If so, we now increment i and move to the row below,which gets us closer to the target.\n\nFinally we reach a point where we find the target.\n\nComplexity\nTime complexity:\nO(m+n)\n\nSpace complexity:\nO(1)\n\nCode\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int m = matrix.length; // row\n        int n = matrix[0].length; // col\n        int i = 0;\n        int j = n - 1;\n\n        while (i >= 0 && i < m && j >= 0 && j < n) {\n            if (matrix[i][j] == target) {\n                return true;\n            } else if (matrix[i][j] > target) {\n                j--;\n            } else if (matrix[i][j] < target) {\n                i++;\n            }\n        }\n\n        return false;\n    }\n}', '10:10 I think you misspoke here. If the target is smaller than the midpoint, you want to search to the left of it, not the right', 'class Solution:\r\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\r\n        k = 0\r\n        for i in range(len(matrix)):\r\n            p = matrix[k][0]\r\n            s = matrix[k][len(matrix[k]) - 1]\r\n            print(p, s)\r\n            if p <= target and target <= s:\r\n                if target in matrix[k]:\r\n                    return True\r\n                else:\r\n                    return False\r\n            k += 1']"
205,4xbWSRZHqac,"['My C++ Solution which is also of O(n):\n void sortColors(vector<int>& nums) {\r\n        int n0=0,n1=0,n2=0;\r\n        for(int i=0;i<nums.size();i++){\r\n            if(nums[i]==0){\r\n                n0++;\r\n            }\r\n            else if(nums[i]==1){\r\n                n1++;\r\n            }\r\n            else if(nums[i]==2){\r\n                n2++;\r\n            }\r\n        }\r\n        nums.clear();\r\n        nums.insert(nums.begin(),n0,0);\r\n        nums.insert(nums.begin()+n0,n1,1);\r\n        nums.insert(nums.begin()+n0+n1,n2,2);\r\n    }', 'do you have any strategies to identify edge cases like how we are not supposed to increment the i pointer if we do a swap with the right pointer, or must we have done this question before?', 'I slept in the middle.. that is not easy to understand explanation.', 'Cannot imagine solving leetcode without your solutions', 'you are fking brilliant, thank youuu', 'What will be the approach if there are n number of colours?', 'Looks like a great problem to use counting sort since there are only 3 values and guaranteed to never be anything else', ""it's is so cool ,btw there are also another case that if we swap 2 with 2 , which means 2 still in i position , so we should also put i in original position till r -1"", 'Probably failed an interview over this today! and the interviewer just would not let me use count sort 😭', '""""""\r\nI tried to understand why edge case is happening. Bellow is my understanding. Might not be   fully correct but if someone can check this we might able to verify. \n\nIf interested please paste these text in some editor(preferably in jupyter notebook) and check\r\n\r\n""""""\r\n\r\n\r\n""""""\r\nO(N) time O(N) space - Single Pass\r\n\r\n1.Basically we are using 3 pointer format. \r\n    -left pointer designate that all the 0 are on it\'s left\r\n    -right pointer designate that all the 2 are on it\'s right\r\n    -middle pointer taking caser of 1 in middle\r\n\r\n2. One special edge case here\r\n\r\n    [0,1(l),2(m),1,0(r),2]\r\n    \r\n    -This edge case happens when middle pointer points to 2 here. In This case 2 wll be swapped with r. When it happens 0\r\n     will be hanging in middle.\r\n     \r\n     Why it is happening?\r\n     \r\n         To understand this We first need to understand what is actual role of l,m & r pointers.\r\n         \r\n         1.m is main pointer here. It tells how and when to swap. \r\n         2.left having chance to point 0 or 1 at any random time.\r\n         3.m having chance to point 0,1 or 2 at any random time.\r\n         4.r also having chance to point 0,1 or 2 at any random time.\r\n         \r\n         5.t means that when m pointer swaps with r pointer any of there values (0,1,2) can take its place in middle.\r\n         \r\n         -if 1 comes in middle, no issue because we want one 1 in middle.\r\n         \r\n         -if m points 0 then left pointer is already taking care of 0 - no issue here also.\r\n         \r\n         -But if m points to 2 then all 3 values can take it place at any random time- 0 or 1 or 2. \r\n          This happens because of point 3 and 4 above.\r\n          \r\n             -when it is replace by 1 no issue here.\r\n             \r\n             -but if is replaced by 0 then m will move one step again and then 0 will be hanging there in middle\r\n             \r\n             -If it is replaced by 2 then again 2 will be hanging in  middle just like 0\r\n             \r\n             -Above hanging happens when it points to 2 only(reason being possibility of all 3 number appearing at this place)\r\n             .This can be avoided if we don\'t move m pointer in this case.               \r\n""""""\r\n\r\ndef sortColors(nums):\r\n    \r\n    l,r=0,len(nums)-1\r\n    m=0\r\n    \r\n    while m<=r:\r\n        \r\n        if nums[m]==0:\r\n            nums[m],nums[l]=nums[l],nums[m]\r\n            l+=1\r\n            \r\n        elif nums[m]==2:\r\n            nums[m],nums[r]=nums[r],nums[m]\r\n            r-=1\r\n            m-=1 #2\r\n            \r\n        m+=1   \r\n        \r\n    return nums\r\n\r\nprint(sortColors([2,0,2,1,1,0]))']"
206,qkLl7nAwDPo,"['So elegant', 'This is so clever', ""We can do this qn by O(N)  space but it's super hard"", 'MinStack Java Solution:\n\nhttps://youtu.be/lHynQtJUcXs', 'I looked at this problem yesterday and it was listed as Medium.', ""Friends, If you use a Linked List it won't have to reallocate when the array reaches it's limit and you can push the min value into the nodes, so head node always have the min.\n\nLove your work NeetCode. Even if I nail the answer, I always check your solution and I learn something, even if it's just syntax tricks."", 'Wouldn t it be better with a new Node class that has a value and a min? This way you dont store twice the number of pointers', 'Thanks', 'I love how the name of the problem itself is actually the biggest hint.', ""I guess there is some Problem in the code while submitting if Minstack() is called on the first call then we couldn't return anything and the test case fail, IDK you have tackle this problme or not but I have got this problem.\n:)""]"
207,3Rw3p9LrgvE,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews\n\n🥷 Discord: https://discord.gg/ddjKRXPqtk\n\n🐦 Twitter: https://twitter.com/neetcode1', ""what's the need of using a hashmap when all we're storing in it for the keys are false values? Can't we use a set instead and whenever the element is present in the set can we not return false?"", '4:50 6:33 10:20', 'Could someone explain why this doesnt work, it appears to do the same exact thing? setting dp[i][j] = dp[i+1][j] should be the same as setting it to True or False as needed, right?\n\n        dp = [[False for j in range(len(s2)+1)] for i in range(len(s1)+1)]\r\n        dp[-1][-1] = True\r\n        for i in range(len(s1),-1,-1):\r\n            for j in range(len(s2),-1,-1):\r\n                if i < len(s1) and s1[i] == s3[i+j]: # THIS LINE IS CHANGED\r\n                    dp[i][j] = dp[i+1][j] \r\n                if j < len(s2) and s2[j] == s3[i+j]:  # THIS LINE IS CHANGED\r\n                    dp[i][j] = dp[i][j+1]\r\n        return dp[0][0]', 'Hello, the proposed Backtracking solution has a mistake. It will return wrong result \'true\' for a test case s1=""a"", s2="""", s3=""c""', 'FYI your DFS solution does not pass all test cases. I get the point of this video is to highlight the DP solution but you shouldn\'t show incorrect code. \n\nCase that does not pass:\ns1: """"\ns2: """"\ns3: ""a""', 'I am obsessed with your explanation!  You become my no.1 idol', 'Why I= len(s1) and j =len(s2) return true? What if the first character does not match either one?', ""This was super helpful. Here's an O(N) solution I made based off this, given we only have to track 2 rows of our grid at once.\n\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\r\n        if len(s1) + len(s2) != len(s3):\r\n            return False\r\n\r\n        dp, prev = [False] * (len(s2)+1), [False] * (len(s2)+1)\r\n\r\n        for i in range(len(s1), -1, -1):\r\n            for j in range(len(s2), -1, -1):\r\n                dp[j] = False\r\n                if i == len(s1) and j == len(s2):\r\n                    dp[j] = True\r\n                if i < len(s1) and s1[i] == s3[i + j] and prev[j]:\r\n                    dp[j] = True\r\n                if j < len(s2) and s2[j] == s3[i + j] and dp[j+1]:\r\n                    dp[j] = True\r\n            dp, prev = prev, dp\n\r\n        return prev[0]"", ""Another approach, super messy but works\n\n\nunordered_map<string, int> mp;\n\n\r\n\r\nclass Solution {\r\npublic:\r\n\r\nbool isscramble(string s1, string s2, string s3, int index1, int index2, int index3, int str){\r\n    if(index3 == s3.size()){\r\n        return true;\r\n    }\r\n    if(index1 == s1.size() && str == 0){\r\n        return false;\r\n    }\r\n    if(index2 == s2.size() && str == 1){\r\n        return false;\r\n    }\r\n\r\n    string temp = to_string(index1);\r\n    temp.push_back(' ');\r\n    temp.append(to_string(index2));\r\n    temp.push_back(' ');\r\n    temp.append(to_string(index3));\r\n    temp.push_back(' ');\r\n    temp.append(to_string(str));\r\n    if(mp.find(temp) != mp.end()){\r\n        return mp[temp];\r\n    }  \r\n    \r\n    bool ans;\r\n\r\n    if(str == 0){\r\n        if(s1[index1] == s3[index3]){\r\n            ans = isscramble(s1,s2,s3,index1+1, index2, index3+1, 0) || isscramble(s1,s2,s3,index1+1, index2, index3+1, 1);\r\n        }\r\n        else{\r\n            return mp[temp] = false;\r\n        }\r\n    }\r\n    else{\r\n        if(s2[index2] == s3[index3]){\r\n            ans = isscramble(s1,s2,s3,index1, index2+1, index3+1, 0) || isscramble(s1,s2,s3,index1, index2+1, index3+1, 1);\r\n        }\r\n        else{\r\n            return mp[temp] = false;\r\n        }\r\n    }\r\n\r\n    return mp[temp] = ans;\r\n}\r\n\r\n    bool isInterleave(string s1, string s2, string s3) {\r\n        mp.clear();\r\n            if(s3.size() != (s1.size() + s2.size())){\r\n        return false;\r\n    }\r\n    bool ans = isscramble(s1,s2,s3,0,0,0,0) || isscramble(s1,s2,s3,0,0,0,1);\r\n\r\n        return ans; \r\n    }\r\n};""]"
208,e69C6xhiSQE,"['This is a Premium LC Problem but you can solve it for FREE here: https://www.lintcode.com/problem/663/', ""I don't understand one thing, will the initial ordering of the gate index pairs in the queue affect the final result?"", 'Done thanks, this is same logic as the shortest bridge to connect 2 islands problem, you start a bfs from multiple start positions (in the case of islands you start bfs from all the nodes in the first island, but in this case we start bfs from all the gates (even though the gates aren’t connected, that’s fine)\n\nOur queue is initialized with the gates and then we snapshot the queue size and do bfs (keeping a distance variable that you increment everytime you complete a layer)', 'My solution without visit\n\nfrom collections import deque\nclass Solution:\n    """"""\n    @param rooms: m x n 2D grid\n    @return: nothing\n    """"""\n    def walls_and_gates(self, rooms: List[List[int]]):\n        # write your code here\n        direct = [(0,1), (0,-1), (1,0), (-1,0)]\n        q = deque()\n        ROWS, COLS = len(rooms), len(rooms[0])\n        for r in range(ROWS):\n            for c in range(COLS):\n                if rooms[r][c] == 0:\n                    q.append((r,c))\n        while q:\n            r, c = q.popleft()\n            path = rooms[r][c]\n            for dr, dc in direct:\n                rr = r + dr\n                cc = c + dc\n                if (rr < 0 or cc < 0 or\n                    rr >= ROWS or cc >= COLS or\n                    rooms[rr][cc] <= 0 or \n                    rooms [rr][cc] <= path + 1):\n                    continue\n                rooms[rr][cc] = path + 1\n                q.append((rr, cc))\n        return rooms', 'Wow I love this problem.', 'there\'s no need for a `visited` set. if the value is not ""inf"", then update it. I basically used your solution for rotting oranges. (I recommend the viewer to go watch that video and implement that strategy here)\n here\'s a cleaner code with less storage requirements:\n\n\nclass Solution:\r\n    """"""\r\n    @param rooms: m x n 2D grid\r\n    @return: nothing\r\n    """"""\r\n    def walls_and_gates(self, rooms: List[List[int]]):\r\n        # write your code here\r\n        rows, cols = len(rooms), len(rooms[0])\r\n        q = deque() # (r, c)\r\n        inf = 2147483647\r\n        directions = ((1,0),(-1,0),(0,1),(0,-1))\r\n        \r\n        for r in range(rows):\r\n            for c in range(cols):\r\n                if rooms[r][c] == 0:\r\n                    q.append((r,c))\r\n        distance = 1\r\n        while q:\r\n            for i in range(len(q)):\r\n                r, c = q.popleft()\r\n                for dr, dc in directions:\r\n                    row, col = r + dr, c + dc\r\n                    if (row == -1 or row == rows or\r\n                        col == -1 or col == cols or\r\n                        rooms[row][col] != inf ):\r\n                        continue\r\n                    rooms[row][col] = distance\r\n                    q.append((row, col))\r\n            distance += 1', 'Here\'s my version without a visited set. So O(1) space? Since queue only holds values temporarily? \nfrom typing import (\n    List,\n)\n\n""""""\n-1 = wall \n0 = gate \n2147483647 = empty room \n\nTime; O(N*M)\nSpace: O(1) \n\n1) Starting at every gate we will try to reach all possible values \n2) Since we might revisit values, we will only continue if the current distance is greater than the new distance. \nThis will also account for other gates, which might\'ve been closer. \n3) walls are considered impassable invalid positions! \n\n\n""""""\nfrom collections import deque \n\nclass Solution:\n    """"""\n    @param rooms: m x n 2D grid\n    @return: nothing\n    """"""\n    def walls_and_gates(self, rooms: List[List[int]]):\n        \n        directions = [(0,1),(1,0),(-1,0),(0,-1)] \n        ROWS, COLS = len(rooms), len(rooms[0]) \n        que = deque([])\n         \n        #Find all Gates \n        for r in range(ROWS):\n            for c in range(COLS):\n                if rooms[r][c] == 0 :\n                    que.append((r,c, 0))\n\n        while que: \n            r, c, distance = que.popleft()\n            for d in directions: \n                nr, nc = d[0] + r, d[1] + c \n                if 0 <= nr < ROWS and 0 <= nc < COLS and rooms[nr][nc] != 0 and rooms[nr][nc] != -1: \n                    #so we only add to our que and update distance if current value at (nr,nc) is greater! \n                    if rooms[nr][nc] > distance + 1:\n                        rooms[nr][nc] = distance+1\n                        que.append((nr, nc, distance+1))\n\n        return rooms', '1:54 you mean a wall, not gate.', ""Brilliant. The intuition here is simple but absolutely brilliant. I don't think I would get the optimal solution for this one without watching this video."", ""Thanks for solution, is the for loop at line 22 really required ? because, it's a queue, all new positions will be appended to the end.""]"
209,amvrKlMLuGY,"['💡 GRAPH PLAYLIST: https://www.youtube.com/watch?v=EgI5nU9etnU&list=PLot-Xpze53ldBT_7QA8NVot219jFNr_GI', 'Still dont get the problem statement at all', 'Just one thing: you can also keep the max for  path in a different variable which will be your final answer. While constructing the min-heap just by the actual values of the grid. It will give the same answer.', 'When I do the visit.add after the heappop, I get a time limit exceeded. but if I do it inside the neighbors loop then it passes all test cases quickly. Anyone know why?', ""Here's an alternative way: Binary search + dynamic programming\n1. given a fixed water level, do dynamic programming to see if you can reach the end, this takes O(n^2)\n2. do a binary search in the range of 0 to maximum of the grid, representing the range of possible water levels, each time perform step 1. Consequently you could find the smallest water level that you can reach the end. The range is log(n^2) ~ log(n)\noverall time complexity is O(n^2 logn)"", 'Just wanted to point out that this would be:\n\nlet n = w * h\nTime: O(n*logn) since we are checking for visited values. If we did not have the visited set to check for duplicates then it would be O(n^2 * logn)\nSpace: O(n) since at most we could have n values in our minHeap and n values in our visited set.', ""3:30 Can you spell and pronounce it right? Dijkstra's algorithm (/ˈdaɪkstrəz/ DYKE-strəz)"", ""One of my professor's major advisors was Dijkstra himself! Six Degrees of Separation 😄"", 'great video as usual ! only missing thing is time and space complexity', 'DIKE-STRA']"
210,mLpW3qfbNJ8,"['💡 GRAPH PLAYLIST: https://www.youtube.com/watch?v=EgI5nU9etnU&list=PLot-Xpze53ldBT_7QA8NVot219jFNr_GI', ""@NeetCode Just found out that, it makes a huge difference if you write the recursive steps as the following. You wouldn't get the correct answer in this way. I don't know why. Would someone be able to answer it for me?\n            res = res and dfs(r, c + 1)\n            res = res and dfs(r, c - 1)\n            res = res and dfs(r - 1, c)\n            res = res and dfs(r + 1, c)"", 'Hi! Can someone pls explain why are we returning True when going outside of the range in grid2 (line 7). I can understand returning True if grid2 is water because grid1 can still be land but outside of grid2 range being returned as True - I do not understand that part. thanks!!', 'Great Explanation 🔥', 'class Solution:\r\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\r\n        rows, cols = len(grid1), len(grid1[0])\r\n        visit = set()\r\n        def dfs(r, c):\r\n            if r < 0 or c < 0 or r >= rows or c >= cols or (r, c) in visit or grid2[r][c] == 0:\r\n                return True\r\n            if grid1[r][c] == 0:\r\n                return False\r\n            visit.add((r, c))\r\n            return dfs(r + 1, c) & dfs(r - 1, c) & dfs(r, c + 1) & dfs(r, c - 1)\r\n        \r\n        count = 0\r\n        for r in range(rows):\r\n            for c in range(cols):\r\n                if grid2[r][c] == 1 and (r, c) not in visit and dfs(r, c):\r\n                    count += 1\r\n        return count\n\nIn python, x and y means if x if False, return x. otherwise, return y. So only if x is True then y can be executed. \nx or y: if x if True, return x. otherwise return y. That means if x is True, y will not be executed.\nSo in the dfs(). we can only use &. Cause it is the bit counting. \nif we use and, what will happen?\nIn this problem, \ngrid2 = 0: True\ngrid2 = 1: 1) if grid1 = 0: False\n                   2) if grid1 = 1, put in visit\nSo if we use ""and"", if the first dfs(r + 1, c) meet grid1[r + 1][c] is 0 ( sea portion), then it will return False. Then the last 3 dfs() will not be executed. But actually we can still go the others\' directions. \nIn conclusion, if you want to use ""AND"", then you had better save the result of each dfs() in a variable, or you can use""&""', 'Man the amount of confidence I have after solving all your graphs question is insane, thanks a lot for the videos', 'One readability optimisation: instead of ANDing res and reassigning it, you could just use the All function in Python on all 4 directions at once, if any of them return false the whole thing is false.', ""Why can we not use BFS traversal instead of DFS?  I tried but it's giving TLE. Does anyone know the difference?"", ""why res stored in the variable and not returned there itself? if its false what's the point of calculating further?"", 'Why are we returning true if we go out of bounds?']"
211,cTBiBSnjO3c,"['8:09 You talk about popping the stack but are still using the popped values to be present to indicate distance (for the number 75 in your example).  Popping doesn\'t allow for that as it shortens arrays, so this explanation doesn\'t make much sense.\n\nAlso popping occurs from the end, shifting occurs from the beginning, and you\'re referring to ""popping"" numbers with earlier index values (inserted earlier) with items inserted later at the end, which also doesn\'t make sense at face value (you\'re placing the number in your stack in your explanation and then discussing popping earlier values).\n\n**EDIT** This only makes sense when you get to the code section and realize you\'re storing the index in the value.  It makes no sense (as I commented above) to a first-time observer watching your drawn explanation.', 'Got TLE exception with the n^2 solution, thanks for this approach', 'I am currently doing you roadmap. My god, thank you so so so much for that. I am so grateful for that. It truly has helped grinding leetcode fun.', 'Excuse me sir but 69 is always greater. Sorry, I can’t help myself.', 'i tried this with function...but it will run only for small number of arrays', 'whats the tool you use for drawing the solutions?', 'Please create a DSA interview preperation playlist in JAVA also. it will be very helpful to learn DSA in JAVA from you!!!', 'I found this one really hard, i was only able to find a brute force solution. Thank you for the clean explanation. ^_^', 'understood', 'Great Explanation as always\nThank you']"
212,gBTe7lFR3vc,"['💡 LINKED LIST PLAYLIST: https://www.youtube.com/watch?v=G0_I-ZF0S38&list=PLot-Xpze53leU0Ec0VkBhnf4npMRFiNcB&index=2', 'If slow goes 1\nFast goes 2\n\n\nAnd slow goes first…\n\n\nAnd the whole cycle is n steps, then once fast gets ahead i.e. after its first step, then think of more as slow is already on its next lap. \n\nHow many iterations does fast have to take? To match slow? \n\nn - delta\n\nDelta is 2 - 1 \n\nSo if it was 10 steps it would be 10 - ( 2 - 1)\n\nIf you actually think of fast getting ahead then fast well is always ahead. \n\nHe purposely didn’t use ahead but said gap. But depending on how you think of it, it can be vague a bit…', 'No one on their own will ever think that the best way to do that is to presume the pointers collide, that\'s absolutely insane reasoning for an ""Easy"" problem.  Couldn\'t you just have 2 pointers one ahead of the other, and if the ahead pointer is ever behind the behind pointer (by checking the `pos` which they claim is a node attribute index value) then it\'s a loop?  That seems much more intuitive and sane use of two pointers, but I see how this insane theory-based one is the only solution for not having some comparable index value (but then I mean, could you not cast the nodes to an array and just make an index value anyways?)', 'Since there were no rules against modifying the original linked list, my approach was to actually move through the linked list and reverse the list as I traversed it. I only had to store a single node in a hash map (the original head) so the memory complexity was O(1). Once you move through a cycle all the nodes you encounter after the cycle are now reversed so the path will take you back to the original head and you can return true if you find a match against the single node in the hash map, otherwise false if you encounter NULL.', 'This explanation is sooooooooooooooooooooooooooooooooo ammmmmmmmmmmmmmmmmmmmmaaaaaaaaaaaaazing. Thank you very much!!!', 'A lot of people are cheating on this question by looking at the `pos` variable that is not passed in. Efficient solutions like these could only be in ~50% because of these cheaters.', 'thansk for such an awesome explanation.', 'How does one come up with that algo XD', 'you are so gooddd', 'Would there ever be a situation where the fast pointer always overshoot the short pointer so that they will never meet?']"
213,LziQ6Qx9sks,"['💡 DYNAMIC PROGRAMMING PLAYLIST: https://www.youtube.com/watch?v=73r3KWiEvyk&list=PLot-Xpze53lcvx_tjrr_m2lgD2NsRHlNO&index=1', ""I have a question? in the description it says we have to multiply it by 2 after dividing it by 3. And We're only dividing it by 3. This is the only thing that confuses me. Can anyone help? please"", 'each day has 3 actions that depend on n oranges remaining. DP is suitable here with top down or bottom up\n\nBottom up building output: \ndp[n] = maximum number for n oranges remaining\n\ndp[0] = 0\ndp[1]=1\ndp[2] = Math.min(dp[2-1]+1, dp[2/2] +1) = 2\ndp[3] = math.min(dp[3-1]+1, dp[2*3/3]+1\n...\n\nTop down: \nCalculateTopDown(int n, int[] dp )\n{\n      if(n <= 1) return n;\n       BestResult = CalculateTopDown(n-1)+1\n      if(n%2==0)\n             BestResult  = Math.min(bestResult, calculateTopDown(n/2)+1); \n\n\r\n      if(n%3==0)\r\n             BestResult  = Math.min(bestResult, 2*calculateTopDown(n/3)+1); \n\n     dp[n] = bestResult\n\nreutnr bestResult\n}', ""Thanks NeetCode, so isn't it a branch and bound method?"", 'The only solution on the internet that explains this peoblem...others are just copying hints', ""I don't really get why we have to write return dp[n] for the second time"", 'you really churned those dp problems last june :d', 'Hey @NeetCode, can you also convince us why greedy works ?', 'Awesome explanation. You made it look easy.', 'the agreement on leetcode is that time complexity is O(log^2(N),) not O(log(N)).']"
214,fFVZt-6sgyo,"['u forgot to add 2,1 to the hashmap', 'not clear explanation', 'Thanks a lot', 'Just wonder why the prefix sum 2 is not in the hashmap.', 'Very nice & clear. TY!', 'yey first real english guide!', ""It's easier to use defaultdict instead of the .get"", 'Finally some decent explanation of this magic', 'I have a doubt. If the array is 6,4,3 and k is 9. we find that sum till n is 13 and 13-k ie 13-9=4 is present in the array so that will get counted but in reality it is wrong as it is not a subarray is we dont pick contiguous element. please explain', 'Still dont get how to arrive at using a map, no intuition\nThis is a crappy problem']"
215,Ph95IHmRp5M,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'Man you are awsome. Really awesome.', 'You are the best neet code', 'Please always include time and space complexity for all solutions. My understanding is that interviewer always ask for time and space complexity in pretty much all interviews.\nTime O(N^N), Space O(N^2). I struggle with tighter time complexity for backtracking problems. If we can ignore previously visited locations from the search then it can actually be O(N!)?', 'the only chess piece i know how to move is a pawn', 'I learnt something from this video. You explained it very clearly and concisely. Thank you!', 'pretty genius way to detect collision of diagonal!!', 'Thanks\nTODO:-\nTake notes\n\nBacktracking the positions of the queens, but since queens can move horizontally vertically and diagonally, we can’t put two queens together in the same row (because they move horizontally so would attack each other) and also can’t put them in same column or diagonal. So when backtracking, we place queen in a position in row and make recursive call to place the other in next row and keep track of:\n\nColumn that queen was placed in\nBoth diagonals of the queen (YES there are TWO diagonals that the queen can move in, positive slope and negative slope, so need to keep track of both)', 'Great explanation', 'I had seen this problem for the first time about 7 years ago in uni and I was too scared to even attempt it. \n\nThanks for explaining it so beautifully and helping me conquer my fear. (I was so stupid to be scared of this problem lol)']"
216,wjYnzkAhcNk,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', ""That's right. Even Floyd wouldn't have resolved this problem in 30 minutes. It goes on to say that given the nature of such requirements in an interview, certain solutions are best memorized so that you could use them in a different situation or if the same problem comes up again."", 'A slightly better implementation.😊\n\ndef findDuplicate(self, nums: List[int]) -> int:\n        slow, fast = 0, 0\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n\n        slow2 = 0\n        while slow != slow2:\n            slow = nums[slow]\n            slow2 = nums[slow2]\n        \n        return slow', 'I will cry if I got this question in intervew', 'I like the fact that you disliked this problem', ""You're right, I don't know why would anyone ask this question, nobody will know it unless they have super memory and saw it already and this doesn't let you learn anything about the interviewee."", 'Indexes are nodes and values in those indexes are next pointers ( to indexes). That how it is linked list', ""In example through logic once we reached to the 3 \n\nin first while loop we reached 3 so why can't we directly return nums[3] \n\nwhich is answer 2.\n\nPlease answer anybody."", 'Thk from Egypt ❤', 'I really love u thk for all u do bro']"
217,NMP3nRPyX5g,"['💡 LEETCODE SOLUTIONS: https://www.youtube.com/playlist?list=PLot-Xpze53leF0FeHz2X0aG3zd0mr1AW_', 'For test case \nremovable=[1,2,3,4]\ns=""abcacb"" p=""ab""\nwhat if question is for finding the max size of removable characters so that p is a substring of s\nbinary search would give wrong answer for that what should be the optimized approach', 'The space complexity of the solution is so big, it creates a new set for each out while loop. We should optimize it.', 'Input: s = ""abcab"", p = ""abc"", removable = [0,1,2,3,4]\nOutput: 0\n\nIn this example, isn\'t the max removable k 2, since you can remove indices 3 and 4, which will make p still a subsequence of s?', 'A little bit simplified: \n       def isSubseq(s, p, removed):\r\n            i, j = 0, 0 \r\n            while i < len(s) and j < len(p):\r\n                if i not in removed and s[i] == p[j]:\r\n                    j += 1\r\n                i += 1\r\n            return j == len(p)', 'how time complexity will be nlogk when we are slicing an array to check for removed index in worst case we have to to it for k time so time complexity will be nk am I missing something?', 'Wouldnt the line: removed = set(removable[:m+1]) be O(k) since it is string splicing? Am I missing something?', 'Amazing Playlist!! Thank you!', 'I am not able to put my thoughts completely but we should be able to solve this in O(n) (or more preciously O(m+n)) by using prefix array of KMP. If I have prefix length for each char, then when removing a particular index I should have some way to check prefix length of next occurrence of this char and based on which I should be able to answer whether I can delete or not in O(1). In this I will traverse removable array from start and stop when removing char will cause p not be subsequence.', 'Can you say what was the intuition behind this to be a binary search problem?']"
218,kShkQLQZ9K4,"['💡 LEETCODE PLAYLIST: https://www.youtube.com/playlist?list=PLot-Xpze53leF0FeHz2X0aG3zd0mr1AW_', 'This solution will fail if the target has duplicate set of values [5,5,5], in that case length of good set will be 1, you can use booleans to keep track like this class Solution:\n    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:\n        t1, t2, t3 = target\n        x1_found, y1_found, z1_found = False, False, False\n        for x1, x2, x3 in triplets:\n            if x1 > t1 or x2 > t2 or x3 > t3:\n                continue\n            if x1 == t1:\n                x1_found = True\n            if x2 == t2:\n                y1_found = True\n            if x3 == t3:\n                z1_found = True\n            \n            if x1_found and y1_found and z1_found: return True\n        return False', 'Please cover leetcode 1648...', ""We can make it faster by stopping as soon as we detect we've found all three values:\n\nclass Solution:\n    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:\n        found = [False, False, False]\n        for t in triplets:\n            if t[0] > target[0] or t[1] > target[1] or t[2] > target[2]:\n                continue\n            for i in range(3):\n                if t[i] == target[i]:\n                    found[i] = True\n            if all(found):\n                return True\n        return False"", ""Great video! The idea I thought of is that to satisfy the target [a,b,c] we find three such pairs:\n1. [a, <=b, <=c]\n2. [<=a, b, <=c]\n3. [<=a, <=b, c]\nand if we can't, its False.\n\n        c1 = False\r\n        c2 = False\r\n        c3 = False\r\n\r\n        for i in range(0, len(triplets)):\r\n            if(not c1):\r\n                if (triplets[i][0] == target[0] and\r\n                    triplets[i][1] <= target[1] and\r\n                    triplets[i][2] <= target[2]):\r\n                    c1 = True\r\n            if(not c2):\r\n                if (triplets[i][0] <= target[0] and\r\n                    triplets[i][1] == target[1] and\r\n                    triplets[i][2] <= target[2]):\r\n                    c2 = True\r\n            if(not c3):\r\n                if (triplets[i][0] <= target[0] and\r\n                    triplets[i][1] <= target[1] and\r\n                    triplets[i][2] == target[2]):\r\n                    c3 = True\r\n            if(c1 and c2 and c3):\r\n                return True\r\n        return False"", 'My solution.\n\nclass Solution:\n    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:\n        valid_max = [0, 0, 0]\n        \n        for triplet in triplets:\n            # update valid_max if triplet is valid\n            if triplet[0] <= target[0] and triplet[1] <= target[1] and triplet[2] <= target[2]:\n                valid_max = [max(valid_max[0], triplet[0]), max(valid_max[1], triplet[1]), max(valid_max[2], triplet[2])]\n                \n        \n        return valid_max == target', 'A bit-optimized solution would be\n\ndef mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:\n\t    first_index = second_index = third_index = 0\n        \n\t    for first_element, second_element, third_element in triplets:\n        \n\t\t\tif first_element <= target[0] and second_element <= target[1] and third_element <= target[2]:\n                                  first_index, second_index, third_index = max(first_index, first_element), max(second_index, second_element), max(third_index, third_element)\n\n\t    return [first_index, second_index, third_index] == target', ""can someone explain why it's greedy?"", 'much smooth and silky solution\nclass Solution {\n    public boolean mergeTriplets(int[][] triplets, int[] target) {\n        boolean t1=false,t2=false,t3=false;\n        for(int i=0;i<triplets.length;i++){\n            if(triplets[i][0]==target[0] && triplets[i][1]<=target[1] && triplets[i][2]<=target[2] ){\n                t1=true;\n            }\n            if(triplets[i][1]==target[1] && triplets[i][0]<=target[0] && triplets[i][2]<=target[2] ){\n                t2=true;\n            }\n            if(triplets[i][2]==target[2] && triplets[i][0]<=target[0] && triplets[i][1]<=target[1] ){\n                t3=true;\n            }\n        }\n        if(t1 && t2 && t3){\n            return true;\n        }\n        return false;\n    }\n}', 'Excellent solution!!!!\r\n\r\nBefore I saw this video, I did very complex steps\r\n1. remove duplicated and useless elements \n2. do backtracking\r\n3. finally get TLE😓.']"
219,f7JOBJIC-NA,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', ""How's it different than Djkistra Algo? @neetcode"", 'can you drop a link to c++ code for this ques?', 'JAVA IMPL.\n\n\nimport java.util.*;\r\n\r\nclass point {\r\n\r\n    int x;\r\n    int y;\r\n\r\n    public point(int x, int y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return Objects.hash(x, y);\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        point p = (point) obj;\r\n        if (this.x == p.x && this.y == p.y) {\r\n            return true;\r\n        }\r\n        return false;\r\n\r\n    }\r\n\r\n}\r\n\r\nclass edge {\r\n    point p1;\r\n    point p2;\r\n    int weight;\r\n\r\n    public edge(point p1, point p2, int weight) {\r\n        this.p1 = p1;\r\n        this.p2 = p2;\r\n        this.weight = weight;\r\n    }\r\n}\r\n\r\nclass Solution {\r\n\r\n    public int prims(HashMap<point, List<point>> adjList, HashSet<point> visited, PriorityQueue<edge> minHeap,\r\n            int sum) {\r\n        edge top = minHeap.poll();\r\n        if (top == null) {\r\n            return sum;\r\n        }\r\n        while (visited.contains(top.p2)) {\r\n            top = minHeap.poll();\r\n            if (top == null) {\r\n                return sum;\r\n            }\r\n        }\r\n        sum += top.weight;\r\n        point start = top.p2;\r\n        visited.add(start);\r\n        List<point> neighbours = adjList.get(start);\r\n        neighbours.forEach((neighbour) -> {\r\n            if (!visited.contains(neighbour)) {\r\n                int weight = Math.abs(start.x - neighbour.x) + Math.abs(start.y - neighbour.y);\r\n                minHeap.add(new edge(start, neighbour, weight));\r\n            }\r\n        });\r\n\r\n        return prims(adjList, visited, minHeap, sum);\r\n\r\n    }\r\n\r\n    public int minCostConnectPoints(int[][] points) {\r\n        if (points.length == 1) {\r\n            return 0;\r\n        }\r\n        HashMap<point, List<point>> adjList = new HashMap<>();\r\n\r\n        PriorityQueue<edge> minHeap = new PriorityQueue<>((e1, e2) -> {\r\n            return Integer.compare(e1.weight, e2.weight);\r\n        });\r\n        for (int i = 0; i < points.length; i++) {\r\n            for (int j = 0; j < points.length; j++) {\r\n                if (i != j) {\r\n                    List<point> temp = adjList.getOrDefault(new point(points[i][0], points[i][1]),\r\n                            new ArrayList<>());\r\n                    temp.add(new point(points[j][0], points[j][1]));\r\n                    adjList.put(new point(points[i][0], points[i][1]), temp);\r\n                }\r\n            }\r\n        }\r\n\r\n        minHeap.add(new edge(null, new point(points[0][0], points[0][1]), 0));\r\n        int sum = 0;\r\n        HashSet<point> visited = new HashSet<>();\r\n        sum = prims(adjList, visited, minHeap, sum);\r\n        return sum;\r\n\r\n    }\r\n\r\n}', ""shouldn't we heapify the list first?"", 'Great Explanation !!!', 'Ok, can you clarify why did not we just do compare each node with everyone and take the min values and add them up? it will be n^2. is it because we want to prevent a cycle?', 'is this a TSP?', '❤❤', 'small tip: if we heapq.heappush a tuple instead of list, it will save a lot of time.']"
220,hTM3phVI6YQ,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'Hey NeetCode,\n\nIn the Iterative DFS approach, within the while loop, if we append like this\n\nstack.append(node.left, depth+1);\nstack.append(node.right, depth+1);\n\n\nWhen we pop in the next iteration, then the right child will be popped and their children will be added right (because the right child is added last in the stack). I think the order should be reversed here so that the left children will be popped in the next iteration', 'Hi there,I dont get why we use a max here why not just use a count instead?', ""I did catch the node --> root. But ... here's what my aMaZiNg code resulted in -\nAttributeError: 'Solution' object has no attribute 'maxDeapth'. Did you mean: 'maxDepth'? \n\n**cries in the corner**"", 'Wooow... almost one line solution ))) You are amazing!!!', ""I usually don't like recursion, but it was the simplest one. xD"", 'you are smart', 'thanks! right should have been appended before the left yes ?', 'understood', 'I’m a bit confused on the DSF on why it would be max(result, depth) wouldn’t depth be good enough?']"
221,6kTZYvNNyps,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'This is too hard for me now😶\u200d🌫', ""why don't you return anything at the end of the dfs method?"", 'is this meant for humans to solve.. .😭', 'Hard became Easy for me after watching this', 'LINTCODE JAVA SOLUTION\npublic class Solution {\r\n    public String alienOrder(String[] words) {\r\n        HashMap<Character, HashSet<Character>> adjMap = new HashMap<>();\r\n\r\n        for(int i=0;i<words.length;i++) {\r\n            for(int j=0;j<words[i].length();j++) {\r\n                char ch = words[i].charAt(j);\r\n\r\n                adjMap.put(ch, new HashSet<>());\r\n            }\r\n        }\r\n\r\n        for(int i=0;i<words.length-1;i++) {\r\n            String w1 = words[i];\r\n            String w2 = words[i+1];\r\n\r\n            int minLen = Math.min(w1.length(), w2.length());\r\n\r\n            if(w1.length() > w2.length() && w1.substring(0, minLen).equals(w2.substring(0, minLen))) {\r\n                return """";\r\n            }\r\n\r\n            for(int j=0;j<minLen;j++) {\r\n                char c1 = w1.charAt(j);\r\n                char c2 = w2.charAt(j);\r\n\r\n                if(c1 != c2) {\r\n                    adjMap.get(c1).add(c2); // c1 -> c2\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        List<Character> list = new ArrayList<>();\r\n\r\n        for(Map.Entry<Character, HashSet<Character>> entry: adjMap.entrySet()) {\r\n            list.add(entry.getKey());\r\n        }\r\n        \r\n        Collections.sort(list);\r\n\r\n        visit = new HashSet<>();\r\n        path = new HashSet<>();\r\n        res = """";\r\n\r\n        for(int i=list.size()-1;i>=0;i--) {\r\n            char ch = list.get(i);\r\n\r\n            if(visit.contains(ch) == false) {\r\n                if(dfs(adjMap, ch) == false) {\r\n                    return """";\r\n                } \r\n            }\r\n        }\r\n\r\n        String ans = """";\r\n        for(int i=res.length()-1;i>=0;i--) {\r\n            ans = ans + res.charAt(i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n\r\n    HashSet<Character> visit;\r\n    HashSet<Character> path;\r\n    String res;\r\n\r\n    public boolean dfs(HashMap<Character, HashSet<Character>> adjMap, char ch) {\r\n        if(path.contains(ch)) {\r\n            return false;\r\n        }\r\n\r\n        if(visit.contains(ch)) {\r\n            return true;\r\n        }\r\n\r\n        path.add(ch);\r\n        visit.add(ch);\r\n\r\n        for(Character c: adjMap.get(ch)) {\r\n            if(dfs(adjMap, c) == false) {\r\n                return false;\r\n            } \r\n        }\r\n\r\n        res = res + ch;\r\n        path.remove(ch);\r\n\r\n        return true;\r\n    }\r\n}', 'Done thanks\n6:20 you only need to compare words to the word right after it and not to every other word in the list because the list itself is sorted lexicographically according to the language', 'Is there any way to create a Lintcode account without Wechat?   Can someone with a wechat account help me activate it', ""I can't wait when someday my client will request to implement this algorithm so they can sell the product to Alien."", ""For those looking for the solution that also works in Lintcode, when iterating over the characters to call DFS on each one, we can replace:\n`for char in adj:`\nwith:\n`for char in reversed(sorted(adjacencyMap.keys())):`\n\nThis is because our solution already works for all connected components, but when we have 2 connected components, we want to ensure that we sort the start of our connected components by Human dictionary order (because Lintcode requires it). The reason we're sorting in reverse order, ex: z before a, is that we're going to reverse the result later on. Was looking for a while on how to convert Neetcode's solution to work with Lintcode's requirements and couldn't find it anywhere so figured I'd share the solution once I got it working.""]"
222,8f1XPm4WOUc,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'Can anyone explain why he does rank[p2] += rank[p1] or vice versa? I intuitively did rank[p1]+=1 and same for p2, and it still works.', ""can you do a video on tarjan's algorithm in python?"", 'where can i do this problem for free?', 'Python hashmap only version:\n\nclass Solution:\r\n    def countComponents(self, n: int, edges: List[List[int]]) -> int:\r\n        parent_map = { i: i for i in range(n)}\r\n        subtree_size = { i: 1 for i in range(n)}\r\n        \r\n        \r\n        num_components = n\r\n        for starting_node, ending_node in edges:            \r\n            if self.union(starting_node, ending_node, parent_map, subtree_size):\r\n                num_components -= 1\r\n        \r\n        return num_components\r\n    \r\n    def find_root_parent_node(self, current_node, parent_map):\r\n        parent_node = parent_map[current_node]\r\n        while current_node != parent_node:\r\n            grand_parent_node = parent_map[parent_node]\r\n            parent_map[current_node] = grand_parent_node\r\n            \r\n            current_node = grand_parent_node\r\n            parent_node = parent_map[grand_parent_node]\r\n        return parent_node\r\n    \r\n    def union(self, node_1, node_2, parent_map, subtree_size):\r\n        node_1_parent = self.find_root_parent_node(node_1, parent_map)\r\n        node_2_parent = self.find_root_parent_node(node_2, parent_map)\r\n        if node_1_parent == node_2_parent:\r\n            return False\r\n        \r\n        smaller_parent = node_1_parent\r\n        larger_parent = node_2_parent\r\n        if subtree_size[node_1_parent] > subtree_size[node_2_parent]:\r\n            smaller_parent = node_2_parent\r\n            larger_parent = node_1_parent\r\n            \r\n            \r\n        parent_map[smaller_parent] = larger_parent\r\n        subtree_size[larger_parent] += subtree_size[smaller_parent]\r\n        \r\n        return True', 'I think line 7 should be res = par[n1] (in the find function) ? thanks.', 'This question is similar to the question  547. Number of Provinces', ""rank array is messed up, can't just add up lol"", 'How can you make everything daunting so easy? Hats off to you sir.', 'Dope! When I first saw the video I was like ""too easy, just dfs blah blah ..."". Haven\'t seen anyone solving it using DSU. Thank you sir!\n\nOne question though, you don\'t need rank to solve this problem do you?']"
223,asbcE9mZz_U,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'it won\'t pass the test case for ""oa"" and ""oaa""', 'you dont need a set and you do not need to remove leaf nodes either. When you found a word, just say node.isWord = False. This will handle all nodes, not just leafs and it will prevent adding duplicates without having to use a set', 'This was my approach for removing the word from Trie to overcome Time Limit Exceeded on python:\r\n[... in Trie class ...]:\r\n    def removeWord(self, word):\r\n        cur = self\r\n        for c in word:\r\n            if len(cur.child[c].child) == 0:\r\n                del cur.child[c]\r\n                return\r\n            else:\r\n                cur = cur.child[c]\r\n\r\n[... in dfs function ...]:\r\n        if node.end:\r\n            res.add(word)\r\n            # this is optimization, remove the word after it has been found\r\n            node.end = False\r\n            root.removeWord(word)\r\n\r\n\r\nhope this helps!', 'How u come up with all of this solution ideas bro? it took me like 20 minutes to realise why your code works 🤣', 'How about converting the matrix to Trie and searching for words?', 'I have a question regarding the backtracking/recursion. Do we not need to pass in current vistited set as parameters to the function? why or why not??', 'you should redo this one', ""Your solution really helped me to fix TLE. Shame on me, I couldn't come up with the right solution on my own =("", 'Just small modification to avoid TLE #######################\n1. Fasle the EndOfWord\n2. Adding num_of_word variable\n\nclass TrieNode:\r\n    def __init__(self):\r\n        self.children = {}\r\n        self.EndOfWord = False\r\n        \r\n    def add_word(self, word):\r\n        cur = self\r\n        for c in word:\r\n            if c not in cur.children:\r\n                cur.children[c]=TrieNode()\r\n            cur = cur.children[c]\r\n        cur.EndOfWord = True\r\n\r\nclass Solution:\r\n    def __init__(self):\r\n        self.num_of_words = 0\r\n        \r\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\r\n        self.num_of_words = len(words)\r\n        root = TrieNode()\r\n        for word in words:\r\n            root.add_word(word)  \r\n        res, visit = [], set()\r\n\r\n        def dfs(x, y, word, node):\r\n            if x<0 or y<0 or x>=len(board) or y>=len(board[0]) or board[x][y] not in node.children or (x,y) in visit or self.num_of_words == 0:\r\n                return\r\n            visit.add((x,y))\r\n            \r\n            node = node.children[board[x][y]]\r\n            word+=board[x][y]\r\n            if node.EndOfWord:\r\n                res.append(word)\r\n                node.EndOfWord = False ####################################\r\n                self.num_of_words-=1 ###############################\r\n            \r\n            dfs(x+1, y, word, node)\r\n            dfs(x, y+1, word, node)\r\n            dfs(x-1, y, word, node)\r\n            dfs(x, y-1, word, node)\r\n\r\n            visit.remove((x,y))\r\n        \r\n        for i in range(len(board)):\r\n            for j in range(len(board[0])):\r\n                dfs(i, j, """", root)\r\n\r\n        return res']"
224,RyBM56RIWrM,"['the best code \nfun countBits(n: Int): IntArray {\r\n        val arr = IntArray(n + 1)\r\n        if (arr.size == 1) return arr\r\n        arr[1] = 1\r\n        for (i in 2 until arr.size) arr[i] = arr[i / 2] + i % 2 \r\n        return arr\r\n    }', 'Mind blowing ❤', 'Great explanation as always !!! Thank you !', 'what if i used the hamming weight function (almost O(1) complexity) to calculate the hamming weights of each bit  and add it to the array in one pass??', 'Awesome solution!', 'Hello, Thank you for this great video. I am wondering why in your video for ""number of 1 bit"", the time complexity for the %2 method is O(1), but in this video, the time complexity for the %2 method is O(nlogn), where the continuous mod 2 contributes to the logn part. Can I argue that the complexity for the %2 approach for this question could also be O(n) as there will only be 32 bits? Thank you very much for answering', 'tell me this is Magic, wow bro!', 'The thing that I love about neetcode is how he builds our intuition. Rarely do I have to look at his actual implementation--I can just watch his explanation, understand the problem and solution, and then implement it myself.', 'This solution is inspired by your video on simple numbers. \nBasically we were n&(n-1) to get the 1 and incrementing the counter. here we just do the AND operation then get the amount from  dp[n&(n-1)] + 1. \n\n        for(int i=0;i<n;i++){\n            int j = i&(i+1);\n            res[i+1]=res[j]+1;\n        }', '9:10 no pun intended']"
225,MOeuK6gaC2A,"['Thank you so much bro.', 'if (r-l+1)==n:\n    res = min(res,diff1,diff2)\n\nThis if condition is unnecessary, since the left pointer has already been increment. it\'s just like if (10-0+1>10), again if (10-1+1)==10 in the same loop. so completly waste. \n you can just put   "" res = min(res,diff1,diff2) "" inside of the prev if condition.', 'This O(n) algo can be slightly improved with these changes :\n\nEssentially, use bit manipulation operations\n\n(1) No need to have an O(n) loop to build the alternating bits mask. Bit manipualation methods and geometric progression math formula can be used to get the mask bit string in O(1) time\n\n(2) No need to have an O(n) loop to count bit flips. XOR of the input bit string segment and mask bit string segment can be done to get few 1 bits representing bit flips. Segments can be obtained by using an all 1s mask, AND with the input and alternating bits mask to get the segments, and right shift the all 1s mask to get the next segments. Later, the 1s in the XORed result can be obtained by using bit manipulation methods and geometric progression math formula -- build as many cloned blocks as is the length of the XORed result, AND each block with 1, 10, 100, ..., 1000 mask segments -- i.e. AND the 1st big block and the 2nd mask block -- right shift the ANDed block k times (where k is the length of the XORed block) to get all ""bit flip indicator"" bits (0 or 1) to the rightmost bit position\n\nAll these can be done mathematically. No need to code. Math equation (geometric progression) gives the result in O(1)\n\nThus the final program would be a much closer to O(n)\n\nMakes sense? (I\'ve implemented this)', 'Nice way to explain , but I think this is not the optimal solution and errors out for a test case having around 74461 characters in input . Error- :Time limit exceeded"" . Kindly update the code with the upgraded version if any . \nIt would be really helpful if there can be a direct link for the source code as well .\n\nThanks, your videos are helpful !!!', 'Thanks for the video, but I think there is a mistake in the code. The string concatenation creates new copies every time, so the time complexity of constructing alt1 and alt2 is O(n^2). I think the list operation should be used instead', 'It is great that you mentioned you have come up with that idea of type 1 operation from the leetcode discuss. It motivates people more that even NeetCodeIO looks for the leetcode discuss section, so why would we feel down to check the discuss section?', 'Actually diff1 + diff2 == L. Only one diff/alt is needed.', 'Hi, thanks for the explanation.\r\n\r\nI think the reason that extending the alternating strings (alt1 and alt2) work is that each time they transform into each other. (0101... becomes 1010... and vice versa etc.) which means that we should do diff2 = diff-1 and diff1 = diff2 -1 instead of diff -=1 and diff2-=1.\r\n\r\nThe solution works because at each round we take minimum of diff1 and diff2 which makes swapping diff1 and diff2 unnecessary computation wise (even though logically it seems wrong).', ""Such a smart solution. Is this really a medium question though? It's pretty hard to come up with such a solution during an interview."", ""Anyone Getting TLE in Java convert string to char array.\n\nclass Solution {\r\n    public int minFlips(String s) {\r\n        int n =s.length();\r\n        s = s+s;\r\n        char s2[] = s.toCharArray();\r\n        char[] alt1=new char[n+n];char[] alt2=new char[n+n];\r\n        for(int i=0;i<s.length();i++){\r\n            if(i%2==0){alt1[i]='1';alt2[i]='0';}\r\n            else{alt1[i]='0';alt2[i]='1';}\r\n        }\r\n        int l=0,res=s.length(),diff1=0,diff2=0;\r\n        for(int r=0;r<n+n;r++){\r\n            if(s2[r]!=alt1[r]){diff1++;}\r\n            if(s2[r]!=alt2[r]){diff2++;}\r\n            \r\n            if(r-l+1>n){\r\n                if(s2[l]!=alt1[l]){diff1--;}\r\n                if(s2[l]!=alt2[l]){diff2--;}\r\n                l++;\r\n            }\r\n            if(r-l+1==n){\r\n                res=Math.min(res,Math.min(diff1,diff2));\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}""]"
226,Y0lT9Fck7qI,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', ""Can anyone explain me why at 12:15, the base case has 1 as default value? I though from 5 to 5 should not count because it's not actually moving from/to anywhere.\nAt 4, I understand that to go to 5, there's only one way."", 'OG coding', ""12:10 \nI can't wrap my head around why there's 1 way to get to 5 when you're already on the 5th step?\nThere are only two options: taking one step or taking two steps.\nSo when you're already on the 5th step, shouldn't you have zero options?\nBecause taking one step would take you to the 6th step, and taking two steps would take you to the 7th step; both options won't take you to the 5th step."", 'I couldnt stop thinking who came up with this algorithm.  You go from a long manner of counting by ones and twos, to creating a decision tree, to finding patterns and see how can you simplify the code, to ultimately realizing that counting backwards can simplify the counting, to ultimately recognizing the solution is simply the fibornacci series of numbers.  TOo easy, becuase some genius paved the way... amazing', 'GOD', 'That was a great explanation!', 'Why is the base case 1? Wouldn’t it be 0 since we are already at the goal?', 'Your Decision Tree explained memoisation succinctly. Thanks !!!', 'Wow this was a great explanation. I love you ❤']"
227,hsomLb6mUdI,"['💡 DP Playlist: https://www.youtube.com/watch?v=73r3KWiEvyk&list=PLot-Xpze53lcvx_tjrr_m2lgD2NsRHlNO', 'who designed this problem? To solve this under 45 mins during interview is insane!', 'Hi NeetCode, thanks for this explanation, it really helped, however please there is a small enhancement you can do:\n\nIn fact the reason why your solution at the end is showing less performance, it\'s because you are not benefiting from the memoization correctly. If you debug your solution, you will find that the line 30 is being hit multiple times for the same ""remainT"". the variable ""used"" in the line 24 should check first if ""dp[remaintT]"" is available to not do the work again. The dp check on the line 11 can  be removed.\n\nThanks again.', 'I love that ""Word break with steroids""😂', 'When you choose a stikcker you are basically decreasing count of all the same character in the sticker and the target, then what is the need of reducing the frequency at the very start of the recursion it seems like redundant code', 'One small optimization is we can filter out letters from stickers that are not in our target (using a set of target) when populating stickCount. This helps simplify the problem to only letters in stickers that are also in target. \n\nstickCount = []\ntargetSet = set(target)\nfor i, s in enumerate(stickers):\n      stickCount.append({})\n      for c in s:\n           if c in targetSet:\n                stickCount[i][c] = 1 + stickCount[i].get(c,0)', 'if we do not check the 1st one character, like the target is ""thehat"" at the beginning, we know we can first go to the sticker ""with"", cause ""th"" in with. But if we skip th, what I mean is we iterate all characters in ""thehat"", th is not in ""example"", but e and a are in ""example"", so we can go pass the sticker ""example"" and the remaining target is ""thht"", then we can go pass the second sticker ""example"". \nSo the path gonna be ""thehat with using example"" -> ""thht with using with"" -> ""ht with using with"", then the target is empty. And the result is still 3 stickers.\nBut in 11:07, @neetcode said we cannot go pass the sticker""example"", because the 1st chacter ""t"" is only in ""with"". \nI think this thought also gonna be work, but why doesn\'t neetcode take this solution?', 'Can you also provide solutions of trilogy innovations coding interview questions?', ""hmm, i found your solution this time is overly complicated and the discussion as well. It is hard to pinpoint exact things, but i think a couple of things can be improved:\n1. in discussion, you went on length to discuss why simply using target is not enough, but later on you kinda contradict your own discussions. Perhaps i didnt understand the context very well, but i felt like you have not fully understood the solution yet thus you were considering a convoluted scenario where target can not be used as the key.\n2. you used dfs(target, stick) as the dfs..., which i find a bit unnecessary... It gives the impression it is a 2-d DP, while actually we can think of the problem as 1-d DP, which has dp(target) = 1 + min(dp(target - sticker1), dp(target-sticker2, ...).\n3.Lastly, you didn't explain why we have to check remainT[0] not in s is necessary. In fact it is not necessary condition, you will get the solution as well even without these lines. However, this line is super helpful since it can skip some loops by only processing sticker that is a potential candidate. This can be seen as like a heuristic A star technique in search. Missed an opportunity to explain the trick."", 'Word Break on Steroid 😆']"
228,Hr5cWUld4vU,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'why he have used a list for the res , why not just a integer? can anyone make me understand please!', 'I am still confused about line 24. Can anyone explain to me how it works?', 'this is kinda like house robber 3', 'quick question to anyone: why is using a global variable cheating?', 'Another way to conceptualise what constitutes a path is to only have those nodes or vertices in consideration that have at most 2 edges.', 'I actually solved this one on my one, granted its one of the easier hard problems (and my code ran pretty slow, beat 28%). However, I originally misinterpreted the question as find the max subtree, not path. Luckily it was literally one line of code difference between the two problems the way I solved it, but its a good reminder to make sure you really understand what is being asked.', ""Here's using nonlocal and also not having to check leftMax and rightMax twice for 0\n\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n\n        res = root.val\n\n        def traverse(node):\n            if not node:\n                return 0\n\n            leftMax = traverse(node.left)\n            rightMax = traverse(node.right)\n            \n            nonlocal res\n            res = max(res, node.val + leftMax + rightMax)\n\n            return max(0, node.val + max(leftMax, rightMax))\n        \n        traverse(root)\n        return res"", 'This one really confused me. Thanks so much for your explanation.', 'I\'ve noticed you tend to do that list by reference trick for primitive values. Python also has built in way to do that, you can declare the variable normally, and then inside the DFS, do ""nonlocal"" res.\n\ndef max_path_sum(root):\n    res = root.val\n    def dfs(node):\n        nonlocal res\n        if not node:\n            return 0\n        etc.....']"
229,BTf05gs_8iU,"['🌲 Tree Playlist: https://www.youtube.com/watch?v=OnSn2XEQ4MY&list=PLot-Xpze53ldg4pN6PfzoJY7KsKcxF1jg&index=2', 'time complexity for search is missing in this video', 'what would be the time complexity of this?', 'I prefer not to mix dfs with for loop.\n\ndef search(self, word: str) -> bool:\n\n        def search(node, pos) -> bool:\n            if pos == len(word):\n                return node.isEnd\n                \n            c = word[pos]\n            if c == ""."":\n                for child in node.children.values():\n                    if search(child, pos + 1):\n                        return True\n                return False\n            else:\n                if c not in node.children:\n                    return False\n                else:\n                    return search(node.children[c], pos + 1)\n\n        return search(self.head, 0)', ""Doing it iteratively isn't too hard, you just need an explicit stack:\n\n    def search(self, word: str) -> bool:\n        stack = [(self.root, -1)]\n        while stack:\n            node, depth = stack.pop()\n\n            if depth == len(word) - 1:\n                if node.isEnd:\n                    return True\n                else:\n                    continue\n\n            char = word[depth+1]\n            if char == '.':\n                stack.extend([(child, depth+1) for child in node.children.values()])\n            elif char in node.children:\n                stack.append((node.children[char], depth+1))\n\n        return False"", 'Wow!!! This is the type of learning I was looking for these many days to learn DSA. Thanks much my dear author :)', 'search function is insane', ""You're good at explaining man! Keep up the good work."", ""yesterday, i didn't know what a trie was\ntoday, i do\n\nthanks neetcode\n\nI should add, I particularly like the trie data structure. It is intuitive and simple, quite easy to follow and implement. A good example of a helpful data structure"", '17:33 , ""we\'re going down a child""\ngod forbid somebody takes this out of context 💀']"
230,GBKI9VSKdGg,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', ""Hi there, can someone explain why the first condition of the second base case is i >= len(candidates)? Shouldn't it be i >= len(candidates) - 1, because i is an index and if it's equal length of candidates it will be out of bounds? I tried changing the condition to this but it obviously didn't work."", ""What doesn't make sense to me in this explanation is why go over the cases where you wouldn't add anything to the array, I think spliting each time between adding and not adding an element is faster and maybe a bit easier to understand for some. I'll leave my solution here if it helps anyone.\n\nclass Solution {\npublic:\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        vector<vector<int>> result;\n        vector<int> subset;\n        DFS(result, subset, candidates, target, 0, 0);\n        return result;\n    }\n\nprivate:\n    void DFS(vector<vector<int>>& result, vector<int>& subset, const vector<int>& candidates, int target, int sum, int index) {\n        if (sum >= target) {\n            if(sum == target) {\n                result.push_back(subset);\n            }\n            return;\n        }\n        for(int i = index; i < candidates.size(); i++) {\n            subset.push_back(candidates[i]);\n            DFS(result, subset, candidates, target, sum + candidates[i], i);\n            subset.pop_back();\n        }\n    }\n};"", 'complexity 2^Target what that mean?\nwhy not 2^n ?', 'All your videos are so helpful but they would be more helpful if you also went into details about the time and space complexities of your solutions.', 'why is ""cur"" an argument here in the helper function, rather than a globally accessible variable. Doesn\'t the former method have much worse efficiency?', '10:00 isnt each value in candidates at least 2? not 1? because on leetcode it says.. 2 <= candidates[i] <= 40 in that does the time complexity change? 2^t/2 ?', 'would anyone be able to help with the time and space complexity of this solution?', ""What's the difference between a subset and a combination?"", 'I am struggling to figure out how to identify if a problem is a backtracking problem, and needs this decision tree treatment. Any help is appreciated!!']"
231,4RACzI5-du8,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'Are you for real? My interviewer gave me 2 hints for 2d dp tf?', 'After watching longest palindromic substring neetcode video came up with this:\n\nclass Solution:\n    def countSubstrings(self, s: str) -> int:\n        res = 0\n\n        def check(l,r):\n            nonlocal res\n\n            while l>= 0 and r < len(s) and s[l] == s[r]:\n                res += 1\n                l -= 1\n                r += 1\n\n\n\n        for i in range(len(s)):\n            check(i,i)\n            check(i, i+1)\n        \n        return res', 'I would tell the interviewer DRY code is not the end all be all. And then dry it.', 'Great explanation but not sure why this is categorized as dp on your website\n\nSame solution as longest palindrome problem (for each index expand outwards to find palindromes)', 'loving blind 75 series, learning a lot', ""I couldn't pass the test case #130 by this way, but all test cases from 1 to 129 passed :("", 'whys this DP', 'awesome', ""You can also use Manacher's algorithm for O(n) and O(n) time space complexity!""]"
232,XKA22PecuMQ,"['💡 LEETCODE PLAYLIST: https://www.youtube.com/playlist?list=PLot-Xpze53leF0FeHz2X0aG3zd0mr1AW_', '// PLEASE SOMEONE HELP ME ,, IT IS NOT PASSING ONE TEST CASE. I AM STUCK FOR MANY DAYS. I HAVE ABOVE AVERGAGE LEETOCODE //SKILLS\n\nclass Solution {\n    public int[] assignTasks(int[] servers, int[] tasks) {\n        Queue<int[]> available = new PriorityQueue<>((a,b) -> a[0] != b[0] ? Integer.compare(a[0],b[0]) :\n         Integer.compare(a[1], b[1])); //weight, index\n        Queue<int[]> unavailable = new PriorityQueue<>((a,b) -> Integer.compare(a[2], b[2])); //weight, index, freeTime \n       if(servers.length >= 56)System.out.println(servers[56] + ""---"" + servers[36]);\n\n        IntStream.range(0, servers.length).mapToObj(i -> new int[] {servers[i], i}).forEach(available :: add);\n\n        int[] result = new int[tasks.length];\n\n        int time = 0;\n        int idx = 0;\n\n        while(idx < tasks.length) {\n            while(!unavailable.isEmpty() && unavailable.peek()[2] <= time) {\n                int[] cur = unavailable.poll();\n                available.add(new int[] {cur[0], cur[1]});\n            }\n\n            if(available.isEmpty()) {\n                time = unavailable.peek()[2];\n            }\n            else{\n                int[] cur = available.poll();\n                unavailable.add(new int[] {cur[0], cur[1], time+tasks[idx]});\n                result[idx++] = cur[1];\n                time++;\n\n            }\n        }\n        return result;\n\n\n    }\n}', 'We can optimize the space complexity further by only storing the time available and the index, and not the weight of the server. We can get knowledge about the weight of the server from the server array.', ""I think there is some little bug with this solution!\nThe heapify won't take the index of two same weight servers as a matter. For example, two servers idx 0 and idx 1 with 5 weight. After heapify they are in order. Let's say idx 0 is used, and then idx1 is used for shorter task. Therefore, idx will be back sooner, and idx 0 will return after that. If they're both on the heap now, who promised that idx 0 will be chosen and not idx1. Idx1 will be chosen is a more probable event."", 'Nice explanation bro!! Though its TLE on leetcode right now.🥲', 'why do we need to advance the time if there none available?', ""I thought the exact same thing but got wrong answer. \nAfter examining I realized what was my mistake:\nWhen there were no free servers, I updated time to the moment when a the topmost server from occupied heap will be free. \nBut when there were free servers, I used to increment time by 1 which is a mistake, because in case time is already bigger then the current index of the task, there is no point increasing it. Because time getting increased by 1 means it might release some more server on the next iteration which was not supposed to be freed at that very moment when the next task was pushed to the queue.\n\nby the way, you don't need to store all those three parameters in the unavailable heap, just store the index of the task, that'll suffice."", 'Hey man, you never let me down! thank you!', 'Just one thing is missing in your live code, heapq.heapify(unavail) after initialization of unavail heap as list! Thank you for simple explanation.', 'Thanks for the awesome explanation! I have one doubt here, why are we using a while loop for popping from the unavailable queue, we can only use  a if and just take out that single server which is free and put it in the available queue, why are we bothered with all the servers that have become free in the unavailable queue, when they are already arranged based on time,weight and index']"
233,s-VkcjHqkGI,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'This is the Claver way to do it as you ask with one loop:\nclass Solution:\r\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\r\n        res = []\r\n        ROW, COLON = len(heights), len(heights[0])\r\n        stack = [] # (row, colon, isPacific)\r\n        visit = [[[False, False] for _ in range(COLON)] for _ in range(ROW)] # [pasific, Atlantic]\r\n        # fill init stack\r\n        for r in range(ROW):\r\n            stack.append((r, 0, True))\r\n            stack.append((r, COLON-1, False))\r\n        for c in range(COLON):\r\n            stack.append((0, c, True))\r\n            stack.append((ROW-1, c, False))\r\n\r\n        while stack:\r\n            row, col, isPacific = stack.pop(0)\r\n            for r, c in [(row, col-1), (row, col+1), (row+1, col), (row-1, col)]:\r\n                inMatrix = 0 <= r < ROW and 0<= c < COLON\r\n                if inMatrix and not visit[r][c][0 if isPacific else 1] and \\\r\n                        heights[row][col] <= heights[r][c]:\r\n                        if not visit[r][c][0 if isPacific else 1]:\r\n                            stack.append((r, c, isPacific))\r\n            visit[row][col][0 if isPacific else 1] = True\r\n            if visit[row][col] == [True, True] and [row, col] not in res:\r\n                res.append([row, col])\r\n                \r\n        return res', 'Can you pls  explain me the syntax for r<0, c<0,r==rows or c==cols or height [r][c] < prev \nfor preventing the visit of all the cells ?', 'As we say in hindi ""feel agya"".', 'For brute force how is the time complexity O((N*M)^2) ? \nHere, we are traversing the whole grid of size N*M. So, the DFS will be called for N*M time. Time complexity of DFS is O(N + 2E). So how it is O((N*M)^2) ?', 'Finals solved this on my own after 3 days lmao.', ""For 'res' you may simply return pac.intersection(atl). Python sets have a built-in method for this ❤"", 'i think you can check if r and c are in range(rows) like you did in another video', ""First Way - Subproblem hint: if heights[row][col] has already been explored during dfs/bfs traversal for let's say current row/column i, j then this information can be saved into a hashmap/dictionary as subproblems. Now during further exploration for let's say new current row/col i', j', if we can again encounter a similar row/column as stored and height[i'][j'] >= height[stored_row][stored_col], then it means this current row can reach both the ocean. \n\nSo basically subproblem is if an island with less or equal height than the current island (to be explored), is able to reach both the ocean, then the current larger island will must be able to reach as well."", 'Thanks Neetcode! One simplification you could do - while calling the dfs() functions, we could simply pass prevheight as 0. Assuming the height would never actually be in negative here']"
234,bXsUuownnoQ,"['💡 GRAPH PLAYLIST: https://www.youtube.com/watch?v=EgI5nU9etnU&list=PLot-Xpze53ldBT_7QA8NVot219jFNr_GI', 'Takes 20.80MB to run...""eFfiCientLY""', 'could also run union-find to check for cycles and then return n - 1 == len(edges) to check for connectedness', ""I don't see where in the problem it says 0 is the root node."", 'Can we use union find to do this  ?', 'Can we do this by union join to Chek for loop and then checking if parent of each node is root to check for connected components??', 'I found out union find can work\nclass Solution:\n    """"""\n    @param n: An integer\n    @param edges: a list of undirected edges\n    @return: true if it\'s a valid tree, or false\n    """"""\n    def valid_tree(self, n: int, edges: List[List[int]]) -> bool:\n        # write your code here\n        id = [i for i in range(n)]\n        self.n = n \n        def find(v):\n            if v != id[v]:\n                root = find(id[v])\n                id[v] = root\n                return root\n            else:\n                return v\n        def union(a, b):\n            rootA = find(a)\n            rootB = find(b)\n            if rootA == rootB:\n                return False\n            else:\n                id[rootA] = rootB\n                self.n -= 1\n                return True\n\n        for a, b in edges:\n            if not union(a, b):\n                return False\n        if self.n != 1:\n            return False\n        return True', 'why are we using it?', 'what is the use of adj list?', ""one testcase doesn't display the desired outcome""]"
235,gqXU1UyA8pk,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'l = 0\r\n        c_frequency = {}\r\n        longest_str_len = 0\r\n        \r\n        for r in range(len(s)):\r\n            \r\n            if not s[r] in c_frequency:\r\n                c_frequency[s[r]] = 0\r\n            c_frequency[s[r]] += 1\r\n            \r\n            # Replacements cost = cells count between left and right - highest frequency\r\n            cells_count = r - l + 1\r\n            if cells_count - max(c_frequency.values()) <= k:\r\n                longest_str_len = max(longest_str_len, cells_count)\r\n                \r\n            else:\r\n                c_frequency[s[l]] -= 1\r\n                if not c_frequency[s[l]]:\r\n                    c_frequency.pop(s[l])\r\n                l += 1\r\n        \r\n        return longest_str_len', 'good explanation', ""why r we taking maxF when the window could be invalid? shouldn't we calculate the maxF after the inner while loop?"", 'when we increment the left pointer we also need to increment the right?', 'The optimization with maxf is so freaking genius! Thanks for taking time to make this. Grateful🙏', 'Its easier to understand the final optimisation, if you simply replace while condition with if condition.  In that case, it simply means that if window_length - maxf > k, its time to shift the window by one position to the right, because you have exceeded the number of replacement you can do in current window.', 'only (windowlen - mostfreqchar[] <= K   )    is sufficient to get idea and write code.... Brilliant. Thanks', 'In worst case, O(n^2)\n???', 'I came with first approach coded it up wrote map[i] instead of map[s[i]] , wasted 5-6 hours 🙂🙂😂']"
236,bNvIQI2wAjk,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'Dude, i was so happy thinking i did by myself, but then i\'ve got ""Time Limit Exceeded"" :(\nthere\'s the code:\nclass Solution {\r\npublic:\r\n    vector<int> productExceptSelf(vector<int>& nums) {\r\n        vector<int> ans;\r\n       \r\n        for(int i=0; i<nums.size(); i++){\n            int val=1;\r\n            for(int j=0; j<nums.size(); j++){\r\n                if(j==i){continue;}\r\n                val *=nums[j];\r\n            }\r\n            ans.push_back(val);\r\n        }\r\n        return ans;\r\n    }\r\n};', 'Does it not break if there is a zero in the middle of the given array?', ""I don't get why this still counts as O(1) when you really created res[]. I was expecting in-place swapping to satisfy O(1) memory space. Can someone explain it to me?"", 'Tried solving this one and was literally timing out of the solution window. I would have never thought of this had I not looked at solutions.', 'Omg dis fookin brilliant mann', ""This is seriously the best and most concise explanation I've seen for this problem."", 'concept of prefix product and postfix product is amazinggg!!<3', 'Worst explanation ever.', 'surely its O(n) space complexity since you still have to create an array for the output?']"
237,gs2LMfuOR9k,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', ""you said that the space complexity is O(1) but shouldn't it be O(h) where h = height of the tree? Because we are using the call stack for the recursive calls."", ""After an hour, I finally did a O(n) solution, and i check NeetCode's video: 6 mins\nMe :  ..."", 'Damnit I solved this using DP and felt good until I saw your insanely short and intuitive solution.\n\nI basically created a path to each node, popped values off the longer path and compared to the top of the shorter path until the path lengths were equal. When they were I popped off each value and compared and as soon as they were equal I returned the node where it was equal.', 'Thank you for the neat explanation. And the code as well.', ""It's amazing how simple and straightforward your solution is!"", ""Why I am getting wrong answer for this Input with code below: \r\n\r\n[3,5,1,6,2,0,8,null,null,7,4]\r\n5\r\n4\r\n\r\nOutput : null\r\nExpected : 5\n\n----------------------------------------  Code  ----------------------------------------------------\n\n\nclass Solution:\r\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\r\n        \r\n        cur = root\r\n\r\n        while cur:\r\n            \r\n            if p.val > cur.val and q.val > cur.val:\r\n                cur = cur.right\r\n\r\n            elif p.val < cur.val and q.val < cur.val:\r\n                cur = cur.left\r\n\r\n            else:\r\n                return cur"", 'are binary trees always like this? such that values on the left are lower and right are higher?', ""what if it's not a BST??"", 'Wow great simple solution']"
238,FdzJmTCVyJU,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤\n\nMeeting Rooms 1: https://www.youtube.com/watch?v=PaJxqZVPhbg', ""wouldn't your solution get stuck in the while loop if start[s] == end[e]? I feel like it is missing a \nelif start[s] == end[e]: \n    e += 1 \n    s+=1"", ""I was asked this question in salesforce internship interview recently. Wasn't able to solve it 😣"", ""This is Klee's Algorithm, right??"", 'Great job', 'any alternative to leetcde and lintcode ?\nAnyone please help.', 'It does not pass this test case : [[1,5],[8,9],[8,9]]', ""I don't have Leetcode Premium so I can't test, but will using the same code from Non-Overlapping Intervals (LeetCode #435) and returning the count val + 1 work here?"", 'can someone explain why we had to track `res, count` both?', 'I was going to use priority queue of end times, and int[] of start times, but your approach using int[] for start and end[] is simpler\n\nMain differences are using a PQ, it sorts as new values are added. No pointers are needed here to manage and no need to create new int arrays']"
239,v1HpZUnQ4Yo,"['This is similar to Jump Game II: https://www.youtube.com/watch?v=dJ7sWiOoK7g', ""Why is the time complexity O(n)? Isn't it also possible for the second `for j` loop to also loop n times? So, together with the first `while` loop, the total time complexity would be O(n^2)."", 'Problem Link: https://leetcode.com/problems/jump-game-vii/', ""**QUESTION:** Why it sufficient to remember only the farthest so far?\nWhat if farthest so far is, let's say 10 but we didn't lend on 9 just yet which could be a node on a path to the target? If we land on 9 the next time (same BFS level, different node) we will reject it as 10 is the farthest so far. \n\nIn a first glance I would expect this algorithm to fail in some scenarios. \nWhy is it working nevertheless? \n\nThanks"", ""Shouldn't line 13 be: `farthest = min(i + maxJump, len(s))` to avoid out of bound like what you did in line 8?"", 'To avoid TLE: furtherest = max(furtherest, i + maxJump)', ""Hi Neetcode , I have been trying to solve this one in a greedy manner like you jump game 1 solution I have been able to solve 137 test cases just the 4 test cases are not passing can you plese tell where I am wrong with my solution.\nclass Solution {\n    public boolean canReach(String s, int minJump, int maxJump) {\n        if(s.charAt(s.length() - 1) == '1') return false;\n        int index = s.length()-1;\n        \n        for(int i = s.length()-1;i>=0;i--){\n            if(s.charAt(i) == '0'){\n                if(i + minJump <= index && Math.min(i+ maxJump,s.length()-1) >= index)\n                    index = i;\n            }\n        }\n        return index == 0;\n    }\n}"", ""I spent two hours trying to solve this with a Monotonic Decreasing Stack.  It's really annoying that you can't go past the last index or else I would have gotten it right away."", 'Fantastic as always ❤️', 'Neet code explains so neatly']"
240,PaJxqZVPhbg,"['Maaan you are amazing!!!', 'I actually got this question during my interview with Meta!', 'Actually most efficient solution is O(n).', ""first of, your explanations are amazing! and q, shouldn't it be, i1.end >= i2.start ?"", 'what if we sort the intervals by ending times? will that work?', ""oh that's how you sort a list of objects"", 'thanks for the lintcode 🔥', ""The description for this question on leetcode is terrible. The examples don't help at all."", 'Thanks man, just wanted to make sure my solution was good, and it was the same as yours. Liked!', 'I ran this code you had in your video, but it did not pass test case [[7,10],[2,4]]']"
241,amnrMCVd2YI,"['thanks man', 'python code for an O(n) solution with O(n) memory complexity. The heap is unecessary\n\n        numcards = len(hand)\n        freq = defaultdict(int)\n        for card in hand:\n            freq[card] += 1\n\n        arr = sorted([x for x in freq])\n        for i in arr:\n            while freq[i]:\n                for j in range(i, i + groupSize):\n                    if freq[j]:\n                        freq[j] -= 1\n                        numcards -= 1\n                    else:\n                        return False\n                        \n        return numcards == 0', ""instead of min heap why don't we use ordered_map in that we won't need any heap ds :)"", ""Wouldn't removing a value from a min heap be log n, because locating the value in the heap would be log n and restructuring the heap would also be log n as well."", 'Here is the cpp version using std::map(TreeMap): \n\nbool isNStraightHand(vector<int>& hand, int groupSize) {\n    if (hand.size() % groupSize != 0) {\n        return false;\n    }\n    \n    map<int, int> m;\n    for (auto i: hand) {\n        m[i]++;\n    }\n    \n    while (!m.empty()) {\n        int key = m.begin()->first; // least element.\n        for (int i = 0; i < groupSize; i++) {\n            if (!m.count(key + i)) {\n                return false;\n            } else {\n                m[key + i]--;\n                if (m[key + i] == 0) {\n                    m.erase(key + i); // remove element if reaches 0.\n                }\n            }\n        }\n    }\n    \n    return true;\n}', 'C++ CODE\n\n\nclass Solution {\r\npublic:\r\n    bool isNStraightHand(vector<int>& hand, int groupSize) {\r\n        if(hand.size()%groupSize!=0)\r\n            return false;\r\n        \r\n        unordered_map<int,int> map;\r\n        priority_queue<int,vector<int>,greater<int>> pq;\r\n        \r\n        for(auto x:hand){\r\n            map[x]++;\r\n        }\r\n        \r\n        for(auto p:map){\r\n            pq.push(p.first);\r\n        }\r\n\r\n        while(!pq.empty()) {\r\n            int first = pq.top();\r\n            for(int i=0;i<groupSize;i++) {\r\n                if(map.find(first+i)==map.end()) {\r\n                    return 0;\r\n                }\r\n\r\n                map[first+i]--;\r\n                if(map[first+i]==0) {\r\n                    if(first+i != pq.top()) {\r\n                        return 0;\r\n                    }\r\n                    pq.pop();\r\n                }\r\n            }\r\n        }\r\n        return 1;\r\n    }\r\n};', 'The O(1) space solution that I came up with which is slower on leetcode (68ms vs 49ms) than this is we just sort the original hand array, and while its length is > 0 greedily construct groups and remove the used elements from the array.', 'In theory a middle value can go to 0 if it is a gap between two groups (not in the group but between the grps).', 'We can solve it in O(n) time using hash-map. Just to pick up a random element first. Then search m-1 element to find the minimum which is an order one operation step two, make a group and deduct the elements from the hash map. \n\nRepeat the above steps until all the elements exhausted. If we cannot exhaust the array, then we can inform the group to return false.', 'I also do think that the snippet i!= minH[0] is not necessary as we can check in the ``for loop`` if the count of that element is 0  or not at that moment if it is 0 we can return false there itself.']"
242,Sx9NNgInc3A,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', '""word dick"" —Neetcode 0:09', 'Is it actually necessary to do this in reverse?', 'You lost me at the dp[5] = false stuff at 8:15', 'Potential reason to use a Trie:\n- narrow down the list of words to iterate over\n\nAs the list of words is considerably small the optimization might be an overkill. However the case where a Trie would make perfect sense is if we were operating on the same set of words but checking different strings.\n\nEg: wordDict = Entire english dictionary (approx. 700K words), checking multiple strings against the same dictionary.', 'Hi, I think the brute force complexities calculated in the first part of the video is not correct. It is going to be exponential. I think it is O(n^n) for the first brute force approach. The reason is that after finding the match of every possible sub-sequence in the dictionary (which takes n^2), you have to find a match for the remainder of the string (which again would take O(n^2)). So overall it takes O((n^2)^(n^2)) = O(n^n). thats what i think. and another sign that O(n^2) is just wrong is that the second brute force approach should intuitively take less time but according to your calculations, it took O(m*n^2) which is more than O(n^2)', 'Bruteforce can be to check for each substring .', 'top-down solution I made after watching this vid since bottom-up felt unintuitive for me.\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        dp = [False] * (len(s)+1)\n        dp[0] = True\n        for i in range(1,len(s)+1):\n            for w in wordDict:\n                if s[i-1:i-1+len(w)] == w and dp[i-1]: dp[i-1+len(w)] = True\n        return dp[len(s)]', 'thank you, i dont see how someone could do this without knowing the solution already', 'well explained! thank you very much good sir']"
243,IsvocB5BJhw,"['💡 DP Playlist: https://www.youtube.com/watch?v=73r3KWiEvyk&list=PLot-Xpze53lcvx_tjrr_m2lgD2NsRHlNO', 'anyone have a memoization python solution?', 'Hi! This is how I did it in JavaScript using the explanation in the video and some improvements discussed in the comments bellow:\nvar canPartition = function(nums) {\n    const total = nums.reduce((acum, curr) => acum + curr,0);\n    if(total % 2) return false;\n    const len = nums.length;\n    const target = total / 2;\n    let dp = new Set();\n    dp.add(0);\n    for(let idx = 0; idx < len; idx++){\n        if(nums[idx] > target) return false;\n        arrayDp = [...dp.values()];\n        for(let idxDp = 0; idxDp < arrayDp.length; idxDp++){\n            let currValue = arrayDp[idxDp] + nums[idx];\n            if(currValue == target) return true;\n            if(currValue < target) dp.add(currValue);\n        }\n    }\n    return false;\n};\n\nIt beats 85% in Runtime and 67.8% in memory.', 'Wowow brother!', ""If we remove the odd sum check at the begining then the following test does not pass (and probably others):\n[1,2,3,5]\nI can't figure out (yet) if this is expected or not"", 'He works so fast', 'why is target considered as 11?', 'Thanks for this explanation! This was definitely an awkwardly worded problem.', 'this solution looks lie 2^n in time ? we are adding all possible subsets. Sure there can be repetition but we still will need be to iterate over all possibilities.', 'The solution you wrote in the end will have 2^N time complexity because you have to generate all the possible subset sums using that method.']"
244,u4JAi2JJhI8,"['🌲 Tree Playlist: https://www.youtube.com/watch?v=OnSn2XEQ4MY&list=PLot-Xpze53ldg4pN6PfzoJY7KsKcxF1jg&index=2', 'thanks for such simple solutions,', 'what is the difference between using a variable with self. vs using a nonlocal variable', 'If you don\'t fall for using in-order traversal, this is quite easy.\nThe only ""hard"" thing was to write a function to compare trees, if you don\'t get it from a platform already. Otherwise, it\'s hard to know if it worked / is correct.\nIn-order traversal DFS will not work, because it will print the smallest (deepest / left-most) nodes first, and even then, it will start with null. Now, the null is ambiguous on decode, unless you do something extra, such as encoding depth or node start.', ""I asked chat gpt it's solution. It wrote a breadth-first search solution first then returned a depth first search solution identical to yours"", ""Since everyone is sharing  their solution, heres mine:\n\ndef serialize(root):\r\n    return '-' if root is None else ' '.join([root.val, serialize(root.left), serialize(root.right)])\r\n\r\n\r\ndef deserialize_rec(s):\r\n    def deserialize_aux(tree):\r\n        temp = tree.popleft()\n        if temp == '-':\r\n            return None\n        n = Node(temp)\n        n.left = deserialize_aux(tree)\n        n.right = deserialize_aux(tree)\n        return n\r\n    return deserialize_aux(deque(s.split(' ')))"", 'Thanks for the explanation! I was close with the serialization except I was using a string and adding in the commas instead of using the "","".join method on an array. I was also pretty stuck on the deserialization since I had not added the ""N"". This video was very helpful.', 'How does it know to switch to nodes.right in the deserialize methodto get the correct right node value?\n\nI can visualize recursion through the tree for nodes.left and nodes.right but this is setting it.', 'Great video just to be specific this is bottom up DFS', 'For deserialization you can use the Iteratable object with Next in python instead of using a global variable\n\n    def deserialize(self, data):\r\n        """"""Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        """"""\r\n        if not data:\r\n            return None\r\n        nodes = iter(data.split(\',\'))\r\n        return self.buildTree(nodes)\r\n\r\n    def buildTree(self,nodes):\r\n        val = next(nodes)\r\n        if val == \'none\':\r\n            return\r\n\r\n        node = TreeNode(str(val))\r\n        node.left = self.buildTree(nodes)\r\n        node.right = self.buildTree(nodes)\r\n\r\n        return node']"
245,FXWRE67PLL0,"['💡 GRAPH PLAYLIST: https://www.youtube.com/watch?v=EgI5nU9etnU&list=PLot-Xpze53ldBT_7QA8NVot219jFNr_GI&index=2', ""So I'm getting ready for an interview and try to find the time complexity. I think he forgot to mention it. In this case the find function is O(logV) because of the line 9, where we assign the grandparent to the current parent, so we shorten the search. Otherwise it works without that line, but then the time complexity would be O(V). So due to it, the time complexity of finding the redundant connection is O(ElogV)."", 'How does this problem have 64% submission rate?', 'This is more like By Size, not by Rank and path compression wastes a cycle by not going to parent first. Also we can use maps/objects instead of arrays for more speed. Here is a JS implementation employing both path compression and ranking:\n```js\r\nfunction findRedundantConnection(edges) {\r\n    const par = {}, rank = {}\r\n    for(let i = 1; i <= edges.length; i++) par[i] = i, rank[i] = 1\r\n    const find = x => par[x] === x ? x : par[x] = find(par[x])\r\n    function union(n1, n2) {\r\n        let p1 = find(n1), p2 = find(n2)\r\n        if (p1 == p2) return true\r\n        if (rank[p1] < rank[p2]) par[p1] = p2\r\n        else if (rank[p1] > rank[p2]) par[p2] = p1\r\n        else par[p1] = p2, rank[p2]++\r\n    }\r\n    for (const [n1, n2] of edges) if (union(n1, n2) === true) return [n1, n2]\r\n}\n```', ""At 12:45: wouldn't your path compression code only shorten the links (up to the root) by 1? For example if we have:\n5 -> 4 -> 3 -> 2 -> 1, where 1 is the root and we call find() on 5. At the end of your find() function, I believe the parent of 5 will be 3, not 1,  is that correct?"", ""You could implement edge compression in the find() function to make it more efficient. If you have a long path parent <- child relationships, it will be slow to find the root of the last child, which you may have to do multiple times depending on the input. But once you've found the root, you can set all the parents along the parent <- child path to the root to simplify the graph so it is quicker to find next time"", 'thanks', 'if would just add - if par[par[p]]: par[p]  = par[par[p]] on row 9.', 'Dang gave me spoilers before explaining the question. :(', ""Excellent video. We don't need to do par[p] = par[par[p]] \nwhile n!=par[n]\n  n = par[n]\nreturn n \nwould suffice too""]"
246,O761YBjGxGA,"['💡 DP Playlist: https://www.youtube.com/watch?v=73r3KWiEvyk&list=PLot-Xpze53lcvx_tjrr_m2lgD2NsRHlNO', 'Another way of wording the dp solution is... (n-1)* dp[n-1][k] represents putting any number but the largest on the right, and dp[n-1][k-1] represents putting the largest number on the right', 'there is an interesting closed form solution using permutations', 'Best explanation!!', ""The reason this works is that that all sticks have unique sizes which makes all the subarrays (without an exception) having only 1 max.\r\nSo, even when we remove 1 max elem from the list; the remaining subarray has exactly the same properties with the initial array (1 max with all subarrays having 1 max again etc.)\r\n\r\nHaving only 1 max always means that there is always 1 element that can be put at the end ->  (n-1, k-1)\r\nwhere as for all non-max elements -> (n-1, k) for the rest of the array\r\n\r\nHaving only 1 max for all subarrays also mean that the problem is the same for all subarrays.\r\n\r\nHOWEVER, if the problem stated that the sizes could be the same. Then, the subarrays wouldn't be unique."", 'FYI, \n2D array solution:\n3340 ms\n\n        mod = 10 ** 9 + 7\r\n        dp = [[0] * (k + 1) for _ in range(n + 1)]\r\n        dp[1][1] = 1\r\n        for i in range(2, n + 1):\r\n            for j in range(1, k + 1):\r\n                if j > i:\r\n                    break\r\n\r\n                dp[i][j] = dp[i - 1][j - 1] + (i - 1) * dp[i - 1][j]\r\n        return dp[n][k] % mod\r\n\n1D array solution:\n2664 ms\n\n        mod = 10 ** 9 + 7\r\n        dp = [0] * (k + 1)\r\n        dp[1] = 1\r\n        for i in range(2, n + 1):\r\n            nextDP = [0] * (k + 1)\r\n            for j in range(1, k + 1):\r\n                if j > i:\r\n                    break\r\n                nextDP[j] = dp[j - 1] + (i - 1) * dp[j]\r\n            dp = nextDP\r\n        return dp[k] % mod', 'TLE even with the DP method', 'Amazing', 'What kind of sadist asks this question in an interview???', ""You can change base case condition to k>n  (there is no way to make k stocks visible if you don't have enough sticks)- half of dp table will be skipped. Besides, when using hashmap it is really slow -(at least in java), better solution would be to use plain array.With that changes recursive solution passes time limit without problem.""]"
247,U2SozAs9RzA,"['💡 BINARY SEARCH PLAYLIST: https://www.youtube.com/watch?v=U8XENwh8Oy8&list=PLot-Xpze53leNZQd0iINpD-MAhMOMzWvO', 'Is this actually required?\nres = min(res, k)\n\nk will be always less than res ryt?', 'Nice drawing brotha', 'Thank you ', 'I love it when his voice goes deep, it makes the problem feel so much more serious 😆', 'A simpler version of implementation. When we find a speed meet the criteria set it as the right bound and keep searching a better one.\n\ndef minEatingSpeed(self, piles: List[int], h: int) -> int:\n        l, r = 1, max(piles)\n        while l < r:\n            m = (l + r) // 2\n            hours = 0\n            for p in piles:\n                hours += math.ceil(p / m)\n\n            if hours > h:\n                l = m + 1\n            else:\n                r = m\n\n        return l', ""No way I'd come up with this on the fly. Definitely just gonna memorize the code lol"", ""class Solution {\r\n    public int minEatingSpeed(int[] piles, int h) {\r\n        Arrays.sort(piles);\r\n        int res=Integer.MAX_VALUE;\r\n        int start=1;\r\n        int end=piles[piles.length-1];\r\n        while(start<=end){\r\n            int mid=start+(end-start)/2;\r\n            if(totaltime(piles,mid)<=h){\r\n                res=Math.min(res,mid);\r\n                end=mid-1;\r\n            }\r\n            else{\r\n                start=mid+1;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    int totaltime(int []piles,int speed){\r\n        int time=0;\r\n        for(int i=0;i<piles.length;i++){\r\n            time=time+(int)Math.ceil((double)piles[i]/speed);\r\n        }\r\n        return time;\r\n    }\r\n} \r\n\n\nthis is my java code i don't know why it is not passing one last test case on leetcode .\n\nInput\r\npiles =\r\n[805306368,805306368,805306368]\r\nh =\r\n1000000000\r\nOutput\r\n1\r\nExpected\r\n3"", 'Thanks! A slight improvement would be to tighten ""l"" (lower bound) to be =math.ceil(min(piles) *  len(piles) / h) since we cannot go better than that', ""You actually don't even need to keep track of result here. When the binary search ends the value at the left pointer should always be the result""]"
248,YPTqKIgVk-k,"['Y cant I do this??\nd = {}\nfor i in nums:\n       d[i] = d.get(i,0)+1\nl = []\nfor  i in nums:\n         If d[i] > = k:\n                 l.apppend(i)\nreturn l', 'Should we consider the input will be always sorted?', 'Cannot believe I figured this on my own, definitely took some time but I was able to figure it out on my own.', ""What I don't quite understand is that when I implemented this solution, the speed and memory is not as efficient compared to my initial solution in \n```\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = {}\n        for num in nums:\n            count[num] = 1 + count.get(num, 0)\n        \n        res = sorted(count, key = count.get, reverse = True)\n        return res[:k]\n\n ```\n\nEven though using sorted() here causing it to be n log n... Can someone explain why this one is appearing to be much quicker than the solution in the video?"", ""The best explanation I've seen! Thank you so much man!"", 'Pretty sure you can use select and partition to do this within O(n)', 'klogn might be better than o(n). good place to stop and verify with your interviewer how does your ""use case"" look like to demonstrate high level understanding of trade-offs.', 'Hard but I loved it', 'Nice algorithm but it looks like it will fail when the nums list is [-1,-1]  which makes c as -1 throwing index out of range exception.', 'This is amazing explanation. Thank you for sharing this video.. Learnt something new today!']"
249,VFskby7lUbw,"['💡 DP Playlist: https://www.youtube.com/watch?v=73r3KWiEvyk&list=PLot-Xpze53lcvx_tjrr_m2lgD2NsRHlNO', 'Still not understand, help!', 'I think the time complexity of brute force will be n! Right?', 'What made you to not check l == r instead go with l > r as the base condition?\nCould you please explain', ""Wouldn't brute force be O(n!) complexity?"", ""Excellent explanation!\nThere is one part which I am not able to comprehend. Why can't we use the caching with subsequence? There are 2^n subsequences, but won't the caching of that subproblems help us?"", 'the most unsatisfying video from neetcode', ""It would be better to understand if this video is like others DP video which draw a grash to run the solution's algorithm , because this is quiet complex to understand, hard to implement how it actually run in my brain"", 'This looks like a variation of MCM. Is my intuition correct?', 'C# Implementation of above code with all test cases passed\n\npublic class Solution \r\n{\r\n    public int MaxCoins(int[] nums)\r\n        {\r\n            List<int> lst = nums.ToList();\r\n            lst.Insert(0, 1);\r\n            lst.Insert(lst.Count, 1);\r\n            int count = lst.Count;\r\n            int[,] dp = new int[count, count];\r\n            return DFS(1,lst.Count-2,dp,lst);\r\n        }\r\n\r\n        private int DFS(int l,int r,int [,] dp,List<int>nums)\r\n        {\r\n            if (l > r)\r\n                return 0;\r\n            if (dp[l, r] != 0)\r\n                return dp[l, r];\r\n            dp[l, r] = 0;\r\n\r\n            for(int i=l;i< r+1;i++)\r\n            {\r\n                int coins = nums[l - 1] * nums[i] * nums[r + 1];\r\n                coins = coins + DFS(l, i - 1, dp, nums) + DFS(i+1, r, dp, nums);\r\n                dp[l, r] = Math.Max(dp[l, r], coins);\r\n            }\r\n            return dp[l, r];\r\n        }\r\n}']"
250,3SJ3pUkPQMc,"['Best Time to Buy and Sell a Stock 1: https://www.youtube.com/watch?v=1pkOgXD63yU', 'This logic is so easy, compare to the solutions on leetcode. I am in awe rn', 'I coded this up in the most complicated brute force way, with top down recursion utilizing memorization lmao. Take a look (it works try it on your own): \nclass Solution {\n\nprivate:\n    vector<vector<int>> dp;\npublic:\n    int strategy(int index, int prev, bool buying, bool selling, vector<int> &prices){\n        if(index == prices.size() || selling && prices[index] == 0 || selling && prev > prices[index]){\n            return 0;\n        }\n        \n        if(dp[index][selling])\n            return dp[index][selling];\n        int maxProfit = 0;\n        \n        if(buying){\n            int buyIndex = -prices[index] + strategy(index+1, prices[index], false, true, prices);\n            int buyNextIndex = strategy(index+1, prev, true, false, prices);\n            maxProfit = max(buyIndex, buyNextIndex);\n        }else if(!buying /*selling*/){\n            int sellIndex = prices[index] + strategy(index+1, INT_MIN, true, false, prices);\n            int sellNextIndex = strategy(index+1, prev, false, true, prices);\n            maxProfit = max(sellIndex, sellNextIndex);\n        }\n\n        return dp[index][selling] = maxProfit;\n    }\n    int maxProfit(vector<int>& prices) {\n        dp.resize(prices.size(), vector<int> (2, 0));\n        return strategy(0,INT_MIN, true, false, prices);\n    }\n};', 'using local minimum approach:\nclass Solution(object):\n    def maxProfit(self, prices):\n        """"""\n        :type prices: List[int]\n        :rtype: int\n        """"""\n        profitsum = []\n        minvv = float(\'inf\') \n        for i in range(len(prices)):\n            minvv = min(minvv, prices[i]) \n            temp = len(profitsum)\n            print temp\n            if prices[i] - minvv > 0:\n                profitsum.append(prices[i] - minvv)\n            if len(profitsum) > temp:\n                minvv = prices[i]\n        return sum(profitsum)', 'Brohhhh !!!\nIt really blows my mind how simple the solution is 🙌', 'I see the future 😋', 'Nice video!\nBTW, the problem is updated now, can you make a video on that?', 'What if the input is 1234567', 'Btw I like your short and clear cut explanation..videos length is small too....thanks...😉', 'Thanks bro....I tried doing everything...but now I can die in peace']"
251,dw2nMCxG0ik,"[""Why is DP[4] = D[4-1] + DP[4-2] + DP[4-3]? I understand if we were to find ways to get to a certain target, the only way we'll be able to get there is by using the elements from the nums array but that doesn't mean they'll all actually sum up to 4 though right? having a hard time wrapping my head around it"", 'class Solution:\r\n    def combinationSum4(self, nums: List[int], target: int) -> int:\r\n        dp = [0] * (target + 1)\r\n        dp[0] = 1\r\n\r\n        for i in range(1, target + 1):\r\n            for num in nums:\r\n                if i >= num:\r\n                    dp[i] += dp[i - num]\r\n        return dp[target]', 'Nice!! Here is an idea -> You can club some problems to have super similar code. It will be better for understanding the concepts! Example: \n\nThe problem in this video is SUPER similar to coin change II. The only change is, here we loop through amount or ""target"" first and then through coins or ""nums"".\nIntuition: If we parse through coins first, we consider every coin only once -> We will miss the unique combination. If we parse through target first, we can consider coins again and again -> We can protect unique combinations count.\n\nTry this code on this problem and it will pass to remember its similarity with coin change II (make sure to change the input params to the function when you run),\n\ndef combinationSum4(self, coins: List[int], amount: int) -> int:\n        dp = [0] * (amount + 1)\n        dp[0] = 1 \n        for i in range(1, amount + 1):\n            for j in range(len(coins)):\n                if i - coins[j] >= 0:\n                    dp[i] += dp[i - coins[j]]\n        \n        return dp[-1]\n\nHere are the set of problems that can use this unbounded knapsack pattern :\n\nCoin change 1, Coin Change 2, Perfect Squares,  Combination Sum 1, 2, 3, 4', 'This can be thought of as a general fibonacci method. Instead of adding the last two, we take an array to determine indices of the previous values to add', 'The initial decision tree explanation was understandable but I got little confused in DP solution-\nwhy is DP[0] = 1 ?\nsince we need to go to the base case, so we need, DP[4] = DP[4-1]+DP[4-2]+DP[4-3]+DP[4-4] ?\nExplanation of the code part .\nCan someone please help me out in this', ""With all due respect I don't think this was the clearest way to explain the transition from top-down to bottom-up approach. I think that part could have been expanded a lot more. I appreciate the content though. Watching other videos and coming back to it helped a lot."", ""One way to explain dp[0] is, it represents the specific case of target = 0, nums = [] -> 1 solution of emptiness -> 0.  It's easier to think about it if you use an array for dp, not a hashmap.  I'm not sure why he says you need a 2D array; 1D is sufficient.  Still, very succinct solution overall, thank you!"", 'Ham unbounded knapsack ka concept use kar sakte hain na', 'Thanks bro thanks a lot, hope you continue this good work :3', 'If anyone wants the C++ code:\nint combinationSum4(vector<int>& nums, int target) {\r\n        vector<unsigned int>dp(target+1,0);\r\n        dp[0]=1;\r\n        for(int i=1;i<=target;i++){\r\n            for(int num:nums){\r\n                if(i-num>=0) dp[i]=dp[i]+dp[i-num];\r\n            }\r\n        }\r\n        return dp[target];\r\n    }\n\nStats: \nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Combination Sum IV.\r\nMemory Usage: 6.7 MB, less than 65.95% of C++ online submissions for Combination Sum IV.']"
252,-RDzMJ33nx8,"['💡 DP PLAYLIST: https://www.youtube.com/watch?v=73r3KWiEvyk&list=PLot-Xpze53lcvx_tjrr_m2lgD2NsRHlNO&index=2', 'First hard problem i solved', 'I really like the transition modelling visualization, Thanks for such brilliant explanantion!', 'Seems like leetcode added some edgecase\ns =\n""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa""\nt =\n""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa""\n\nOutput\n21912870037044994048\nExpected\n654905827', 'It could be even O(s) space. Runtime beats 90% and memory beats 90%:\ndp = [1] * (len(s) + 1)\r\n        for i in range(len(t)):\r\n            newRow = [0]\r\n            for j in range(len(s)):\r\n                if t[i] == s[j]:\r\n                    newRow.append( newRow[j] + dp[j] )\r\n                else:\r\n                    newRow.append( newRow[j])\r\n            dp = newRow \r\n\r\n        return dp[len(s)]', 'slight optimization: Instead of returning 0 if i == len(s), we can return 0 earlier by checking if len(s) - i < len(t) - j, which means that the rest of s is too small for the rest of t.', 'A really easy optimization that can be added is to check if there are enough characters left in s to create t, this can be done as easily as: if len(s) - i < len(t) - j: return 0.\nImproves runtime significantly', 'simple and clear! thanks !!!', 'Hey Navdeep(@Neetcode), just a small suggestion , May be for the sake of future viewers ,you could fix the typo(i + i) in line 14, may be any kind of overlay on video should do i guess', 'Time limit exceeds, you need to do memoization...']"
253,YLesLbNkyjA,"['💡 SIMILAR PROBLEM: https://www.youtube.com/watch?v=zx5Sw9130L0', 'This is the exact same pattern as that histogram rectangle problem', 'In a first place you should show on examples what we should include to sub-array as much numbers as we can to increase Min-Product, unless next number is smaller then smallest of sub-array. So smallest number acts like a baseline of a hill, and traversing with a stack while going down from hill it allows us to just keep track other side of the hill', 'i solved it using segment tree', ""Actually, you should point out: the key to solve this problem is find the firstLeftMinValue and RightMinValue for index i, that's why we use the stack"", 'Neatly done', 'It seems that having duplicated elements with the same value in stack is not useful. It is save to pop it out and put it back as newStart set to the original index. So change the while line condition stack[-1][1] > n to stack[-1][1] >= n will still work. So the stack would be strictly increasing.', 'Unlike most of your videos, the explanation here is not clear.', 'For people coming from largest rectangle in histogram\nbelow code explains the problem \n\nsome modifications help avoid extra loops\n\n# this is my solution which is exactly the same as largest rectangle in histogram\ndef maxSumMinProduct(nums) -> int:\n    # add -1 to the end so that we can avoid extra while loop\n    # for example when computing the last elemenet in nums\n    # which is smallest and hence we will be computing the stack\n    nums = nums + [-1]\n    res = -1\n    stack = []\n    # adding 0 to the pre_comp_sum helps in calculating pre sum \n    pre_comp_sum = [0]\n    pre_comp_sum.extend(pre_comp_sum[-1] + n for n in nums)\n\n    for index, ele in enumerate(nums):\n        if stack and ele < stack[-1][1]:\n            last_index = -1\n            while stack and stack[-1][1] >= ele:\n                last_index, last_ele = stack.pop()\n                new_res = last_ele * (pre_comp_sum[index] - pre_comp_sum[last_index])\n                res = max(res, new_res)\n            stack.append((last_index, ele))\n        else:\n            stack.append((index, ele))\n    return res', ""I've solved dozen of leetcode and watched 3 times more of your solutions but this is the first one that I was unable to understand the problem and then also your explanation. Either it's too confused for me or I need to watch it again on some better day ;)""]"
254,XYi2-LPrwm4,"['💡 DP PLAYLIST: https://www.youtube.com/watch?v=73r3KWiEvyk&list=PLot-Xpze53lcvx_tjrr_m2lgD2NsRHlNO&index=2', 'Thanks!', ""Wouldn't have guessed this was LCS until you mentioned it!"", 'nicely done i am learning through these videos cause I was not able to understand what to dointially no idea what can I do or not just doing hit and rum stuff thanks for this its help me understand what to start with and what kind of concept I would have to keep in tracjk while having something of this caliber it was quite a easy code but without this explanation of your I would never able to understand the the logic how to do .', 'now 72 is a medium problem not a hard', 'For anyone who is interested in the DFS memorization solution(C++) :\n\nint dfs(int i, int j, string word1, string word2, unordered_map<Position, int, hashFunction>& cache) {\n    if(cache.count({i, j})) {\n        return cache[{i, j}];\n    }\n    \n    if (i == word1.size() && j == word2.size()) {\n        return 0;\n    }\n    \n    if (i == word1.size()) {\n        return word2.size() - j;\n    }\n    \n    if (j == word2.size()) {\n        return word1.size() - i;\n    }\n    \n    int distance = 0;\n    if (word1[i] == word2[j]) {\n        distance = dfs(i + 1, j + 1, word1, word2, cache);\n    } else {\n        // cases if we need replace, delete, insert\n        distance = 1 + min(dfs(i + 1, j + 1, word1, word2, cache), min(dfs(i + 1, j, word1, word2, cache), dfs(i, j + 1, word1, word2, cache)));\n    }\n    \n    cache[{i, j}] = distance;\n    \n    return distance;\n}\n\nint minDistance(string word1, string word2) {\n    unordered_map<Position, int, hashFunction> cache;\n    \n    return dfs(0, 0, word1, word2, cache);\n}', 'i am just so happy when i find your video', ""Hi I have a question. I'm confused about why when word1[i] == word2[j] we need to use the diagonal value? How to find this pattern which is crucial to this problem. I'm new to dynamic programming. Hope someone can help. thanks in advance"", 'Can not believe that it has been downgraded to a medium question. I have completely no idea the first time saw it lol.', ""After watching you explanation, me be like - isn't there any hard dp problem on leetcode 🤣""]"
255,8g78yfzMlao,"['Instead of replacing negative integers by 0, we can replace them by n+1, where n=len(A). The algorithm will still work without the condition of checking A[val-1]==0.', ""How tf am I supposed to come up with that logic? I'm no Einstein."", 'It is so much similar to Pigeon Hole algorithm. Correct me if I am wrong', 'Insane', 'Awesome explanation, I made a few modifications\ndef first_positive(nums):\n  \tn = len(nums)\n  \tfor i in range(n):\n    \t\tif nums[i] < 1 or nums[i] > n:\n     \t \t\tnums[i] = n+1\n\n  \tfor i in range(n):\n    \t\tif abs(nums[i]) > 0 and abs(nums[i]) <= n:\n      \t\t\tif nums[abs(nums[i]) -1] > 0:\n        \t\t\tnums[abs(nums[i]) -1] *= -1\n  \n  \tfor i in range(n):\n    \t\tif nums[i] > 0:\n      \t\t\treturn i+1\n\n  \treturn n+1', 'When you modify input, it is not o(1) space', 'How does negative tell us that 2 exists in our input array?', 'The logic used to solve this problem is just insane. I love it ♥ Great explanation!', 'But we are modifing the input , should we do that?', 'i am not able to understand for [1, 2, 0]. can anyone explain']"
256,HLZLwjzIVGo,"['I ended up getting a time limit exceeded for the input: 3288', 'dp = [n] * (n+1) - nice move to fill dp array with maximum values. Thank you!', 'import queue\r\nclass Solution:   \r\n    def numSquares(self, n: int) -> int:\r\n        # Breadth first search for solution, timed out at input 7168\r\n        Q=queue.Queue()\r\n        Q.put((n,0))\r\n        \r\n        while Q:\r\n            currentValue, currentLevel = Q.get()\r\n            start =1\r\n            while start*start<currentValue:\r\n                Q.put((currentValue-start*start, currentLevel+1))\r\n                start += 1\r\n            if currentValue == start * start:\r\n                return currentLevel +1', 'here is Java solution to this problem\nclass Solution {\n    public int numSquares(int n) {\n        int dp[]=new int[n+1];\n        Arrays.fill(dp,n);\n        dp[0]=0;\n        for(int i=0;i<n+1;i++){\n            for(int j=1;j<i+1;j++){\n                int square=j*j;\n                if(i-square<0){\n                    break;\n                }else{\n                    dp[i]=Math.min(dp[i],1+dp[i-square]);\n                }\n            }\n        }\n        return dp[n];\n    }\n}', 'This is graph problem that looking for the shortest path by BFS. If you think it in this way, it will become an very easy problem.', 'This can also be solved using BFS. Can you please do a video of this problem solving using BFS?', ""There's also a bfs based approach to this problem. I think the TC will be the same. Only one extra queue is required. Still the space complexity will be O(n) ig.\nclass Solution {\r\n    public int numSquares(int n) {\r\n        Queue<Integer> q = new LinkedList<>();\r\n        //add visited array so we don't go to values which we have traversed already (similar to dp)\r\n        HashSet<Integer> visited = new HashSet<>();\r\n        int ans = 0;\r\n        q.offer(n);\r\n        while (!q.isEmpty()) {\r\n            int size = q.size(); \r\n            for (int i = 0; i<size; i++) {\r\n                int cur = q.poll();\r\n                if (cur == 0) return ans;\r\n                for (int j = 1; j<=cur/j; j++) {\r\n                    if (!visited.contains(cur-j*j)) {\r\n                        q.offer(cur-j*j);\r\n                        visited.add(cur-j*j);\r\n                    }\r\n                }\r\n            }\r\n            ans++;\r\n        }\r\n        return -1;\r\n    }\r\n}"", ""Fan here. We can also utilize Lagrange's four-square theorem to solve this question.\nclass Solution:\n    def numSquares(self, n: int) -> int:\n        def isPerfectSquare(x):\n            y=int(x**0.5)\n            return y*y==x\n        def isFourSqaure(x):\n            while x%4 == 0:\n                x/=4\n            return x%8==7\n        if isPerfectSquare(n):\n            return 1\n        if isFourSqaure(n):\n            return 4\n        i = 1\n        while i*i<=n:\n            y=n-i*i\n            if isPerfectSquare(y):\n                return 2\n            i+=1\n        return 3"", 'As is, this code is O(n^2), it lacks the square root, but otherwise nice video :) ! I love your thumnails btw they really make the videos enticing and easy to click at imo!', 'This code will give TLE, as  -> for s in range(1, target +1) will get the loop to run 1 extra time, to hit the condition if s*s > target: break, ex: if target is 5, the loop will run for 1, 2, 3 and then break, changing the loop to -> for s in range(1, int(sqrt(target)) + 1): will pass all the tests,  as the 2nd loop for a target of 5 will run only for [1, 2]']"
257,jIaA8boiG1s,"[""Isn't reversing the array O(n) operation internally?"", '1 LINE python solution:\n\n\n\n\n\n\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        return [int(digit) for digit in str(int("""".join(map(lambda x: str(x), digits))) + 1)]', ""I don't get it. I looked up the solutions and everyone did the same thing. Why don't just make a digit? \n\nclass Solution:\r\n    def plusOne(self, digits: List[int]) -> List[int]:\r\n        n = 0\r\n        for digit in digits:\r\n          n *= 10\r\n          n += digit\r\n        n += 1\r\n        op = []\r\n        while n!=0:\r\n          op.append(n%10)\r\n          n = n//10\r\n        return op[::-1]\nIt will have extra space anyways when we want to append the carry (especially in languages like Java where array's length is immutable) \n\n\nI get it maybe the above solution is slightly better for arrays without carry but overall they both have the same worst case time complexity."", 'nice explanation didnt think about reversing the list but now i have that in the toolbag', ""Here's my solution which uses recursion, lmk what y'all think:\n\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        if not digits:\n            return [1]\n\n        if digits[-1] != 9:\n            digits[-1] += 1\n            return digits\n        return self.plusOne(digits[:-1]) + [0]"", 'My Approach (used try-except also didnt need CARRY or REVERSING array):\n\n        i = -1\n        try:\n            while True:\n                if digits[i] != 9:\n                    digits[i] += 1\n                    return digits\n                digits[i] = 0\n                i -= 1\n        except:\n            digits.insert(0, 1)\n            return digits', 'Using recursion, without reversing, & any loop.\nclass Solution:\n    n = 0\n    def plusOne(self, digits: List[int]) -> List[int]:\n        if digits[-1 - self.n] == 9:\n            digits[-1 - self.n] = 0\n            self.n += 1\n            if (len(digits) - self.n) <= 0:\n                digits.insert(0,1)\n            else:\n                self.plusOne(digits)\n        else:\n            digits[-1 - self.n] += 1\n        return digits', 'Using recursion, without reversing, & any loop.\nclass Solution:\n    n = 0\n    def plusOne(self, digits: List[int]) -> List[int]:\n        if digits[-1 - self.n] == 9:\n            digits[-1 - self.n] = 0\n            self.n += 1\n            if (len(digits) - self.n) <= 0:\n                digits.insert(0,1)\n            else:\n                self.plusOne(digits)\n        else:\n            digits[-1 - self.n] += 1\n        return digits', 'Here is my solution without reversing: \n\ndef plusOne(self, digits):\r\n        n = len(digits)\r\n        i = n - 1\r\n\r\n        while i > -1:\r\n            if digits[i] == 9:\r\n                digits[i] = 0\r\n            else:\r\n                digits[i] += 1\r\n                return digits\r\n            i -= 1\r\n        \r\n        return [1] + digits #Denotes carry', 'Check out this solution. Short and succinct:\n\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        for i in range(len(digits) - 1, -1, -1):\n            if digits[i] != 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        digits[0] = 1\n        return digits + [0]']"
258,5hQ5WWW5awQ,"['Thanks Buddy, was able to submit my solution after getting the Explanation', ""Buddy you don't know how much I appreciate you saying that this problem is hard again and again. This is because a lot of times when I'm not able to solve a problem it's extremely demotivating. However, knowing that others are struggling to solve this problem as well gives me some hope."", 'This solution is brilliant because it LAZILY pops unwanted entries from the minHeap. For example, at 16:13, if there were a (100, 4) entry in the minHeap, you wouldn\'t care about it, because it wouldn\'t matter, as it wouldn\'t affect the result for query ""5"", which would be (4, 6).', 'With this code, the heap keeps stale things that have a large value, popping first should reduce the memory used', 'Thanks a lot Neetcode!! These videos make life so much easy.', 'amazing video. this solution beat 100% in Python3', 'Thank You, It helped a lot!', 'Great explanation bro 🔥🔥 you made a hard problem seem very easy, was stuck on it for 1 hr. coded in 5 mins after understanding the intuition', ""Thanks, another great tutorial! Question about the time complexity, wouldn't adding a new entry to the heap be an O(n) operation and so if we start with a heap of size 1 and end of up with a final size of n we will have an O(n^2) total time complexity in the worst case if we have to keep all the intervals in the heap? If so, wouldn't a sorted map structure e.g. with a balanced tree instead of a heap have a better time complexity e.g. similar to the idea used in solving skyline problem?"", 'this is an atrocious question!!']"
259,lJwbPZGo05A,"[""Actually, the reason why it works is simple, and it happens because of two factors.\nFirst, if you moved to some value, and your total sum is greater than zero, then it means, that previous values did bring some value to the outcome. For example, we have gas = [2,3,0] and cost = [0,0,5]. If we take just solely value 3 without 2, it wouldn't be enough to pass the last station, but previous values definitely bring some value to the outcome.\nSecond, if we know, that there's definitely has to be a solution. Then, we may assume, that it has to be the smallest possible value, as I said before it may bring the most value to the result"", 'maximum gas path', 'How will this change if input didn’t say it is guranteed unique solution?', 'Amazing explanation as always.. I totally love your videos and how simple you make them to understand them.', ""I still don't get why we don't need to go back when we reach the last index..."", ""I took a similar approach but one I feel is slightly more intuitive. I would consider this a sliding window approach. If anyone's having trouble with this problem, try out this version.\n\nFirst, create an array called dif, where at each point, dif[i] = gas[i] - cost[i]. What this array tells us is how it affects our gas tank when we're at position i and moving to position i+1. If we see a positive value in dif[i], we know we gain a surplus of gas (because we filled up more than we spent moving forward). If we see a negative value, we know we have a net loss of gas. And if we see a 0, we break even moving forward from i to i+1, and it doesn't impact our gas tank to make this move. \n\nAt this point we can start our sliding window approach. Two pointers, start and end, both point to the first element (i.e. start = end = 0). We also keep track of how much gas we have in our tank as we progress on the road trip; we hold this in a variable called tank, initially set to tank=0 because we haven't filled up any gas just yet.\n\nThe general idea of the loop is: start marks the start of our road trip, end marks the end. Tank holds the total amount of gas we currently have on a trip from start to end. When we can push end forward, we do; when we can't due to lack of gas, we push start backwards, seeking some extra gas. Let's get more specific with how and when we push forward and back.\n\nPushing Forward\nWhen exactly can we push the end pointer forward? When tank + dif[end] >= 0. Why? Because this means that all the gas we have in our tank, when also considering the net cost of moving forward by one position (dif[end]), is enough to move us forward without dipping our tank into the negatives. In other words we have enough gas to progress to the next station on this current trip. So in these cases when we're able to extend the trip, we add the value of dif[end] to the tank and then increment end by 1. Then we try to move forward again... until we run out of gas.\n\nPushing Back\nWe do this when we run out of gas, i.e. where tank + dif[end] < 0. These are cases where, for example, tank was positive but not high enough to make up for the net loss of moving to the next station. So, in such cases, we seek extra gas by moving the start of our road trip backwards. Every time we move start backwards (i.e. decrement start by 1), we then adjust the value of tank by the new dif[start], because this net gain/loss is now part of our overall road trip and affects our gas tank. It's possible that when we move back one spot, we actually lose gas and the tank dips into the negatives. But we just keep pushing start backwards and updating the value of our tank (adding every new dif[start] to tank), until we reach a value where tank + dif[end] >= 0 and we can begin pushing the end pointer forward again. \n\nEnd Conditions\nInevitably, because our only two operations are bringing start backwards and pushing end forwards, start will equal end. If we arrive at this condition by pushing end forward, we know the trip was possible, because we only move end forward when possible. In such a case, tank >= 0, because the last step would have ensured tank + dif[end] >= 0, and then set tank += dif[end]. If we arrive at our end condition from moving start backwards, it means we were seeking more gas. If tank >= 0, it means we found the gas we were looking for, and the trip is possible. If tank < 0, it means we never made up for the necessary gas and the trip is impossible. In short, after reaching the point where start = end, we return the index of start if tank >= 0, and -1 if tank < 0.\n\nWhy does it work?\nI had two concerns with this algorithm, both of which can be dismissed. The first is: when moving start backwards, how do we know it's safe and that we don't accidentally incorporate an impossible path into our route? That is, since we move start backwards and add dif[start] each time, and some of those dif[start] values will be negative, isn't it possible that a section is impossible to pass? This was a little hard to wrap my head around so I may not explain it well, but pretty much it comes down to the fact that we maintain an accurate value in tank for each adjusted start position. When we encounter negative values at dif[start], they push our tank further into the negatives. The only way we can return to pushing end forward is if we find enough positive values at each new dif[start] that we make up for the new loss. For example, if we push start back by 1 and find dif[start] = -50, the only way we'll start pushing end forward again is if we make up for that 50, say by moving start backwards 50 more times and each time finding dif[start] = +1. Positions with a net loss become new blocks until enough surplus gas is found in prior positions to allow us to move past them too.\n\nSecond potential issue that can be dismissed: we start by pushing end forward, then as needed pushing start backwards. What happens if the end and start pointers meet at some index k, but the real starting position is somewhere between index 0 and k? We end the code when start and end meet, and start never has a chance to pass end and inspect those earlier indices because it has essentially been moving backwards from the end of the list the whole time. The reason this is not an issue is because we are told that when a solution exists, there is only one unique solution. By the way this algorithm works, end is only pushed forward if it can be and if the resulting tank value is >= 0. A valid solution to this problem is some starting position where, starting with a tank of 0, a circular route can be made. So if we find a path from some start index to the solution index, we have a contradiction: a circuit can be made from the solution index, but since we can reach the solution index from an earlier index with a tank of at least 0 remaining, then that earlier index would be a second solution. Therefore we know end will never pass a valid solution; it will only ever reach it and stop. \n\nHope this helps!"", 'i am sorry but i didnt understand why did i+1 didnt cause an issue at the last index', 'This makes complete sense, your way of explanation makes this intuitive now, THANK YOU!', 'Simplyyyyy superrrr......\nBtw.. can it be done using sliding window also????', 'what if the diff was [-3,-3,-3,3,2]. the algorithm would return the index of 3 even though the circular root is not possible.']"
260,eDtMmysldaw,"['💡 BACKTRACKING PLAYLIST: https://www.youtube.com/watch?v=pfiQ_PS1g8E&list=PLot-Xpze53lf5C3HSjCnyFghlW0G1HHXo&index=1', 'def splitString(""0090089""):\n\tfor i in range(7-1):\n\t\t#iteration 1\n\t\ti = 0\n\t\tval = int(s[:0+1]) = int(""0"") = 0\n\t\tif dfs(idx=1,prev=0):\n\t\t\t#ignore\n\t\t\tfor i in range(1,7):\n\t\t\t\ti = 1\n\t\t\t\tval = int(s[1 : 2]) = int(""0"") = 0\n\t\t\t\tif 0 == 0-1 #stop\n\t\t\t\ti = 2\n\t\t\t\tval = int(s[1 : 3]) = int(""09"") = 9\n\t\t\t\tif 9 == 0-1 #stop\n\t\t\t\ti = 3\n\t\t\t\tval = int(s[1 : 4]) = int(""090"") = 90\n\t\t\t\tif 90 == 0-1 #stop\n\t\t\t\ti = 5\n\t\t\t\tval = int(s[1 : 5]) = int(""0900"") = 900\n\t\t\t\tif 900 == 0-1 #stop\n\t\t\t\ti = 6\n\t\t\t\tval = int(s[1 : 6]) = int(""09008"") = 9008\n\t\t\t\tif 9008 == 0-1 #stop\n\t\t\treturn False\n\t\t\n\t\t# iteration 2\n\t\ti = 1\n\t\tval = int(s[:1+1]) = int(""00"") = 0\n\t\tif dfs(idx=2, prev = 0):\n\t\t\t#ignore\n\t\t\tfor i in (2,7):\n\t\t\t\ti = 2\n\t\t\t\tval = int(s[2 : 3]) = int(""9"") = 9\n\t\t\t\tif 9 == 0-1 #stop\n\t\t\t\ti = 3\n\t\t\t\tval = int(s[2 : 4]) = int(""90"") = 90\n\t\t\t\tif 90 == 0-1 #stop\n\t\t\t\ti = 4\n\t\t\t\tval = int(s[2 : 5]) = int (""900"") = 900\n\t\t\t\tif 900 == 0-1 #stop\n\t\t\t\ti = 5\n\t\t\t\tval = int(s[2 : 6]) = int (""9008"") = 9008\n\t\t\t\tif 9008 == 0-1 #stop\n\t\t\t\ti = 6\n\t\t\t\tval = int(s[2 : 7]) = int (""90089"") = 90089\n\t\t\t\tif 90089 == 0-1 #stop\n\t\t\treturn False \n\t\t\n\t\t#iteration 3\n\t\ti = 2\n\t\tval = int(s[:2+1]) = int(s[:3] = int(""009"") = 9\n\t\tif dfs(idx =3, prev = 9):\n\t\t\t#ignore\n\t\t\tfor i in (3,7):\n\t\t\t\ti = 3\n\t\t\t\tval = int(s[3 : 4]) = int(""0"") = 0\n\t\t\t\tif 0 == 9-1 #stop\n\t\t\t\ti = 4\n\t\t\t\tval = int(s[3 : 5]) = int(""00"") = 0\n\t\t\t\tif 0 == 9-1 #stop\n\t\t\t\ti = 5\n\t\t\t\tval = int(s[3 : 6]) = int(""008"") = 8\n\t\t\t\tif 8 == 9-1 and dfs(idx = 5+1 = 6, prev = 8):\n\t\t\t\t\t\t\t\t\t#ignore\n\t\t\t\t\t\t\t\t\tfor i in (6,7):\n\t\t\t\t\t\t\t\t\t\ti = 6\n\t\t\t\t\t\t\t\t\t\tval = int([6: 7]) = int(""9"") = 9\n\t\t\t\t\t\t\t\t\t\tif 9 == 8 - 1 # stop\n\t\t\t\t\t\t\t\t\treturn False \n\t\t\t\ti = 6 \n\t\t\t\tval = int(s[3 : 7]) = int(""0089"")= 89\n\t\t\t\tif 89 == 9-1 #stop\n\t\t\treturn False \n\t\ti = 3 \n\t\tval = int(s[:3+1]) = int(s[:4] = int(""0090"") = 90\n\t\tif dfs(idx =4, prev = 90):\n\t\t\t#ignore\n\t\t\tfor i in range(4,7):\n\t\t\t\ti = 4\n\t\t\t\tval = int(s[4 : 5]) = int(""0"") = 0\n\t\t\t\tif 0 == 90 -1 # stop\n\t\t\t\ti = 5\n\t\t\t\tval = int(s[4 : 6]) = int(""08"") = 8\n\t\t\t\tif 8 == 90 -1 # stop\n\t\t\t\ti = 6\n\t\t\t\tval = int(s[4 : 7]) = int(""089"") = 89\n\t\t\t\tif 89 == 90 -1 and dfs(idx = 6+1 = 7, prev = 89):\n\t\t\t\t\t\t\t\t\tif idx == len(s): # yes\n\t\t\t\t\t\t\t\t\t\treturn True\n\t\t\t\t\treturn True\n\t\t\treturn True', ""*slightly* optimized code --> just did a bit more pruning\n\nclass Solution:\r\n    def splitString(self, s: str) -> bool:\r\n        def backtrack(low, lastNum):\r\n            for i in range(low, len(s)-1):\r\n                split = int(s[low: i+1]);\r\n                if (lastNum == '#' or lastNum-1 == split):\r\n                    if backtrack(i+1, split):\r\n                        return True;\r\n            if lastNum != '#' and int(s[low:]) == lastNum - 1:\r\n                return True;\r\n            return False;\r\n        return backtrack(0, '#');"", 'Woow. I strugled a lot with this problem. Super simple explanation, thank you!', 'There is far more optimal solution (O(n^2) time and same space complexity (O(n) ). run a loop until half of the size of the string (min 2 numbers to be consecutive), and build all the string below it with a loop and num -1 each time. concatenate all of them to a one string and compare to the input. If equal you found, if not, -1 if you got into half of size', 'The maximum value of s[:i + 1] exceeds the maximum value of int, so it is wrong to convert s[:i + 1] with int here.', 'wait, on 1:38 how is ""89"" in descending order? 98 is descending, this is in ascending order  ... pls correct me!', ""Why do we need two similar loops? the i and j functions? Also it seems one is iterations of initial value, is that correct? Why can't they be written together?"", 'This gave me 95% efficiency\n---------------------\n    def splitString(self, s: str) -> bool:\r\n        n = len(s)\r\n        def dfs(i, prev):\r\n            if i == len(s):\r\n                return False\r\n\r\n            if prev and (prev - int(s[i:]) == 1):\r\n                return True\r\n\r\n            for k in range(i, n):\r\n                num = int(s[i:k+1])\r\n                if prev is not None and prev - num != 1:\r\n                    continue\r\n                if dfs(k+1, num):\r\n                    break\r\n            else:\r\n                return False\r\n            return True\n\r\n        return dfs(0, None)', 'you deserve way more subscribers!!!']"
261,ahobllKXEEY,"['Feel free to suggest problems or any feedback is always appreciated! 👨\u200d🎓', 'Omg, this problem is more than easy.', 'Can you solve seat reservation manager for an infinite number of seats? Will it change the solution?', 'how would the solution change if they mentioned reserved could be called multiple times even once all seats are full? could you explain the two min heap solution please?', 'Hey man! Thank you for the great content! I just want to ask that at 3:25 you said something about popping from the heap takes O(log(n)), but I believe it should take O(1)? Also, it would be great if you could go over the example input next time, I actually find it harder to understand than the problem than to actually solving it.', ""I can't find this question on leetcode."", ""You know how there's the 100 days of Leetcode. I might need to start doing 100 days of NeetCode :)""]"
262,vRbbcKXCxOw,"['🌳🌲 Tree Playlist: https://www.youtube.com/watch?v=OnSn2XEQ4MY&list=PLot-Xpze53ldg4pN6PfzoJY7KsKcxF1jg&index=2', ""Great video! Isn't the time complexity O(min(P,Q)) where we quit as soon as the smaller tree is deemed unequal to the bigger tree?"", 'Ammmazing. Thank you very much', 'class Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n    \r\n        tree1=self.preOrder(p,[])\r\n        tree2=self.preOrder(q,[])\r\n        if(tree1==tree2):\r\n            return True\r\n        else:\r\n            return False\r\n    def preOrder(self,node,ans):\r\n        if(not node):\r\n            ans.append(None)\r\n            return  \r\n        ans.append(node.val)\r\n        self.preOrder(node.left,ans)\r\n        self.preOrder(node.right,ans)\r\n        return ans\r\n         \nI have done this', 'from collections import deque\r\n\r\nclass Node(object):\r\n    def __init__(self, value):\r\n        self.value = value\r\n        self.left = None\r\n        self.right = None\r\n\r\nclass BinaryTree(object):\r\n    def __init__(self, root):\r\n        self.root = Node(root)\r\n\r\n    def print_result(self, traversal_type, tree_2):\r\n        if traversal_type == ""is_same_tree_recursive"":\r\n            return self.isSameTree_DFS_recursive(self.root, tree_2.root)\r\n        if traversal_type == ""is_same_tree_iterative"":\r\n            return self.isSameTree_BFS_iterative(self.root, tree2.root)\r\n        else:\r\n            print(""Depth type "" + str(traversal_type) + "" is not supported."")\r\n            return False\r\n\r\n    def isSameTree_DFS_recursive(self, p, q):\r\n        if not p and not q:\r\n            return True\r\n        if not p or not q or p.value != q.value:\r\n            return False\r\n        \r\n        return (self.isSameTree_DFS_recursive(p.left, q.left) and self.isSameTree_DFS_recursive(p.right, q.right))\r\n\r\n    def isSameTree_BFS_iterative(self, p, q):\r\n        queue = deque([(p, q)])\r\n\r\n        while queue:\r\n            node_p, node_q = queue.popleft()\r\n\r\n            if not node_p and not node_q:\r\n                continue\r\n\r\n            if not node_p or not node_q or node_p.value != node_q.value:\r\n                return False\r\n\r\n            queue.append((node_p.left, node_q.left))\r\n            queue.append((node_p.right, node_q.right))\r\n\r\n        return True\r\n\r\n\r\n\r\n        \r\n\r\nif __name__ == ""__main__"":\r\n\r\n    tree1 = BinaryTree(1)\r\n    tree1.root.left = Node(2)\r\n    tree1.root.right = Node(3)\r\n\r\n    tree2 = BinaryTree(1)\r\n    tree2.root.left = Node(2)\r\n    tree2.root.right = Node(0)\r\n\r\n    X = tree1.print_result(""is_same_tree_recursive"", tree2)\r\n    print(X)\r\n\r\n    Y = tree1.print_result(""is_same_tree_iterative"", tree2)\r\n    print(X)', 'why is my base case wrong\nif p and q:\n    return p.val == q.val\nelif not p and not q :\n     return True\nelse:\n     return False', 'Iterative version can be achieved with the following concept in mind:\n\nTraverse both trees simultaneously and return False on certain checks. Keep in mind, that two nonidentical trees can have the same traversal output. So there will be another check in addition to comparing values (same concept in this video)', 'the code can be cleaned up a bit, the and & or thing is redundant, just do it like this:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p or not q: return p == q\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)', 'Easiest tree question', ""As usual, I've over complicated when tried to solve it 😅 .""]"
263,EaphyqKU4PQ,"['💡 GRAPH PLAYLIST: https://www.youtube.com/watch?v=EgI5nU9etnU&list=PLot-Xpze53ldBT_7QA8NVot219jFNr_GI&index=2', 'legend', ""Super helpful. Thanks for trudging through Dijkstra's to make it easier for us!"", 'why is this problem not on your 150 list Nav?', 'So it’s like bfs but using priority queue instead of a regular queue?', ""Dijkstra's algorithm is read as /ˈdaɪkstrəz/ DYKE-strəz, not Jikstra's"", 'great explanation', 'An interesting way to pronounce ""Djikstra"" lol', 'Hey, bro!\n\nI am just loving what you do, thanks a lot!\n\nIt will be nice to mention why the order of values in minHeap must be in this exact order(weight, node). Due, to how minHeap in python works, it will order heap objects by the first value(weight). If you place values the other way (node, weight) --> It will work wrong.', ""the course dijkstra's solution was more than sufficient. Thank you \n\nclass Solution(object):\r\n    def networkDelayTime(self, times, n, k):\r\n        adj = {}\r\n\r\n        for n in range(1,n+1):\r\n            adj[n] = []\r\n        \r\n        for s,d,w in times:\r\n            adj[s].append((d,w))\r\n        \r\n        shortest = {}\r\n        min_heap = [(0,k)]\r\n\r\n        while min_heap:\r\n            w1,n1 = heapq.heappop(min_heap)\r\n\r\n            if n1 in shortest:\r\n                continue\r\n            \r\n            shortest[n1] = w1\r\n\r\n            for ne,w in adj[n1]:\r\n                if ne not in shortest:\r\n                    heapq.heappush(min_heap,(w+w1,ne))\r\n        \r\n        return -1 if len(shortest)!=n else max(shortest.values())""]"
264,vgBrQ0NM5vE,"[""Do you have any tips for when to stop looking for a solution with a better complexity? I dismissed a bunch of O(n log n) solutions thinking there's probably an O(n) solution, then gave up in frustration and looked at the solutions, only to find O(n log n) is optimal."", 'Here is the C++ code:\nint maxFrequency(int arr[], int n, int k) {\n        sort(arr, arr+n);\n        int start=0;\n        int end=0;\n        int sum=0;\n        int freq=INT_MIN;\n        while(end<n){\n            sum += arr[end];\n            if(arr[end]*(end-start+1)<=sum+k){\n                freq = max(freq, end-start+1);\n                end++;\n            }else{\n                sum = sum-arr[start];\n                start++;\n                end++;\n            }\n        }\n        return freq;\n    }', ""I came accross so many solution videos for this problem but I didn't understand any of those explanations until it yours. You gave the crystal clear explanation.... thank you so much sir..🙏"", 'We can also do this by creating a frequency map. The approach mentioned in the video can be used but I came up with another appraoch.\n\nCreate a frequency map.\nCheck the answer for last element (max).\nNow come to the second last element. \nNew answer would be the old answer - freq of last element\n+ Now we can move the left pointer by (freq of curr element*diff of last and curr element), basically new k', 'I was not able to come up with that equation. I found the bruteforce way which of course resulted in TLE. Anyway thanks.', 'For some test cases, the total sum will overflow if you are writing the code in Java Or CPP. So int that case use this logic \n\nwhile (nums[r] * (r - l + 1) - total >  k)', 'Java users: use long for total to avoid overflow.', ""I'm a noob and for some reason I feel like it'd be easier to start with the right pointer at index len - 1, does that make sense?"", 'sexy explanation😍!!!!!', 'best explanation... I tried to solve this problem but could not figure out its sliding window']"
265,oobqoCJlHA0,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'Do we have to use trieNode? I used dictionary and had ""None"" to mark if the node is at the end.', 'Excellent explanation', 'What is the worst case time compexity? Is it exponential? If it comes .........', 'What an amazing explanation for the guy who just started learning tries 👍', 'why not just use a dictionary?', ""You legitimately explain these concepts better than any professor I've had, and I went to one of the most highly regarded schools in the US for Computer Science. You outdid both the professors and their teaching assistants.\n\nYou have a gift for explaining this stuff."", 'These videos are literally better than the courses I took in University. Thank you!', 'A more useful and challenging problem would be to return a list of words that starts with a given prefix. Pretty much autocomplete. I’m not sure if that one can be solved iteratively though, I’ve only seen it done recursively.', 'You are the best leetcode teacher on entire YouTube!']"
266,Kkmv2h48ekw,"['This question made no sense until your video explanation was seen', 'One question: why cannot we set countGap = collections.defaultdict(int)?\nI guess the reason is defaultdict is only for nonexistent keys not for nonexistent values. Is that correct?', 'This is just genius, the moment you said to only take the gaps as keys I could figure out the algorithm, things like these helps one to remember the logic behind way quicker. Thanks for the content', ""Sometimes your explanation of problem gives away answer to question - it's too clear. You're taking away our need to practice reaading"", 'initial thought: Maximize count the gaps in the wall of bricks - hashpam<Integer, Integer> key is x, value is number of gaps', 'Ohh man. I tried my level best for this problem passed 78 test cases, spent over 1.5 hrs on this problem. Got time limit exceeded on 79th case. Came here (my fav YouTuber). Now I am laughing after hearing the logic.', 'Liked the video before even watching it. The best channel for competitive coding questions. ❤', 'I think this can also be solved with prefix arrays. Whenever the prefix sum at any position of two arrays are the same, that means drawing a line through them at that position will NOT cut through them. So we just have to see at which position, the prefix sum of the MOST number of arrays is the same, and the answer is the remaining bricks (because we will cut through them)', 'one of the few qns which i liked', 'Amazing content / explanation. Would love to see such kind of explanation to the second part of the ""Lego Blocks"" Hackerrank problem. Only found poor explanations... Anyway, congrats! I\'m following the channel now :)']"
267,keuWJ47xG8g,"['✏️ Have problem suggestions you would like me to solve? Feel free to comment them below :~)', 'Convert the array into non non-decreasing array by replacing elements with its subarray sum if necessary.\r\nfor example,\r\n\r\ninput=[3, 8, 5, 2, 10], output=[3,8,17]  \r\ninput=[1,2,3,4,5],output=[1,2,3,4,5]  \r\ninput=[5,4,3,2,1],output=[5,10]  \r\ninput=[],output=[]\nPlease solve this problem.', 'def addBinary(self, a: str, b: str) -> str:\r\n        a = int(a,2)\r\n        b = int(b,2)\r\n        res = a+b\r\n        return bin(res)[2:]', 'i was  not even able to solve this one is this abnormal ?', 'For converting it to integer, can we not do int(a[i]) and int(b[i]) instead of ord(a[i])-ord(""0"") and ord(b[i])-ord(""0"")?', 'Why not just do bin(int(a, 2) + int(b, 2))[2:] ?', 'we can use the same code for the question : leetcode 413(Add strings),just replace 2 by 10', 'Nice explanation. Did you forget to reverse the result??', 'should be  medium', 'Hello I hava a doubt can we use inbuild function like bin\nclass Solution:\r\n    def addBinary(self, a: str, b: str) -> str:\r\n        return bin(int(a, 2) + int(b, 2))[2:]\n\nthe code works pretty efficiently but is it the right way?']"
268,pfiQ_PS1g8E,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'You are the legend', 'I undertand better with animations  than code.😊', 'Very good solution', 'hey Neetcode my solution is below, it is faster than  78% python submissions, pls check it and tell me how i can improve it..\n\nclass Solution:\r\n    def exist(self, board: List[List[str]], word: str) -> bool:\r\n        \r\n        self.ans = False\r\n        row, col = len(board), len(board[0])\r\n\r\n        def dfs(i, j, index, visited = set()):\r\n            if index == len(word):\r\n                self.ans = True\r\n                return\r\n            b = {(i,j)}\r\n            \r\n            if i-1 > -1 and (i-1, j) not in visited and board[i-1][j] == word[index]:\r\n                dfs(i-1, j, index+1, visited.union(b))\r\n            if i+1 < row and (i+1, j) not in visited and board[i+1][j] == word[index]:\r\n                dfs(i+1, j, index+1, visited.union(b))\r\n            if j-1 > -1 and (i, j-1) not in visited and board[i][j-1] == word[index]:\r\n                dfs(i, j-1, index+1, visited.union(b))\r\n            if j+1 < col and (i, j+1) not in visited and board[i][j+1] == word[index]:\r\n                dfs(i, j+1, index+1, visited.union(b))\r\n            return\r\n        \r\n        for i in range(row):\r\n            for j in range(col):\r\n                if board[i][j] == word[0]:\r\n                    dfs(i, j, 1)\r\n                    if self.ans == True:\r\n                        break\r\n            if self.ans == True:\r\n                break\r\n\r\n        return self.ans', ""For the time complexity analysis,\nI think you can even make it more efficient than that, and that the exponential is a huge upper bound. Because you have a visited set, you can never visit any element more than once. Worst case scenario therefore is that the DFS visits every cell (which probably wouldn't happen multiple times), which is m*n. So I think it is O(m^2n^2). Happy to be corrected"", ""Works like charm 💥\nA minor optimisation that I did is that I only initiate the DFS after I've checked that the current character of the board is mathcing the first char of word\nif word[0] == board[i][j]: dfs\nWon't make a big difference as it will be checked on the first dfs"", ""just a question why are we removing path.remove(r,c) because if we remove it we won't find it in (r,c) in path right"", 'In the solution on the website we have this line ""count = defaultdict(int, sum(map(Counter, board), Counter()))"" can someone walk me through how this works? why does defaultdict have more than 1 argument?', ""It's crazy how simple you make seemingly insurmountable problems look, thank you.""]"
269,WTzjTskDFMg,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'Too bad this doesn\'t work anymore. ""[([]])""', 'I was in the ball park with the hashmap, the stack, and the general idea, but handling the edge cases stumped me. Streamlined your code on my end just to make sure I understand it, thanks!', ""The rules are clear. An input string is valid if : 1) Open bracketes must be closed by the same type of brackets. 2) Open brackets must be closed in the correct order.\n\nA string }() should be valid. Because 1. and 2. are valid. The rules don't say anything about closed brackets needs to have an open bracket."", 'nice and clear explantion', 'I was doing this:\n```\n    def isValid(self, s: str) -> bool:\n        stack = []\n        for c in s:\n            if c in [""("", ""{"", ""[""]:\n                stack.append(c)\n            else:\n                if not stack:\n                    return False\n                if (stack[-1] == ""("" and c != "")"") or (stack[-1] == ""{"" and c != ""}"") or (stack[-1]== ""["" and c != ""]""):\n                    return False\n                else:\n                    stack.pop(-1)\n        return True if len(stack) == 0 else False\n```', 'I would just return ""not stack"". Should be enough.', 'Awesome content.', ""Hello great video but can someone explain why at the line if stack[-1] == closeToOpen we access the last element? Shouldn't the last element be a closing paranthese? Wouldn't that like trying to find an opening paranthese at the end of stack?"", ""Question: what if I do not use hashmap and use the following instead:\n\n        mylist = []\r\n        for x in s:\r\n            if x in '({[':\r\n                mylist.append(x)\r\n            elif x in ')}]':\r\n                if not mylist:\r\n                    return False\r\n                elif mylist[-1] == '({['[')}]'.index(x)]:\r\n                    mylist.pop(-1)\r\n                else:\r\n                    return False\r\n        if not mylist:\r\n            return True\r\n        else:\r\n            return False\n\n''""]"
270,RR1n-d4oYqE,"['One of the hardest ""Medium"" in leetcode.', ""This code is failing this test case for me. I really don't see why\n\nclass Solution {\r\n    \r\n    public int[] getOrder(int[][] tasks) {\r\n        \r\n        int [] result = new int[tasks.length];\r\n        \r\n        Map<Pair<Integer, Integer>, Integer> indexMap = new HashMap<>();\r\n        \r\n        for(int i = 0; i < tasks.length; i++){\r\n            Pair<Integer, Integer> pair = new Pair<Integer, Integer>(tasks[i][0], tasks[i][1]);\r\n            indexMap.put(pair, i);\r\n        }\r\n        \r\n        PriorityQueue<Pair<Integer, Integer>> queue = new PriorityQueue<Pair<Integer, Integer>>((a, b) -> {\r\n            if(a.getValue() == b.getValue()){\r\n                return indexMap.get(a) - indexMap.get(b);\r\n            }\r\n            return a.getValue() - b.getValue();\r\n        });\r\n        \r\n        Arrays.sort(tasks, (a, b) -> {\r\n            return a[0] - b[0];\r\n        });\r\n        \r\n        int index = 0, time = tasks[0][0], taskIndex = 0;\r\n        \r\n        while(!queue.isEmpty() || taskIndex < tasks.length){\r\n            \r\n            while(taskIndex < tasks.length && time >= tasks[taskIndex][0]){\r\n                 Pair<Integer, Integer> pair1 = new Pair<Integer, Integer>(tasks[taskIndex][0], tasks[taskIndex][1]);\r\n                 taskIndex++;\r\n                 queue.offer(pair1);\r\n            }\r\n            \r\n            if(queue.isEmpty()){\r\n                time = tasks[taskIndex][0];\r\n            } else {\r\n                Pair<Integer, Integer> curr = queue.poll();\r\n                result[index++] = indexMap.get(curr);\r\n                time += curr.getValue();\r\n            }\r\n            \r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\n\n[[142,185],[142,74],[669,253],[669,953],[669,694],[669,474],[669,839],[457,87],[457,371],[457,510],[457,691],[457,237],[457,225],[457,413],[457,935],[457,703],[669,709],[669,18],[669,687],[669,911],[669,741],[669,526],[669,900],[669,842],[767,624],[767,802],[287,690],[287,438],[287,406],[287,561],[287,518],[287,769],[287,709],[107,420],[107,277],[107,119],[107,28],[894,373],[894,592],[894,698],[894,947],[894,120],[894,296],[894,429],[894,792],[894,677],[13,6],[13,551],[13,85],[13,930],[13,749],[13,195],[13,629],[13,481],[13,873],[669,324],[669,659],[366,76],[366,385],[366,437],[366,72],[366,518],[366,7],[366,454],[366,382],[366,128],[366,134],[21,824],[21,5],[88,156],[88,331],[88,698],[88,595],[88,403],[380,607],[292,771],[292,323],[292,17],[292,712],[292,202],[292,183],[860,13],[860,632],[860,816],[860,890],[860,179],[860,873],[860,969],[860,960],[860,155],[128,796],[128,582],[128,978],[128,255]]"", ""@neetcode\nI had a doubt on this problem set the whole point was to process the Task in a way that they require less amount of time right??\n\nI have developed a two-pointer solution that fails for the below test case\n\nInput\ntasks = [[19,13],[16,9],[21,10],[32,25],[37,4],[49,24],[2,15],[38,41],[37,34],[33,6],[45,4],[18,18],[46,39],[12,24]]\n\nExpected Output\n[6,1,2,9,4,10,0,11,5,13,3,8,12,7] Total time According to this output is 268\n\nMy Solution Output\n[6,4,10,9,1,2,0,11,13,5,3,8,12,7] Total time According to this output is 238\n\nMy code\n\nBasically, there is one major/incoming queue nextTaskEnqueueTime specifying what would the next task to take and a minor queue which keeps track of\nall the task received in that period when the first task was received and sorted on the processing time so that the CPU can select the next shortest processing time task from it, till this minor doesn't get empty we take the next task it from this queue also while processing we add the task from major/incoming queue\n\nIs my thought process wrong??.. can you please have a look into this .. or anyone else\n\nmy code below \nclass Solution {\n    public int[] getOrder(int[][] tasks) {\n        \n         //Sort based on task processing time.\n        PriorityQueue<int[]> nextTaskProcessingTime = new PriorityQueue<int[]>((a, b) ->  (a[1] - b[1]));\n        // Sort based on task enqueue time & task processing time.\n        PriorityQueue<int[]> nextTaskEnqueueTime = new PriorityQueue<int[]>((a, b) ->  (a[0] != b[0] ? (a[0] - b[0]) : (a[1] - b[1])));\n\n        \n        // Store task enqueue time, processing time, index.\n        int sortedTasks[][] = new int[tasks.length][3];\n        for (int i = 0; i < tasks.length; ++i) {\n            sortedTasks[i][0] = tasks[i][0];\n            sortedTasks[i][1] = tasks[i][1];\n            sortedTasks[i][2] = i;\n            nextTaskEnqueueTime.add(sortedTasks[i]);// store in nextTaskProcessingTime Queue\n        }\n\n        int currTime = 0;\n        int resIndex = 0;\n        int [] result = new int[tasks.length];\n\n        while(!nextTaskEnqueueTime.isEmpty() || !nextTaskProcessingTime.isEmpty()){\n            int sortedSingleTasks[] = null;\n                if(nextTaskProcessingTime.isEmpty()){\n                    sortedSingleTasks = nextTaskEnqueueTime.poll();\n                }\n                else{\n                    sortedSingleTasks = nextTaskProcessingTime.poll();\n                }\n\n                result[resIndex++] =  sortedSingleTasks[2];\n                int i = 0;\n                while(i <  sortedSingleTasks[1]){\n                // while(currTime < sortedSingleTasks[1]){\n                    if( !nextTaskEnqueueTime.isEmpty()){\n                       nextTaskProcessingTime.add(nextTaskEnqueueTime.poll());\n                    }\n                    ++currTime;\n                    ++i;\n                }\n\n        }\n       \n        return result;\n    }\n}"", 'for i, t in enumerate(tasks):\r\n            t.append(i)\r\n        tasks.sort(key=lambda t: t[0])\r\n        res, minHeap = [], []\r\n        i, time = 0, tasks[0][0]\r\n        for _ in range(len(tasks)):\r\n            if not minHeap:\r\n                time = max(time, tasks[i][0])\r\n            while i < len(tasks) and time >= tasks[i][0]:\r\n                heapq.heappush(minHeap, [tasks[i][1], tasks[i][2]])\r\n                i += 1\r\n            procTime, index = heapq.heappop(minHeap)\r\n            time += procTime\r\n            res.append(index)\r\n        return res', 'Very good explanation sir!! I was stuggling to manage the time (specially when the cpu remains in idle state).\nThanks for the explanation.', 'Good', 'Really nice explanation. I was wondering how could we solve this question if cpu is multithreaded', ""How does heapq.heappush know that the array of tasks added to the heap should have its priority based on the task's index since there are 2 values in the array -- [tasks[i][1], tasks[i][2]]?"", 'good one but not intutive tbh i wont be able to come up this edges cases in 30 mins', 'I got this question in an interview with Scale.']"
271,ihj4IQGZ2zc,"['🌲Tree Playlist: https://www.youtube.com/watch?v=OnSn2XEQ4MY&list=PLot-Xpze53ldg4pN6PfzoJY7KsKcxF1jg&t=0s', 'LETS GO! This is the first time I completed a problem by myself where it looks identical to yours, that felt good', 'Woah!\nA really clear elaboration I have ever heard', 'Wtf is this lol. If I get a question like this in an interview, I would just close my computer', 'Man just said: ""preety fun problem"" to my nightmare, this man realy makes the mare go', 'I want to thank you soooo much! The visualizations & level of analysis is exactly what I needed to understand the algorithm-level solution. Your videos are the best!', ""Only thing that is missing from Neetcode's otherwise almost perfect video is the time and space complexity analysis.\nSo is his solution O(n^2) for time (n recur * n item slicing) and also O(n^2) space (n recur * each recur requiring n space?)?"", 'I love the structure of your videos! You do such a good job at explaining the approach and how to go about the problem, that I often am able to figure out the code before you even get to that part. Thanks so much!', 'Really nice explanation. Thanks 👍', 'well explained!!']"
272,dJ7sWiOoK7g,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'Thank You So Much for this wonderful video................🙏🙏🙏🙏🙏🙏', ""I''m having trouble understanding how this is BFS"", 'All your videos are a treasure . Every single one is worth rewatching during interviews. Never ever delete these videos or stop uploading new ones.', 'Crazy. This channel explains coding solutions in the easiest way. It saves my life.', 'Cool idea so is it considered bfs or GrEEdy?', 'this is nuts dawg, who allowed this to exist. im literally shaking and crying rn, wtf.', ""The below code also works :\n\n1.) Traverse the entire nums array. On each i-th iteration, update the farthest_jump to the max of current value of farthest_jump and i + nums[i]\n\n2.) If i is equal to the current jump we have completed the current jump and can now prepare to take the next jump (if required). So we increment the jump by 1 and set curr_jump to farthest jump.\n\n3.) If that's not the case then do not update the jumps variable and the curr_jump variable since we haven't yet completed the current jump.\n\n4.) In the end of the traversal you will get the minimum jumps.\n\nHope this helps :)\n \ndef jump(self, nums: List[int]) -> int:\n        farthest_jump = 0\n        jump = 0\n        curr_jump = 0\n\n        for i in range(len(nums)-1):\n            # Find the Farthest Jump\n            farthest_jump = max(farthest_jump, i + nums[i])\n\n            # it means we have made the jump \n            if i == curr_jump:\n                # Point curr jump to the farthest jump\n                curr_jump = farthest_jump\n                jump += 1\n\n        return jump"", ""I used a Dijkstra's approach to solve the problem, but this is a simpler and quicker answer... wow."", ""Correct me if I'm wrong, but couldn't we solve it by using Dijkstra algorithm? I mean we could create a graph and with this search for the shortest path to the end""]"
273,qYlHrAKJfyA,"['Isn\'t modifying input a bad practice in interviews?\nContext: you added a trailing ""/"" to the path', 'Great explanation', 'simple solution\nstack=[]\r\n        lis=path.split(""/"")\r\n        for items in lis:\r\n            if(items==""..""):\r\n                if(stack):\r\n                    stack.pop()\r\n            elif(items!="""" and items!="".""):\r\n                stack.append(items)\r\nreturn ""/""+""/"".join(stack)', 'iam shsit bro', ""Great explanation as always, I just listen to you explain the problem. By looking at the problem description I wasn't sure I understood all the cases."", '/I/Love/You', ""It'd be much simpler if you split on / and loop over the list and build your stack"", 'amazing explanation', 'So the built-in function .split() come up in my mind, which is a good way to convert string into list, this will help a lot.\nLet\'s still take Neetcode\'s example of the path. If path is ""/../abc//./def/"", then path.split(\'/\') gonna be [\' \', \'..\', \'abc\', \' \', \'.\', \'def\', \' \']. And this is pretty easy to understand the if conditions in Neetcode\'s code.\nclass Solution:\r\n    def simplifyPath(self, path: str) -> str:\n        stack = []\r\n        newPath = path.split(\'/\')\r\n        for c in newPath:\r\n            if c == \'..\':\r\n                if stack:\r\n                    stack.pop()\r\n            elif c != \'\' and c != \'.\':\r\n                stack.append(c)\r\n        return \'/\' + \'/\'.join(stack)', 'Thank you so much for this simple solution. My solution was too complicated and got stuck.']"
274,UcGtPs2LE_c,"['And what exactly happening in for loop \nNew head = cur.next ie 4\nCur.next = none means 3 -> none \nWhat is the value of tail.next ??', 'Why we are doing k=k% length', 'NeetCode is GREAT!!!', 'Good explanation. But, some time can be saved by limiting the explanation of the problem.', 'Best channel on Internet for DS and Algo 🎉 Thanks NeetCode ❤', 'I am the one who like this video for the 500 time', 'Anyone else create a circular LL?', 'Best teacher ever! Thank you :)', 'I THINK THE code is not working', 'why cant we use reversals algorithm on this question?']"
275,VyBOaboQLGc,"[""i'm a fan of your channel.  a small typo i see on line 11: len(encodeMap) -> len(self.encodeMap)"", 'This problem is often encountered at work, I usually use the md5 encryption key to store in a global cache. this example uses a hash map, very similar.', 'str(len(self.encodeMap) + 1)\n\nWe need to add self', 'this is good. but your solution can be optimized, because you work with digits so you have 0-9 and then you move to the bext digit (from 9 you move to 10 from 99 you move to 100 etc...) you can choose different base than decimal such as HEX (base 16 so you have 0-9 and A-F to use) or even better base which is base 64. so your code just needs to convert that serial number to base 16 or base 64 and you get a more optimized solution......', ""I don't know. I thought this was looking for something like a Hoffman Encoding that you are creating a bit stream to actually encode a message. This feels like a cheat."", 'Why did you add 1 to the length of longUrl?', 'How about we save only the part after base in the hashTable to reduce space complexity?', 'hi which language did you use in the google coding interview, was it Python', ""how your getting this power of 10\ni don't understand this"", 'Best approach i must say']"
276,Yan0cv2cLy8,"['Thanks mate, helped me a lot. Easy and very quick', 'May be we should take the range of i from last but one element to compare with goal not upto last element.', 'Thanks for the video! Isn\'t the start of our loop shood be ""len(nums)-2"" instead of ""len(nums)-1""?', 'excellent video. I am learning a lot from your videos. Great work', 'Epic...!\nHare Krishna Dude..!', 'WOW', ""What if n-1 is 0 itself. Would'nt you have to backtrack ex - [2,3,0,1] so i + nums[i] < goal but I can reach there"", 'In the example array [2,3,1,1,4] World but what happen with the greedy solution as you defined when the array is [1,3,1,1,4]?', 'may be we can solve how we solved jump game 2 (window method )if every element in window is 0  or not going out of window return false it would be 2n solution i guess this solution is more intuitive though', 'amazing content']"
277,ZI2z5pq0TqA,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'Thankyou again for this video.. you make all the videos so easy and your explanation skills are amazing!!! Thanks much:)', 'Super Explaintion !!', ""It's really (intuitively) confusing to me after 21:47 that we update the max height AFTER we move the pointer, so we count ourselves!! If the height we're currently calculating *is the max* , we're saying that *the max to the left of it, is itself!*"", 'Spent a bit more than 2 hours doing this one and some O(N ** 2) solution I came with ended up getting accepted. The whole time I was so worried about knowing where each of those gaps of water started and ended, until I looked for the best solution and noticed there was no need to know that, all I had to know was the maximum amount water that could be trapped in the current position. Great explanation.', 'This guy seriously just made a hard problem look so easy', 'My suboptimal o(n) memory solution using the explanation if anyone interested\n\nclass Solution:\n    def trap(self, height: List[int]) -> int:\n        maxleft = [0] * len(height)\n        maxright = [0] * len(height)\n        res = 0\n\n        maxleft[0] = height[0]\n        for i in range(1, len(height)):\n            maxleft[i] = max(height[i], maxleft[i-1])\n\n        maxright[-1] = height[-1]\n        for i in range(len(height) - 2, -1, -1):\n            maxright[i] = max(height[i], maxright[i+1])\n\n        for i in range(len(height)):\n            water = min(maxleft[i], maxright[i])\n            res += water - height[i]\n\n        return res', 'thank you, i understood this', ""I know it doesn't end up mattering but a piece of feedback I thought I'd give on the video, the order in which you explain in the drawing is:\n\n1. Move the pointer\n2. Calculate Volume\n3. Update the leftMax\n\nbut in the actual code,  you:\n\n1. Move the pointer\n2. update the max\n3. Calculate the volume\n\n\nI understand that this doesn't end up mattering in the end, however it can make it really confusing if you can't figure out why that's fine."", ""I don't think `if not height: return 0` is *needed* unless `height` could be `None`? (not allowed on the LC version)""]"
278,5Y2EiZST97Y,"['I really like this problem! Thanks for making these videos to help us all see the algorithms and thought process clearly!', 'Awesome', 'You can use O(1) space for this problem. On pass one, build next links for the new list and establish a two way relationship with the matching node from the second list by using the unused random pointer of list2 to point to list 1. You can also break the next pointer on list1 and use it to point to the list2 node. Then on pass two use those pointers to get to the random node and build the random pointers.', 'I struggled with 3-4 Linked List questions from NeetCode list and watched and learnt from your videos. And finally was able to come up with the solution similar to yours without watching the video. Thank you. Your way of explaining algorithm is effortless. Please make a video on how to explain your thoughts about a question in an interview?', 'Superb Explanation !', ""at 6:00 and line 17, we haven't defined old yet?"", ""There's a O(1) space solution, but seems to require modifying the original linked list"", ""Thanks for the great explanation but I'm confused as to why we can use class objects as dictionary keys? I thought dictionary keys have to be immutable but the Node objects are mutable."", ""I like this solution. but i also like mine :)\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        nodes_to_copy = {}\n        \n        def dfs(node):\n            if not node:\n                return None\n            if node in nodes_to_copy:\n                return nodes_to_copy[node]\n            \n            new = Node(node.val)\n            nodes_to_copy[node] = new  \n            \n            new.next = dfs(node.next)\n            new.random = dfs(node.random)\n            \n            return new\n        \n        return dfs(head)"", ""5:56 what is the 'old' there? where does it come from?""]"
279,6ZnyEApgFYg,"['There is no need to check if level is empty before appending it to the result. The only way our while loop iterates is if the q contains >= 1 nodes. Therefore you are always appending at least a single node to the level list.', 'Hi, how can I implement the same solution using depth first search', 'You are super talented to explain such complex stuff in a soo easy-to-understand way... This is amazing', 'You are the legend maaaan', 'In the deque, I firstly thought if the left most element is popped, the index 0 will be automatically assigned to the second element, then the for loop will make no sense. It was just my misconception in my imagination, don’t know why I thought like that.😅', 'I think it’s worth noting that with a binary tree, it’s more ideal to recursively feed the next left node through before moving on the right as a means of BFS. Given that this is the algo for any n tree though, I’m also seeing the benefit of prioritizing this approach.', '5:49 not a bst', ""Hi,\n\nHow Leetcode executes program with default tree definition and other default definations?\n\nI mean on local machine we define Tree class & initiate it's instance then we call the method with instance name & arguments. \n\nHere, w/o creating instance & w/o providing values how does it work?\n\nHow to run this code on local machine without full code.\n\nPlease guide me on this."", 'Hey, great explanation! Just a correction for what was mentioned at 6:17 : the biggest level can have at most (n+1)/2 nodes, and not n/2. This leads also to O(n) space complexity, so it does not make the final analysis wrong :)', 'ooo I got the BFS part but really the key to the problem is to know when each level ends thanks']"
280,Ua0GhsJSlWM,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', ""How it's possible to come up with such elegant solution directly at the interview without being genius and seeing the problem for the first time? )))))))"", ""Hi, Great video. There is one improvement in terms of space complexity. You really don't need to cache all that table. You just need the three values of dp[i+1][j] , dp[i][j+1] and dp[i+1][j+1]   you can update these values as you go up and that's it. you dont need more memory. I thought it might be helpful to add it."", 'To be honest most of the times you dont explain things in this video, you just tell us ""what"" to do but not ""why"" you do it, this problem is not really intuitive', 'i think this is easy to do after learning the solution but there was no way I would be able to figure out the solution myself', 'sub swe hquence', 'I am just starting leetcode and am at about 15 problems only. Please share how many problems you guys have done and some strategies that might be helpful.', 'Thank you 😍😍😍😍', 'i have two question\n1. is it posible if size of J is more than size of I ?\n2. what the LCS of this quest, if I = [a e d a b] and J = [d e b c a g] ? [e d a b] or [d e b a] ?', 'let M = len(text1), N = len(text2). since updating our dp array only depends on the bottom, right, and diagonal, we can optimize this to O(min(M, N)) space']"
281,99RVfqklbCE,"['Can you also cover the follow up question for this problem please?', 'Awesome explanation', 'instead of if else in return statement, write \nreturn i == len(s)', 'Thank you NeetCode. One can just return `i == len(s)`', 'this man is a hero', ""but wouldn't the while loop keeping looping endlessly if i is never incremented?  because your'e only incrementing i if s[i] = s[j]. what if it never equals ?"", 'DP solution:\nIt is easy to think of this if you finished 10. regular expression matching.\n\ndef isSubsequence(self, s: str, t: str) -> bool:\r\n        if len(s) > len(t):\r\n            return False\r\n        \r\n        dp = [[False] * (len(t) + 1) for _ in range(len(s) + 1)]\r\n        \r\n        for j in range(len(t) + 1):\r\n            dp[len(s)][j] = True \r\n        for i in range(len(s) - 1, -1, -1):\r\n            for j in range(len(t) - 1, -1, -1):\r\n                match = s[i] == t[j]\r\n                if match:\r\n                    dp[i][j] = dp[i + 1][j + 1]\r\n                else:\r\n                    dp[i][j] = dp[i][j + 1]\r\n        return dp[0][0]', 'Thank you so much I was able to write my own Java code by using your logic', 'This one killed me  for some stupid reason -.-', 'Thank you very much!']"
282,rWAJCfYYOvM,"['Dynamic Programming Playlist: https://www.youtube.com/watch?v=73r3KWiEvyk&list=PLot-Xpze53lcvx_tjrr_m2lgD2NsRHlNO&index=1', 'Instead of calling the helper function twice \nWe can call it once passing all the array elements except first and last index \nThen return Max (arr[0]+helper function output ,arr[last]+helper function output) \nThis allows not to loop over 2 times', 'you are the best teacher for data structure and algorithms , all over the youtube', 'I would just add by means of explaining why we leave one out - when we remove an element, the ""circle"" of houses becomes a line of houses, reducing the house robber 2 problem to the house robber 1 problem.', 'i could solve the house robber one but I was not able to see this small observations to solve the second one. (EMOTIONAL DAMAGE !!!!)', ""Great solution but the space complexity would be O(n) I expect since you're passing two new arrays to the function. The new arrays will be referencing the original array but they still need space n nonetheless. It would be O(1) if you pass the index instead."", ""I'm so stupid!.such a simple idea,wasted 30min on trying and got nowhere.😭😭"", 'U just nailed it man🔥', ""I figured out house robber 1 on my own but couldn't figure this one out without looking at the solution. I feel dumb lol"", 'java solution is here \nclass Solution {\n    public static int robsum(int[] nums,int start ,int n){\n       int rob1=0,rob2=0;\n        for(int i=start;i<n;++i){\n            int temp=Math.max(rob1+nums[i],rob2);\n            rob1=rob2;\n            rob2=temp;\n        }\n        return rob2;\n    }\n    public int rob(int[] nums) {\n        \n        int sum1=0,sum2=0;\n       //for a single element it would be answer itself\n        if(nums.length==1){\n            return nums[0];\n        }\n       sum1=robsum(nums,0,nums.length-1);\n        sum2=robsum(nums,1,nums.length);\n        return sum1>sum2?sum1:sum2;\n    }\n}']"
283,fISIuAFRM2s,"['💡 GRAPH PLAYLIST: https://www.youtube.com/watch?v=EgI5nU9etnU&list=PLot-Xpze53ldBT_7QA8NVot219jFNr_GI&index=2', 'Done thanks\nTrivial, do a dfs and for each node count the edges it contributed to the perimeter. 1:30\nA node’s sides that are connected to water or the edge of the grid contribute to the perimeter, the sides of a node that are connected to another node don’t count as perimeter. Add all the sides that are connected to water or edge', ""On Line 12 : Why you didn't added perim += dfs(i, j + 1) ?"", ""On Line 12 : Why you didn't added perim += dfs(i, j + 1) ?"", 'Walking around the border should give an O(m+n) algorithm, except for the step of finding the starting point.', 'So my first resolution is set a global variable called"" res"", then I res += 1, but the error is list out of range, if someone has the same error with me, please let me know.', 'Great video, but the time complexity is not really O(m*n) here. Each block of water, surrounded by three land blocks would be checked thrice.', 'Very helpful video! Can you solve coloring a border problem?', 'You can do it O(N) in a single pass without DFS but the fastest way would probably be to use a Bayesian searching algorithm to find a square of land, then find an edge and use DFS or recursion to find and travel and record just the perimeter of the island', 'W teacher. Thanks!']"
284,nHR8ytpzz7c,"['🌲 Tree Playlist: https://www.youtube.com/watch?v=OnSn2XEQ4MY&list=PLot-Xpze53ldg4pN6PfzoJY7KsKcxF1jg&index=2', 'beautiful', 'Thanks! very great explanation!', 'It is incredible how comprehensible and organized your explanations and solutions are. Thank you so much!', 'It did not pass for me. I copied it exactly but does not pass :( \nclass Solution:\r\n    def rob(self, root: Optional[TreeNode]) -> int:\r\n        # return pair: [withroot, withoutroot]\r\n        def dfs(root):\r\n            if not root:\r\n                return [0, 0]\r\n\r\n            leftPair = dfs(root.left)\r\n            rightPair = dfs(root.left)\r\n\r\n            withRoot = root.val + leftPair[1] + rightPair[1]\r\n            withoutRoot = max(leftPair) + max(rightPair)\r\n            \r\n            return [withRoot, withoutRoot]\r\n        return max(dfs(root))', 'This approach is giving TLE in C++', 'recursion makes problems easy af', 'Great Explaination. Loved it. Have been watching your videos for the past 2 months. This explaination forced me to do away with my laziness and comment.', 'you are making it more complicated. You also draw too much and  say tooooooo much. provide the idea first, then try to explain. This will make sense then. Otherwise, you are just trying to explain without giving how to do it and at last you tell this is the way you  do it. That is not helping at all.', ""This playlist is absolute gold. Don't know what I will expect in DP and Graphs.""]"
285,bkxqA8Rfv04,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'To avoid the -1 or 0 definition, one can build a graph based on the tree. Finding a path based on a graph is pretty intuitive. The process of building a graph based on a tree is mechanical. So, it is easy after some practice.', 'Here\'s a simple solution that i commented through to walk others that are stuck through what each line or lines of the code do, this one is way simpler and more intuitive\n\nclass Solution:\n    def calc_height(self, root):\n        """"""This function will calculate the height given a binary tree""""""\n        if not root:\n            return 0\n        # get the left subtree height\n        lheight = self.calc_height(root.left)\n\n        #get the right subtree height\n        rheight = self.calc_height(root.right)\n\n        #the height will be the maximum between the left and right subtree then + 1 since we\'re at the root node and need to consider the edge connecting the subtrees\n        return max(lheight, rheight) + 1\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        """"""This function will calculate the diamater of a binary tree""""""\n        if not root:\n            return 0   \n        #heights of l and r:\n        lheight = self.calc_height(root.left)\n        rheight = self.calc_height(root.right) \n\n        #now get the diameters\n        ldiam = self.diameterOfBinaryTree(root.left)\n        rdiam = self.diameterOfBinaryTree(root.right)\n\n        #finally, compare the diameter calculation in two ways:\n        # 1. either the diameter is SIMPLY the heights for btoh the subtrees added together\n        # 2. or in the more complex case the highest diameter is found within the subtree so we have to calculate the l diameter and r diameter for each subtreee\n        return max(lheight+rheight, max(ldiam, rdiam))', 'how is this an easy problem?', 'this is definitely not an easy problem', 'Thanks for the video. But what a brainfuck. I wonder if anyone really enjoys solving these.', 'What app are you using to draw on screen?', ""Also you don't have to do -2 operation if you use depth instead of height (I'm not sure if these are two same terms). Then depth of Null-node is 0, and depth of Node with no children is 1 (and so on). So in this way you have to only sum 2 depth. Code here:\n\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        res = 0\n\n        def dfs(root: Optional[TreeNode]):\n            if root is None:\n                return 0\n\n            left_depth = dfs(root.left)\n            right_depth = dfs(root.right)\n\n            nonlocal res\n            res = max(res, left_depth + right_depth)\n\n            return 1 + max(left_depth, right_depth)\n\n        dfs(root)\n        return res"", 'can someone explain why, res has to be a list?', 'I am beginning to feel the power of recursion. Initially, the concept looked complex and non-intuitive compared to iterative approach. But now it makes more sense to use recursion to solve tree problems once you understand that solving a subproblem is enough and after that the recursion takes care the rest of the tree.']"
286,LN7KjRszjk4,"['Thank you for the great explanation', 'can someone please write the cpp code for the same ....?', 'Amazing explanation !', 'This is God stuff _/\\_', 'Bhai itna shi smjhate ho YouTube pe kyu nhi pdaye😅', 'Is this a monotonically decreasing stack?', 'Thank you brother', 'precise and clear', 'Thank you for your wonderful explanation', 'Your explanation is extremely clear. Hope to have a colleague like you very much in the company.']"
287,0snEunUacZY,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', ""I don't see how this is backtracking as we are not doing any .pop()?"", ""I don't understand why the time complexity is N * 4^N yet. Can someone explain it?"", 'Each backtracking, seems like the solution is copying the entire string again and again. So its O(n*4^n) ?\n            for char in digit_map[digit]:\r\n                curr.append(char)\r\n                recur(i+1, curr)\r\n                curr.pop()\n\nthis would be better like other backtracking solution. Perhaps this question was done before the other questions', 'Earlier, Backtracking was nightmare for me. Now, It is easier than any algorithm I have learned till now.', ""I'm finally getting backtracking algorithms in < 20m :-.) maybe I'll actually be able to get a job, tysm Leetcode king"", 'I am curious where is the backtracking part of this question 🤔', ""I'd suggest putting this as the first problem in your backtracking list on neetcode list as its the most straightforward I think"", 'Can someone please explain why we should use\nbacktrack(i+1,curStr+c) \xa0\ninstead of\xa0\nreturn backtrack(i+1,curStr+c) in the recursive function?😭', ""plz don't stop""]"
288,5LUXSvjmGCw,"['""While cur and stack"" but isnt stack originally empty so that loop shouldnt execute?', 'Small correction: at 9:45 the while loop does execute, but only once, thus adding the current node to the stack but not anything else.', ""The solution won't work for all cases. You need to replace and with or in the first while condition"", ""while satck 'or' cur not 'and'"", 'here is a recursive solution in javascript:\n\nvar kthSmallest = function(root, k) {\n    // place in order, return(k - 1)th index\n    return inOrder(root)[k - 1];\n};\n\nvar inOrder = (root) => {\n    if (root === null) {\n        return [];\n    }\n    if (root.left === null && root.right === null) {\n        return [root.val];\n    }\n    return inOrder(root.left).concat(root.val).concat(inOrder(root.right));\n};', 'which will be better doing this recursively or iteratively ???', 'Recursive approach with O(1) space\n\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        counter = 0\n        ans = 0\n        def dfs(root):\n            nonlocal counter\n            nonlocal ans\n            if not root:\n                return\n            dfs(root.left)\n            counter+=1\n            if counter == k:\n                ans = root.val\n            dfs(root.right)\n        dfs(root)\n        return ans', '# Easiest one. keep traversing left. add val and then go right\nclass Solution:\n    def kthSmallest(self, root, k: int) -> int:\n        res = []\n        def inorderTraversal(root):\n            if root is None :\n                return None\n            inorderTraversal(root.left)\n            res.append(root.val)\n            inorderTraversal(root.right)\n\n        inorderTraversal(root)\n        return res[k-1]', 'May be most confusing tutorial I have even watched your videos.\nSorry', 'You can also count the nodes in order. Once you reach k you stop.']"
289,s9fokUqJ76A,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', ""Most of your explainer videos are really great and clearly explain the solution. But unfortunately the middle part of this where you're doing the tree diagram is pretty difficult to follow. Kind of incomprehensible sadly. I'd love to see you re-do this video but take a clearer approach to explaining whats going on."", 'Great Video! thanks for explaining this in a such easy way but \ncan u explain why we need the latter pop ?', 'i agree that this should be in the backtracking category', ""It's a backtracking problem, not a stack. Pls move it to appropriate section and update solution - not to use Stack as it's more confusing. Thanks!"", 'Great explaination', ""@NeetCode please move it to backtracking section, it's very puzzling otherwise"", 'one thing i dont get that, how come this algorithm is making sure that each possible combination will start from ""("" and not "")"" ????', 'Btw, the singular of parentheses is parenthesis. Just think thesis/theses, hypothesis/hypotheses, etc.', ""what will be it's time complexity and space complexity?""]"
290,4sQL7R5ySUU,"['💡 BINARY SEARCH PLAYLIST: https://www.youtube.com/watch?v=U8XENwh8Oy8&list=PLot-Xpze53leNZQd0iINpD-MAhMOMzWvO', 'class Solution:\r\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\r\n        def binSearch(leftBias):\r\n            l, r, i = 0, len(nums)-1, -1\r\n            while l<=r:\r\n                mid = (r+l)//2\r\n                if target > nums[mid]: l = mid + 1\r\n                elif target < nums[mid]: r = mid - 1\r\n                else:\r\n                    i = mid\r\n                    if leftBias: r = mid - 1\r\n                    else: l = mid + 1\r\n            return i\r\n        return [binSearch(True), binSearch(False)]', ""can some one tell me why can't i use this:-\n\nclass Solution:\r\n    def searchRange(self, nums: List[int], target: int) -> List[int]:\r\n        for i in nums:\r\n            if target not in nums or len(nums)==0:\r\n                return [-1, -1]\r\n         \r\n            elif target in nums:\r\n                return [nums.index(target), len(nums) - 1 - nums[::-1].index(target)]\n\n\nAnd also this doesn't satisfy the Case 3:-\n\n\nInput: nums = [], target = 0\r\nOutput: [-1,-1]\n\nPlease tell me why ....."", 'sexy', 'Initially what I did is finding the element through binary search and then iterating left and right to find leftmost and rightmost. But now I realized in worst case that would be O(N).\nThanks a ton for this video!', ""My first approach was binary search and it unfortunately didn't worked and had to switch to linear search and it worked just fine after a few tries with using few conditions and Boolean. And for some reason it was better than 100% java submissions for time complexity."", 'My solution:\n public class Solution {\r\n    public int[] SearchRange(int[] nums, int target) {\r\n       int[] res = {-1, -1};\r\n       if(nums.Length == 0) return res;\r\n       int l = 0;\r\n       int r = nums.Length - 1;\r\n       while(l<=r){\r\n           int mid = (l+r)/2;\r\n           if(nums[mid] <= target) l = mid + 1;\r\n           else r = mid - 1;\r\n       }\r\n       if(r>= 0 && nums[r] == target)\r\n       res[1] = r;\r\n       l = 0;\r\n       while(l<=r){\r\n           int mid = (l+r)/2;\r\n           if(nums[mid]>=target) r = mid-1;\r\n           else l = mid + 1;\r\n       }\r\n       if(l<nums.Length && nums[l] == target)\r\n       res[0] = l;\r\n       return res;\r\n    }\r\n}', ""isn't the time complexity O(log(n^2))"", ""Hi I am getting an error SyntaxError: 'return' outside function can you please suggest what to do?"", 'solved it myself; here to compare and improve :)']"
291,QHH6rIK3dDQ,"['Tree Question Playlist: https://www.youtube.com/watch?v=OnSn2XEQ4MY&list=PLot-Xpze53ldg4pN6PfzoJY7KsKcxF1jg&index=1', ""can someone explain how this incorporates DFS? i understand how it works but it doesn't use the dfs function itself right?"", ""it's very easy but my teacher make it complicate, thank's for video"", 'How many of you are from india', ""Here is a functional extension to an arbitrary number of trees to be merged. It makes the code a bit cleaner, at the cost of changing the function signature. The main idea is using map and getattr to clean things up:\n\nclass Solution:\n    #def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:  \n    def mergeTrees(self, *args: Optional[List[TreeNode]]) -> Optional[TreeNode]:\n        \n        # base case, all the trees are empty. return none\n        if not any(args):\n            return None\n        \n        # get all of their values and sum them to make the new base node\n        vals = map(lambda r: getattr(r, 'val', 0), args)\n        root = TreeNode(sum(vals))\n        \n        # merge the left subtrees\n        root.left = self.mergeTrees(*map(lambda r: getattr(r, 'left', None), args))\n        # merge the right subtrees\n        root.right = self.mergeTrees(*map(lambda r: getattr(r, 'right', None), args))\n\n        # return the new, merged tree        \n        return root"", 'Hey guys, check out this COOL O(1) space solution:                   \ndef dfs(self, x, y, pary,parx):\n        if not x and not y:\n            return\n        \n        if x and y:\n            x.val = x.val+y.val\n            self.dfs(x.left,y.left,y,x)\n            self.dfs(x.right,y.right,y,x)\n        elif x or y:\n            if y:\n                if pary.left==y:\n                    parx.left = y\n                else:\n                    parx.right = y\n    \n    def solve(self, A, B):\n        if not B:\n            return A\n        if not A:\n            return B\n        self.dfs(A,B,None,None)\n        return A', 'WOW i never thought about doing an if statement inside the traversal parameters lol', 'For me, I won\'t easily think of the base case of ""if not root1 and not root2"". probably should be like this, and it will reduce so many judge conditions:\ndef mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\r\n        if not root1:\r\n            return root2\r\n        if not root2:\r\n            return root1\r\n        v1 = root1.val\r\n        v2 = root2.val\r\n        root = TreeNode(v1 + v2)\r\n        root.left = self.mergeTrees(root1.left, root2.left)\r\n        root.right = self.mergeTrees(root1.right, root2.right)\r\n        return root', 'Why isn’t the time complexity Max(m,n)?', 'I think the statement ""You need to merge the two trees into a new binary tree"" does not mean creating a separate tree. So the below should work:\n\ndef mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root1:\n            return root2\n        if not root2:\n            return root1\n\n        root1.val += root2.val\n        \n        root1.left = self.mergeTrees(root1.left, root2.left)\n        root1.right = self.mergeTrees(root1.right, root2.right)\n        return root1']"
292,KT1iUciJr4g,"['If you\'re updating the tail variables each time in the loop, how does the ""left"" dummy node get updated? Like I don\'t understand how you just returned ""left.next"" without doing anything to ""left"" in the while loop.', 'Such a great explanation.', 'I was trying to manipulate the pointers in the list and found it sooooo convoluted, you made the problem look like it was an easy level linked list question', 'we are creating only two new node and we are assinging its next to original linked list so space complexity is  0(1)', 'Another way: find large elements and move to the end one by one', 'How it is  o(1), can anyone tell me?', '❤', 'Those who are saying that Space complexity here is O(N).Try to look into his code. If he would be using O(N) space, then he would be making new node for every iteration of while loop. but in reality he has only made 2 node which are dummy node (left,right) so overall space complexity is Constant O(1).', 'your explanations are always the best, i view the algorithm and understand it well enough to implement myself', 'made it very easy wasted 1 hr on my approach !!!!!']"
293,HAA8mgxlov8,"['Dynamic Programming Playlist: https://www.youtube.com/watch?v=73r3KWiEvyk&list=PLot-Xpze53lcvx_tjrr_m2lgD2NsRHlNO&index=1', 'Does anyone know why does the solution run into max recursion depth problem if I set the condition as : (dfs(i+1, j) and match) or dfs(i, j+2) for the dfs call instead of : dfs(i, j+2) or ((dfs(i+1, j) and match))  (I switch the order of the recursion call) 🤔', 'the question description feels really incomplete without your explanation , thanks a lot', 'If there is one thing which I am not sure is how will the subproblems repeat. If anyone has any intuitive way, pls let me know.', 'You make hard problems very easy. Thanks for explaining.', 'I think the time complexity would be O(N^2M) and not O(N*M) since we have to iterate through the s in case of ""*"". Please do correct me if I am wrong. Thanks!', 'How easy you make a hard problem is unbelievable !!!!!! Salute to you', 'Very good explanation, love the channel!', 'if this is the case below then : \n\'*\' Matches any sequence of characters (including the empty sequence).\n\n    def isMatch(self, s: str, p: str) -> bool:\n        # top down memo\n        cache = {}\n\n        def dfs(i, j):\n            if(i, j) in cache:\n                return cache[(i, j)]\n            \n            if i >= len(s) and j >= len(p):\n                return True\n            if j >= len(p):\n                return False\n            if p[j] == \'*\':\n                # Check if the \'*\' matches an empty sequence or matches one or more characters\n                cache[(i, j)] = dfs(i, j + 1) or (i < len(s) and dfs(i + 1, j))\n                return cache[(i, j)]\n            \n            match = i < len(s) and (s[i] == p[j] or p[j] == ""?"")\n            if match:\n                 cache[(i, j)] = dfs(i + 1, j + 1)\n                 return cache[(i, j)]\n            \n            cache[(i, j)] = False\n            return False\n            \n        return dfs(0, 0)', 'I have a question, why the testcase - s=""a"", p="".*..a*"" has to return false? \nI mean we just make "".*.."" a 0 character string """" and the rest we make one ""a"".\n\nEdit: Nevermind I thought \'.\' can be a 0 character string since in the question it doesn\'t say anything about it.']"
294,mQeF6bN8hMk,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'its slow because you used dfs', 'What is time and space complexity?', 'This problem sounds more complicated than it actually is.', 'This question should be marked easy', ""There is an alternative to recursive. Iterative BFS solution:\n\nclass Solution:\n    def cloneGraph(self, node: 'Node') -> 'Node':\n        if not node: return\n        q, visited = deque([node]), set()\n        clones = defaultdict(Node)\n\n        while q:\n            n = q.popleft()\n            if n not in visited:\n                clones[n].val = n.val\n                for neighbor in n.neighbors:\n                    clones[neighbor].val = neighbor.val\n                    clones[n].neighbors.append(clones[neighbor])\n                \n                q.extend(n.neighbors)\n                visited.add(n)\n        \n        return clones[node]"", ""Isn't your OldToNew in the wrong scope? The function is going to be called for each node, so you're not actually doing a Deep Clone as Node(1)'s neighbor Node(2) is not the same as Node(2), it's its own instance. Setting Node[1].neighbors[0].val = 22, will not affect Node[2].val. \nBasically you're creating n*n-1 objects instead of n because the OldToNew is in the function scope instead of a global scope (I know global is frowned upon, but Leet Code's validation system requires it in this specific instance)"", ""i have a much easier time understanding these than subarray problems.. \nI managed to solve this on my own. this is one was so much easier to me than the ones maxsubarray and subarray related problems.\n\nintution is simple.\nhave a hashmap the key being the  of the node val and the value being the node itself.\nif node val not in hashmap and node val and create a new node.\ntraverse neighbors and check if neighbor value is in hashmap.\nif it is then just get it from the hashmap and don't recurse.\n\nthe beauty of this is initially your node will not have neighbors in the hashmap  but since you are storing references\nthe references get updated. and in the end will give you the correct answer"", 'Why can’t you use a set instead of a map', ""If every node is undirected can't that be created upon finding it as a neigbor? Then you would only need a set to contain the cloned nodes.""]"
295,d4zLyf32e3I,"['Tree Question Playlist: https://www.youtube.com/watch?v=OnSn2XEQ4MY&list=PLot-Xpze53ldg4pN6PfzoJY7KsKcxF1jg&index=1', 'If the question were better worded it would be easier. It took a bit to understand what was a valid ""right side view"" node. If it were instead worded as ""return a list of the rightmost node at every level of the tree"" it would have clicked much sooner for me.', 'why is it that for me, in gfg, im not able to use collections.deque()? ""collections is not defined"" is the error i receive, even after importing the module', 'Great Video,Tnx!!', 'thank you for good english!', ""Version where you don't need to check for null/None values:\n\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        if root is None:\n            return []\n\n        q = deque([root])\n\n        right_side = []\n        while q:\n            for i in range(len(q)):\n                node = q.popleft()\n                \n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n\n            right_side.append(node.val)\n\n        return right_side"", 'This problem is just slightly different than the standard BFS tree traversal.\n  queue=[root]\n    rs=[]\n    while queue:\n      for k in range(len(queue)):\n        curr=queue.pop(0)\n        if curr:\n          rs.append(curr.val)                         #=============lol==========#\n          queue.append(curr.left)\n          queue.append(curr.right)\n      \n    return rs', ""If it's children is not null, I am going to take it's children - Neetcode"", 'drawing the tree and pointing the fact that we have to look at the right most node made the solution so much easier', 'you should have explained better how rightSide left nodes get overwritten by the right ones, but other than that, good tutorial']"
296,OnSn2XEQ4MY,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', ""When we 'return root' at the end of the function, don't we travel all the way up the stack of calls of the recursive function and return each node in the inverted tree? I don't see how we pass the test cases which expect the true root of the inverted tree only?"", ""If you don't understand the recurrsive solution, try looking over the iterative one, maybe it's easier for you to understand that one first (for me it was). Here is my solution in C++:\nThe recursive one is indeed more effiecient and less code to right, but visualising the recursion stack with a stack iteratively was easier for me.\n\nIterative:\n\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if(root == nullptr) {\n            return nullptr;\n        }\n\n        stack<TreeNode*> nodeStack;\n        nodeStack.push(root);\n\n        while(!nodeStack.empty()) {\n            TreeNode *topNode = nodeStack.top(); \n            nodeStack.pop();\n\n            if (topNode->left != nullptr) {\n                nodeStack.push(topNode->left);\n            }\n            if (topNode->right != nullptr) {\n                nodeStack.push(topNode->right);\n            }\n            TreeNode *tmp = topNode->left;\n            topNode->left = topNode->right;\n            topNode->right = tmp;\n        }\n\n        return root;\n    }\n};\n\nRecursive:\n\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if(root == nullptr) {\n            return nullptr;\n        }\n\n        TreeNode *tmp = root->left;\n        root->left = root->right;\n        root->right = tmp;\n        invertTree(root->left);\n        invertTree(root->right);\n\n        return root;\n    }\n};"", 'That’s so much easier than what I thought the problem was asking. When I heard “invert a binary tree” I thought it meant to pick one of the deepest child nodes and make it the new root node, rebuilding the tree inverted vertically.', 'sense = since ??', ""The solution doesn't seem to work anymore, I copied it and got an empty return"", 'understood', 'arrived at the same thing just a bit differently:\n\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n\n        if root is None:\n            return None\n\n        t = self.invertTree(root.left)\n        root.left = self.invertTree(root.right)\n        root.right = t\n\n        return root', 'Iterative version was a good exercise that truly strengthened my understanding of trees and problems related to trees.\n\nI got the idea to do an iterative version from Neetcode providing both recursive and iterative solutions to other problems.\n\nHere\'s the solution in case anyone wants it.\n\n        stack = []\r\n        cur = root\r\n        stack.append(cur) #this was important, it\'s also the reason why adding ""or cur"" to the loop results in a funny outcome\r\n        while stack:\r\n            if not cur:\r\n                cur = stack.pop()\r\n            else:\r\n                stack.append(cur.left)\r\n                stack.append(cur.right)\r\n                tmp = cur.left\r\n                cur.left = cur.right\r\n                cur.right = tmp\r\n                cur = stack.pop()\r\n        \r\n        return root', 'I prefer putting the swap under ""if root:"", since it\'ll return a root or None at the end.']"
297,TGveA1oFhrc,"['Linked List playlist: https://www.youtube.com/watch?v=G0_I-ZF0S38&list=PLot-Xpze53leU0Ec0VkBhnf4npMRFiNcB&index=1', 'Why is the initialization step in getMid() function slow, fast = head, head.next and not slow, fast = head, head like in the 876. Middle of the Linked List code?', 'This code does not work. getMid() is wrong. It should be like this in Java:\n\nprivate static <T> Node<T> findMiddle(Node<T> head)\r\n    {\r\n        var slow = head;\r\n        var fast = head;\r\n\r\n        while (fast.getNext() != null && fast.getNext().getNext() != null) {\r\n            slow = slow.getNext();\r\n            fast = fast.getNext().getNext();\r\n        }\r\n        return slow;\r\n    }', 'Thank you !', 'thanks for explanation!', 'Hello, \n\nInstead of listnodes, this code is returning the listnode object created at memory location.\n\nPlease guide me, how to print entire listnode.', 'This has O(log(n)) space complexity due to the recursion. Merge sort can be done iteratively log(n) times to get O(1) space complexity. Note that this is possible because we are using Linked list. If we were using an array we would need O(n) additional space anyway.', 'The recursive approach takes O(logN) space. Correct me if i am wrong', 'I thought getting the mid node is O(n) so I gave up on merge sort when I thought of it lol', 'anyone know why do we need the ""and"" in the getMid function? Cant we use or? Thanks']"
298,itmhHWaHupI,"['this code runs faster:\n\n```\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # the smaller half of the list, max heap (invert min-heap)\n        self.large = []  # the larger half of the list, min heap\n \n    def addNum(self, num):\n        if len(self.small) == len(self.large):\n            heappush(self.large, -heappushpop(self.small, -num))\n        else:\n            heappush(self.small, -heappushpop(self.large, num))\n \n    def findMedian(self):\n        if len(self.small) == len(self.large):\n            return float(self.large[0] - self.small[0]) / 2.0\n        else:\n            return float(self.large[0])\n```', 'For some interesting reason it runs a bit slower, if we add incoming num into the big heap instead of small, and make the necessary amendment to the code to pop from big instead of small.', ""This is just incredible... for some reason I either never learned, or don't remember learning, Heaps in my computer science education at university. Throughout the years I have always heard the word Heap but never really drilled down into what it did or where it is useful. This really inspired me to fill the gap!!"", 'Thanks for the explanation!\nI found the below solution a bit cleaner yet still intuitive.\n\nThe idea is that for every new number, \n1. we first push it to the small heap\n2. then pop from small heap and push to big heap\n3. check if the small heap is too small(not balanced)\n\nthe code can be reduced largely in this case:\n\nclass MedianFinder:\n\n    def __init__(self):\n\n        self.maxHeap = []\n        self.minHeap = []\n        \n    def addNum(self, num: int) -> None:\n\n        heapq.heappush(self.maxHeap, num * -1)\n        heapq.heappush(self.minHeap, heapq.heappop(self.maxHeap) * -1)\n\n        if len(self.minHeap) > len(self.maxHeap):\n            heapq.heappush(self.maxHeap, heapq.heappop(self.minHeap) * -1)\n\n    def findMedian(self) -> float:\n        if len(self.maxHeap) == len(self.minHeap):\n            return (self.minHeap[0] + self.maxHeap[0] * -1) /2\n        else:\n            return self.maxHeap[0] * -1', 'instead of using heap or priority queues. You can use segment tree . Let me explain , each node from l to r represents the position where each value in the segment l , r lies in the sorted array . Then you can use lazy update to update the position and  binary search in segment tree  to find the median :""D have fun.', 'Thank you so much🥰🥰🥰', ""Why can't I think of such amazing solutions 😢"", 'thank you', 'I believe in C++, we cant delete arbitrary elements from heap, so we would have to modifications in this approach.', 'This algorithm should be in Bible']"
299,qhBVWf0YafA,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'res=[]\r\n        perm=[]\r\n        nums.sort()\r\n        def dfs(loop):\r\n            if not loop:\r\n                res.append(perm.copy())\r\n                return \r\n            for i in range(len(loop)):\r\n                if i > 0 and loop[i] == loop[i-1]:\r\n                    continue\r\n                perm.append(loop[i])\r\n                dfs(loop[:i] + loop[i+1:])\r\n                perm.pop()\r\n        dfs(nums)\r\n        return res', 'Can someone explain to me why we did perm.pop(). And am I correct in assuming that we we count[n] += 1 after calling dfs() to restore the count for the next half of the decision tree? Please help me out 😅', 'Python make it look so easy. Java is honestly a nightmare', 'My intial approach was sorting the elements and when the element is similar to the previous element , we can just ignore. Oh am i so wrong. When you try to select an element through swapping , the sorted nature of the array is lost therefore , it is impossible to know whether the current element is already used or not. that is why hashmap is neccessary.This enables us to know whether the element is already used or not', ""Why can't you just do the same algorithm as in Permutations 1 but make your result a set? Then the duplicate permutations would be avoided and you can convert to a list before returning? Could you also just sort the input and then in the recursion just check if the current decision is the same as the previous one, because that should theoretically get rid of the redundant branches."", '3:15 why a regular brute force decision tree doesn’t work (produces duplicate permutations because the original array had duplicate numbers)\n\nThis happens because you start off two recursive trees with the same number so these sub trees produce duplicates. At the root of the tree you would have two paths that start with 1 and these would produce duplicate permutations.\n\nSo we used hashmap (inputNumber to countInInputArray) representation of the input array and work with that, so that instead of the root having two nodes that start with 1, it only has 1 node that starts with 1. This constraint is what prunes duplicate paths from decision tree. It is also applied recursively at all levels', ""I solve this problem by modify the solution from Permutation I (still using Tree).\r\n\r\n- if array.length === 1 then return the array\r\n- place unique integers (uniqueArray acquired from duplicatesArray) for nodes \r\n- then, for the next nodes, delete from the duplicatesArray of node's number \r\n- recurse(deletedDuplicatesArray)\r\n\r\n😁"", 'Thanks for the explanation, i was able to write the code by my own', 'can you please code in c++/java as python is dumb']"
300,0K0uCMYq5ng,"['Tree Question Playlist: https://www.youtube.com/watch?v=OnSn2XEQ4MY&list=PLot-Xpze53ldg4pN6PfzoJY7KsKcxF1jg&index=1', ""Would this be wrong if I'm getting -10 and 5 as my 1st level after root?"", 'thank u fro the great explanation', 'how is this problem easy lol', ""It's really admirable how you are not taking it for granted and conclude the helper function explanation as a Binary Search technique and explain it fully"", ""That's the best channel for leetcode prep. I know you must be busy with your Google job but keep posting videos - I think you can monetize it even better than any FAANG career"", ""Your explanation is succinct and straight forward. When I tried this problem originally there was an extremely long and convoluted explanation about unique solutions etc... and different potential strategies. I spent days reading the article and trying to find anywhere else on the internet where someone uses the same terms they used to explain the problem but couldn't find it. Thanks for posting such a useful video."", 'This solution is genious', 'The simplest way of explaination this question  if is ever existed then that guy has to watch this video to change his opinion', ""after watching your explanation I really can't understand from anyone else, Please make more videos""]"
301,3jvWodd7ht0,"['💡 BACKTRACKING PLAYLIST: https://www.youtube.com/watch?v=pfiQ_PS1g8E&list=PLot-Xpze53lf5C3HSjCnyFghlW0G1HHXo&index=1', 'Ok so the actual time complexity is n * 2^n including the isPali check. \nBut why is it 2^n for the time complexity for the backtracking part?', 'i feel the trick here is to recognize that when incrementing dfs argument, we should take j instead of i and add 1 to it.', ""Tricky question with wording, I originally thought it was saying it is a valid palindrome if letters can be rearranged to be a palindrome, but really it's the raw string being a palindrome.\n\nGetting better at these though, backtracking definitely has a common format."", ""I'm still struggling to understand how to choose what to do at each step in the DFS. Like how do I know that I need to split my decision in such a way as described in the video?"", 'can anyone pls tell me why r we popping the partition from the ans', '[""aa""] alone wouldn\'t be a subset?', ""after finding the first res [a, a, b]\nwe reached the base case because i = 3 and i == len(s)\nwe return to the previous call stack i = 2  j = 2\nthe 'b' is popped from cur\n\ni thought that was sufficient, because we only did one return which is from the base case\n\nbut how come we return to the previous call stack i = 1 j = 1 from i = 2 j = 2\nand popped 'a' from cur too??"", '*Minor correction, the time complexity is not 2^n, it is n*2^n*', 'This seems so simple after your explanation😭']"
302,fMSJSS7eO1w,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'List2 = []\nfor x in range(len(matrix[0])):\n    List1=[]\n   for y in matrix[::-1]:\n        list1.append(y[×])\n   List2.append(list1)\nreturn list2\n\n\nWhy this code is giving wrong output in leetcode but right output in local jupyter notebook', 'r seems like always n - l, because the matrix is nxn', 'great', 'My solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        N = len(matrix)\n\n        for y in range(N // 2):\n            for x in range(y, N - y - 1):\n                first = matrix[y][x]\n                matrix[y][x] = matrix[-x - 1][y]\n                matrix[-x - 1][y] = matrix[-y - 1][-x - 1]\n                matrix[-y - 1][-x - 1] = matrix[x][-y - 1]\n                matrix[x][-y - 1] = first\n\n\n------- or\n\nclass Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        N = len(matrix)\n\n        for y in range(N // 2):\n            for x in range(y, N - y - 1):\n                rot_x, rot_y = x, y\n\n                for i in range(3):\n                    matrix[rot_y][rot_x], matrix[-rot_x - 1][rot_y] = (\n                        matrix[-rot_x - 1][rot_y],\n                        matrix[rot_y][rot_x],\n                    )\n                    rot_x, rot_y = rot_y, -rot_x - 1', 'The best explanation by far of the layer rotation method. Damn it. The best!!', 'j=0\nfor i in zip(*matrix):\r\n      matrix[j]=reversed(i)\r\n      j+=1', 'my ego has made me attempt this problem almost 3 hours – thank you for this clean explanation!', 'Since its python you can just do\n\ndef rotate(self, matrix: List[List[int]]) -> None:\r\n    n = len(matrix)\r\n    l, r = 0, n - 1\r\n\r\n    while l < r:\r\n        top, bottom = l, r\r\n        for i in range(r - l):\r\n            (\r\n                matrix[top + i][r],\r\n                matrix[top][l + i],\r\n                matrix[bottom - i][l],\r\n                matrix[bottom][r - i]\r\n            ) = (\r\n                matrix[top][l + i],\r\n                matrix[bottom - i][l],\r\n                matrix[bottom][r - i],\r\n                matrix[top + i][r]\r\n            )\r\n\r\n        r -= 1\r\n        l += 1\r\n\n\nSo theres no need for a temp variable, in that case we also wouldnt have to care about doing it in reverse.\n\nBut I think readablitiy suffers a little', 'To say this is time O(n^2) is subtly misleading/not best way to express the time complexity. While I understand that algebraically ""n x n = n^2"", when expressing the algo itself in time complexity, O(n^2) could be interpreted as a quadratic runtime. Since the algo only looks at each cell once, the algo is, in fact, linear, so it would be better to express ""n x n"" as just ""M"" and therefore O(M).']"
303,IlEsdxuD4lY,"['Dynamic Programming Playlist: https://www.youtube.com/watch?v=73r3KWiEvyk&list=PLot-Xpze53lcvx_tjrr_m2lgD2NsRHlNO&index=1', ""Great solution thank you for it. \nI've noticed that this could be simplfied further. we can calculate everything `in place` using only row. \nAs in your solution we fill the row with ones. \n\nand iterate height times and just calculate row[i] += row[i + 1];\n\nexample code here: \n\n    int uniquePaths(int m, int n) {\r\n        std::vector<int> v(n, 1); //size n fill 1\r\n\r\n        for(int c = 1; c < m; ++c)\r\n        {\r\n            for(int i = v.size() - 2; i >= 0; --i)\r\n                v[i] += v[i + 1];\r\n        }   \r\n        return v[0]; \r\n    }\n\nContinue the good work, I appreciate your videos :)"", 'My code based on the math :) O(n)\n\n\ndef uniquePaths(self, w: int, h: int) -> int:\n    n, k = h + w - 2, w - 1\n    fact = 1\n\n    for i in range(k):\n        fact *= n - i\n        fact //= i + 1\n\n    return fact', 'SUPER SICK!!!', 'Thank you !!!', 'NeetCode is where I come when my polished, commented code fails test case 97 by ""Time limit exceeded"". \n...\nOnly to get 0:13 into the video and smack my forehead as the right approach becomes obvious in a flash.', ""Your way of teaching is so good that I didn't even had to wait for you to code and I coded it myself just by using your logic. Thanks man!"", 'cpp run time 0ms😂😂', 'Man this is tough for me. This problem is above me. Greetings from Argentina. I really like your content', 'A think a tabular dynamic programming approach is more straightforward. \n\nNumWays[row][col] = NumWays[row-1][col] + NumWays[row][col-1]\n\nThen return value in the bottom right after the iteration.']"
304,REOH22Xwdkk,"['💡 BACKTRACKING PLAYLIST: https://www.youtube.com/watch?v=pfiQ_PS1g8E&list=PLot-Xpze53lf5C3HSjCnyFghlW0G1HHXo&index=1', 'res = [[]]\r\n        subset = []\r\n\r\n        def dfs(i):\r\n            if i == len(nums):\r\n                return\r\n            subset.append(nums[i])\r\n            \r\n            for j in range(1, len(nums)-i):\r\n                dfs(i+j)\r\n            res.append(subset.copy())\r\n            subset.pop()\r\n            return\r\n            \r\n        for num in range(len(nums)):\r\n            dfs(num)\r\n        \r\n        return res', 'For this particular one, bfs would be cleaner and faster', 'The method for coding it up seems overly complicated. This solution on Leetcode helped me understand the problem much better.\n\ndef generateSubset(nums):\n      if not nums:\n         return [[]]\n      tail = generateSubset(nums[1:])\n      currentValue = nums[0]\n      output = []\n      for subset in tail:\n             output.append(subset)\n             output.append([currentValue] + subset)\n      return output\nreturn generateSubset(nums)', 'Mindblowing🤯\nThanks for explanation, very helpful!', 'is the time complexity of this recursive algo O(2^n) or O(n*2^n)? I know neetcode says n*2^n, but several articles suggest it is 2^n. Several articles suggest it is n*2^n, I really have no idea lol. We know we have a total of 2^n solutions. Why is it times n?', 'i just love that all your videos are under 20 mins', 'XIN Thường niệm nam mô ngọc hoàng thượng đế vô cực đại thiên tôn nam mô a di đà phật nam mô quán thế âm bồ tát', 'Is it me or understanding recursion and backtracking is a little difficult?', 'the time complexity is not n * 2^n, it is just 2^n....']"
305,jSto0O4AJbM,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤\n\nThis one turned out longer than expected, recommend 1.5x speed', 'The best explanation hands down', ""Difficult to image that someone would genuinely come up with the solution on the fly. Only if one have solved exactly this problem before. So, what companies like Google are looking for --- diligent applicants who solve 200-300-400-500+ problems on leetcode and memorize approaches? I got my job in the startup this way. I solved about 80  the most popular problems on leetcode. And on the interview I got 2 out of 3 which I solved perfectly, and the 3-rd one(which I didn't see before) I solved in a brute-force way. That was enough to get in. So for Google, Facebook, etc. you just need to solve more, especially hard ones. That's it!"", 'Skipping the coding solution part for now. I watched the explanation but it still seems worth it to try to code it on my own first, because it was a bit abstract.', '8:38 - even if there is 1K or 1M letters in t, we will only check a-z and A-Z in dictionary, it is 52 which is constant, no?', 'You are the best of bests', 'I was so close on this one! I didn\'t think of that have vs need thing you did so I only solved half the test cases because I moved the left pointer properly but only changed the min_window_size when the count in t matched the count in s, which failed cases where we had duplicates.\n\nI couldn\'t think of a quick way to compare that we have enough of each specific value in the ""s"" hashmap such that we could check to see if our window was smaller. I was thinking maybe you would just have to make a helper function to go through the ""s"" hashmap\'s keys and make sure you have at least enough of each letter to match the count in t, but making a single integer increment when you have enough for each key is smart.\n\nI didn\'t even bother implementing my hashmap count helper function because I figured I was missing some way of tracking the size of the s and t hashmap and didn\'t want to spend 20 minutes just to get to a TLE.\n\n*Edit: I actually did check to see how slow my helper function would be and it was 80% slower than NC\'s solution. So it could work to check through the hashmaps key by key each time, but it\'s super slow. Good to know I was really very close to solving this.', 'I was asked this in an interview yesterday', 'what is the reason for updating res before returning? (line 31)', 'On line 10, it should be ""have, need = 0, sum(countT.values())"" because if a character is present more than once in t, then it is not enough to check the length of the dictionary (number of keys) but you would need to sum up the dict\'s values.']"
306,BJnMZNwUk1M,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'You made this dead easy Thankyou so much 😘', ""Happy Teacher's day man ! Specifically chose a old video to comment because they were helpful to me .\n\nThank you for your contribution."", 'I was redoing this question after a while,  and I got almost everything right, but that middle line of code where we are checking if left < right and top < bottom. Has anyone have the intuition? what prompts you to put that there? Help', 'I really still don\'t understand the part about ""if not (left < right and top < bottom): break"". The while loop on the top already states ""while left < right and top < bottom"", so ""if not left < right and top < bottom"", this already violates the while loop condition. Shouldn\'t the loop should logically break by itself, without having to write additional line of codes explicitly to do it?', 'path = []\r\nwhile len(matrix)>1:\r\n    rowfirst = matrix[0][:len(matrix[0])-1]\r\n    rowlast = matrix[-1][:len(matrix[-1])-1]\r\n    rowlast = rowlast[::-1]\r\n    rowmid = [i[-1] for i in matrix]\r\n    path = rowfirst+rowmid+rowlast\r\n    matrix.remove(matrix[0])\r\n    for i in matrix:\r\n        i.remove(i[-1])\r\n    matrix.remove(matrix[-1])\r\npath.extend(matrix[0])\r\nprint(path)\r\n\nDoes this work as an efficient solution?', ""*explanation for* : _if not (left < right and top < bottom): break_\nsince we updated top and right variable, we should check if while loop condition is still correct\n\nAlternatively: this might be easier to follow\n'''\nclass Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        l , r = 0 , len(matrix[0])\n        t, b = 0, len(matrix)\n\n        res = []\n        while l < r and t < b:\n            # get every i in the top row\n            for i in range(l, r):\n                res.append(matrix[t][i])\n            t +=1\n\n            # get every i in the right col\n            for i in range(t, b):\n                res.append(matrix[i][r-1])\n            r -=1\n\n             \n           *if (l<r and t<b):*\n\n                # get every i in the bottom row\n                for i in range(r-1, l-1, -1):\n                    res.append(matrix[b-1][i])\n                b -=1\n\n                # get every i in the left col\n                for i in range(b-1, t-1, -1):\n                    res.append(matrix[i][l])\n                l +=1\n\n        return res\n'''"", 'note to self - corner cells did not get added twice since top pointer changed.', 'I fucking hate leetcode... thanks for the good explanation🙌', 'Tq']"
307,q6IEA26hvXc,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'Hello Neetcoder,\n\nI have a request, Could you please make a video on leetcode problem number 2387 (Median of a row wise sorted matrix). It would be helpful.\n\nBy the way, your content is amazing and keep up doing this great work. Thank you for all of the efforts you made from all of the neetcode family members.', 'this is so clear and understandable, thank you!!!! :)', ""Why can't we start with a bigger array?"", 'read about islam man', 'ye channel neet droppers ke liye khola hai kya', 'Thank you for your brilliant work🤗', 'Super intuitive explanation, thank you NeetCode!', 'Phenomenal explanation !!!', 'I feel so slow.']"
308,Akt3glAwyfY,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', ""Nice job. We don't need cycle set. WE can check the node adj len .Let me explain why: if we re-visit a node, but the node adj is not empty, which means the node is in the cycle."", ""line 17 : if crs is in ouput, it means that it has been visited because that's what we doing in line 25, 26, so can we use `crs in output` instead?"", ""I'm super excited that I came up with this solution on my own after solving Course Schedule I! I actually thought my solution was hacky because I'm using a set to keep track of known courses we can definitely take (for constant time lookup) and a list to store the result to maintain course ordering. Glad to see my solution was very close to yours!"", 'Wrote out a similar thing, but this is so much cleaner and easy to implement/understand. Thanks :)', 'You forgot to remove crs from map, it would improve the efficiency.', 'I see that both visit set and output list have the same contents. So, what is the rationale behind maintaining both list and a set ? Could anyone explain ?\nThanks', 'thanks! Visit set and output look redundant to me.', 'It may not be necessary to have both `visit` and `output` => both are ""global"" to dfs and carried through out the whole search process and both only record successfully taken courses. The solution works if we simply delete all lines with `visit`', 'Really, how could it be possible that you were once a NEET? You explain topological sort better than my university professor...']"
309,44H3cEC2fFM,"['just using intervals = sorted(intervals) works as well', 'if the interval length is 1, is interval [1:] out of index?', 'public int[][] merge(int[][] intervals) {\r\n        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\r\n        ArrayList<int[]> output = new ArrayList<>();\r\n        output.add(intervals[0]);\r\n        int index=0;\r\n        for (int i = 1; i < intervals.length; i++) {\r\n            int start = intervals[i][0];\r\n            int end = intervals[i][1];\r\n            int lastend = output.get(index)[1];\r\n            if (start<=lastend){\r\n                output.get(index)[1] = Math.max(lastend,end);\r\n            } else {\r\n                output.add(new int[]{start,end});\r\n                index++;\r\n            }\r\n        }\r\n        int[][] ans = new int[output.size()][2];\r\n        for (int i = 0; i < output.size(); i++) {\r\n            ans[i] = output.get(i);\r\n        }\r\n        return ans;\r\n    }', 'Very nice explanation', 'Basically you took a minHeap and Stack to solve this', 'you did not cover edgecases like this [[1,4],[0,4]]', 'super efficient way. impressive. unreal. wow.', 'thank u very much😭the best leetcode video in youtube!', ""I love you Neetcode, you're my leetcode buddy"", 'love your channel man !! youre doing lovely work ! love from india!']"
310,T41rL0L3Pnw,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'awesome idea with O(1)  memory!', 'are you god gifted ?', 'Thank you so much Neetcode for great explanation and solution! I believe Line 19 is  --> if matrix[r][0] == 0 or matrix[0][c] == 0:', 'What about replacing all the 1 in the same row/col of a 0 with ""T"" and traverse the matrix a second time replacing ""T"" with 0?', ""Either this is infact a supremely intuitive problem relative to other leetcode mediums, or I'm getting better at this stupid Leetcode thing. My self esteem hopes it's the latter 😅"", 'Tricky question, but you are with us.', 'Appreciate how the video is updated @15:35 to reflect the correction. It shows this channel is updated to ensure correctness and not left unattended once the video is made and out. Thank you for your systematic approach, videos and code solutions. It helps.', 'Pathetic explanation. Worst question', 'love your channel, helps me a lot for my preps']"
311,vzdNOK2oB2E,"['Thank you! Never would have thought of making the keys the ASCII character count, that is pretty clever', ""I was able to come up with a solution before looking it up :) \nnot optimal but I was glad I was able to solve it. Thanks in part to your videos.\n\ndef groupAnag(list):\r\n    result = {}\r\n    for item in list:\r\n        itemResult = []\r\n        for letter in item:\r\n            itemResult.append(letter)\r\n        itemResult.sort()\r\n        itemResult = ''.join(itemResult)\r\n        if itemResult in result:\r\n            result[itemResult].append(item)\r\n        else:\r\n            result[itemResult] = [item]\r\n    my_list = [i for i in result.values()]\r\n    return my_list"", 'Maybe we can get rid of mapping strings with integer list and use sorted keys.\nSomething like below worked for me:\n\nans = defaultdict(list)\r\n        for str in strs:\r\n            sorted_str = sorted(str) \r\n            ans[tuple(sorted_str)].append(str)\r\n        \r\n        return ans.values()', 'You can sort a string s in o(|s|) time and o(1) time complexity, so I went with first solution:\ndef groupAnagrams(self, strs):\r\n        """"""\r\n        :type strs: List[str]\r\n        :rtype: List[List[str]]\r\n        """"""\r\n        classDict = {}\r\n        \r\n        for string in strs:\r\n            #cannoinze\r\n            letters = list(string)\r\n            letters.sort()\r\n            key = join(letters,"","")\r\n\r\n            \r\n            if key not in classDict:\r\n                classDict[key] = []\r\n            classDict[key].append(string)           \r\n        return list(classDict.values())', ""Set up a dictionary and output list.\n\nIterate thru the input strings.\n    For each input string, create a separate sorted string. \n\n    If the sorted string is a key in the dictionary,\n        append the input string to a list in the key's value\n\n    If the sorted string is not a key in the dictionary, \n        set up a new key value pair where the key is the sorted string,\n        and the value is a list holding just the input string.\n\nIterate thru the values of the the dictionary,\n    append them to the output list.\n\nReturn this output list."", 'If you don\'t want to use defaultdict() from collections, you may do this:\n\ndef groupAnagrams(strs):\n    res = {}\n    for s in strs:\n        count = [0] * 26 # a .... z\n        for c in s:\n            count[ord(c) - ord(""a"")] += 1\n        key = tuple(count)\n        if key in res:\n            res[key].append(s)\n        else:\n            res[key] = [s]\n    \n    return list(res.values())', 'Why is the sorted version run at a lower runtime on leetcode eventhough this solution is better in theory. Leetcode runtimes are pretty weird.', ""why we are use '#' there and what is its importance ?"", 'Amazing... How come you can get to these ideas. It is simple, but it is hard to get to these solutions without hints :)', 'JAVA code\nI really should learn python:\n28 lines vs 8 lines\r\npublic static List<List<String>> groupAnagrams(String[] strs) {\r\n        Map<List<Integer>, List<String>> hm = new HashMap();\r\n\r\n        for(String s: strs) {\r\n            int count[] = new int[26];\r\n            for(Character c: s.toCharArray()) {\r\n                count[c-97]++;\r\n            }\r\n            List<Integer> alphabet_count = new ArrayList<Integer>();\r\n            for(int i: count){\r\n                alphabet_count.add(i);\r\n            }\r\n            if(!hm.containsKey(alphabet_count)){\r\n                List<String> result_map_value = new ArrayList<String>();\r\n                result_map_value.add(s);\r\n                hm.put(alphabet_count, result_map_value);\r\n            }\r\n            else {\r\n                List<String> result_map = hm.get(alphabet_count);\r\n                result_map.add(s);\r\n                hm.put(alphabet_count, result_map);\r\n            }\r\n        }\r\n        List<List<String>> final_result_list = new ArrayList<List<String>>();\r\n        for (Map.Entry<List<Integer>, List<String>> entry : hm.entrySet()) {\r\n            final_result_list.add(entry.getValue());\r\n        }\r\n        return final_result_list;\r\n    }']"
312,cjWnW0hdF1Y,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'Ty', 'Can u follow up the NlogN solution ?', 'I like it', 'isnt DP bottom up, whyd you start from the last index', ""noticing the subproblem 'is there an increasing subsequence with length m' is O(n), and m is between 1 and n, we can use binary search and get overall complexity O(nlogn). But it is way neater with DP"", 'walk out of the room. lol', '""I really doubt your interviewer is going to expect you to get this without a hint; if they do I\'d just walk out of the room""\n\nProbably worked great up until the layoffs 😥', 'Wow great explanation!', 'finally a good explanation and solution for this, thanks!']"
313,s6ATEkipzow,"['Tree Question Playlist: https://www.youtube.com/watch?v=OnSn2XEQ4MY&list=PLot-Xpze53ldg4pN6PfzoJY7KsKcxF1jg&index=1', 'Using inorder traversal can also a solution sir', ""Wonderful. You read my mind. The first intuitive solution that came to my mind was to blindly compare the node values on the left and right with its immediate root node. I think its not only important to teach how to build an intuition but also to teach how not to build one. Thanks a ton for doing that. That's what has made your channel stand out. Keep it up!"", 'took me like four hours to understand this answer fully :(', 'I love how you present the problems so well, I figured it out at 3:23', 'You are amazing', 'I dont know why (root.val < left or root.val > right) gives me wrong answers', ""what if root = INT_MAX doesn't it gives wa."", ""I don't understand the difference between the brute force and the optimize brut force. In both case we iterate trough each node and made a comparison."", 'My solution was to find the inorder traversal using dfs, store it in an array then just check if that array is sorted or not. The overall time complexity is O(N) also! it was easier to understand']"
314,1UOPsfP85V4,"['Linked List Playlist: https://www.youtube.com/watch?v=G0_I-ZF0S38&list=PLot-Xpze53leU0Ec0VkBhnf4npMRFiNcB&index=1', ""I love the Neetcode solution videos but my own approach in this one felt easier to understand. Instead of using a dummy node, I just treated the first k nodes as a special. That is, I reverse the first k nodes so I can initially set a few values to use going forward (e.g. for 1->2->3->4->5, with k =2, I first reverse 1->2 which yields 2->1->nullptr). The values I capture are newHead (which is what I will return at the end of the entire algorithm, this gets set to the last value encountered in the first list which is 2) and then I set a value called prevTail which is the tail of the reverse list from the previous group of k nodes (which is 1 in this case). So prevTail = head, and then newHead = prev once the list is reversed. With that in place it's fairly easy to just keep reversing k nodes in a row and at the end set prevTail->next = prev and prevTail = currHead every time. Then at the end just make sure to set prevTail->next = curr. If the length of the linked list is a multiple of k, curr will be null, otherwise curr will point to the head of the remaining unreversed portion of the list. You could advance k everytime to see if k nodes exist, but I just iterated through the entire list up front and counted the total nodes, and then divided by k to determine how many iterations I needed to perform before terminating.\n\nHere is a link to the solution:\n\nhttps://leetcode.com/problems/reverse-nodes-in-k-group/solutions/4090426/c-determine-total-node-count-reverse-first-k-nodes-and-then-iterate/"", ""One of those problems you know how to solve but can't. Very frustrating."", 'Not the best of your work, honestly.', 'can someone explain the time complexity ? Is it O(Nk)', ""hello, thank you for video, but you've used the stack data structure. As I see it takes memory space O(k). So it doesn't totally fit the problem requirements. Anyway it's easy to replace replace recursion by the loop, so for someone it will be a homework :)"", ""whoever find this solution confusing , I've got a simpler solution for you guys, yes it is not as efficient as given in the video , but still it has the time complexity of nearly O(n)\n\n( Sorry , I have a habit of putting huge comments in my code) \n\n'''\r\ninput => 1 --> 2 --> 3 --> 4 --> 5 --> none\r\nk = 2 \r\n\r\nlists = [2 --> 1 --> None,  4 --> 3 --> None]\r\ncurr = [5 --> None]  because 5 is remained to reverse\r\n\r\nnow connect all the element in lists and curr \r\nso output => 2 --> 1 --> 4 --> 3 --> 5 --> None\r\n\r\n'''\n\nclass Solution:\r\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if k == 1:\r\n            return head  \r\n\r\n        # first find the length of the linked list \r\n        curr = head \r\n        length = 0\r\n        while curr != None:\r\n            curr = curr.next \r\n            length += 1 \r\n        \r\n        # we have to reverse the linked lists length // k times \r\n        prev = None \r\n        curr = head\r\n        if curr.next != None:\r\n            nxt = curr.next \r\n        else:\r\n            nxt = None\r\n        \r\n        lists = []  # this contains the different reverses linked list , which we will connect at the end\r\n    \r\n        for i in range(0 , length//k):\r\n            #reverse the linkedlist \r\n            for _ in range(k):\r\n                curr.next = prev \r\n                prev = curr \r\n                curr = nxt \r\n                if nxt.next != None:\r\n                    nxt = nxt.next \r\n\r\n            lists.append(prev) \r\n            prev = None  # making prev none after every reverse operation is done , because the second linked list to be reversed should point at None at the last \r\n\r\n        if length % k == 0:  # means all the elements in the list is reversed , so we can make curr as None \r\n            curr = None\r\n            # otherwise keep curr as it is , because it will contain the non reversed list , so that we can append that list at the end\r\n\r\n\r\n        # connecting all the linked list present in the lists \r\n        for i in range(len(lists)): \r\n            node = lists[i]\r\n            while node.next != None:\r\n                node = node.next \r\n            node.next = lists[i + 1] if (i + 1) < len(lists) else curr   # edge case for the last element of the list\r\n        \r\n        return lists[0]"", 'Just new to programming how is this solution \na = [1, 2, 3, 4, 5]\nn= []\nk = 2\nc = 0\nfor i in range(len(a)):\n    n.insert(c, a[i])\n    if (i+1)%k == 0:\n        c = (c+ 1)*k\nprint(n)', 'They asked me this question in Qualcomm. Got rejected.', 'Took me a while to understand the part from 10:40. But I got it after a bit of brainstorming. It really helps if you write down the LL on a piece of paper.']"
315,H9bfqozjoqs,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'if we were given an input like this \ncoins = [50], amount = 100\nwould the dfs solution faster than dp solution?', 'Here\'s a similar-sized solution with less abbreviation:\n\n```python\ndef coinChange(self, coins: List[int], amount: int) -> int:\n    coinsToZero = [float(""inf"")] * (amount + 1)\n    coinsToZero[0] = 0\n\n    for currentAmount in range(1, amount + 1):\n         for coin in coins:\n                if currentAmount - coin >= 0:\n                    coinsToZero[currentAmount] = min(coinsToZero[currentAmount],\n                                                     1 + coinsToZero[currentAmount - coin])\n\n    return coinsToZero[amount] if coinsToZero[amount] != float(""inf"") else -1\n```', 'The correct solution on leetcode has ur OUTER loop as its INNER LOOP and your INNER loop as its OUTER loop. Why is it switched around? For example the solution on leetcode says this: \n\nBottom up DP\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:        \n        dp=[math.inf] * (amount+1)\n        dp[0]=0\n        \n        for coin in coins:\n            for i in range(coin, amount+1):\n                if i-coin>=0:\n                    dp[i]=min(dp[i], dp[i-coin]+1)\n        \n        return -1 if dp[-1]==math.inf else dp[-1]', 'great explanation. thank you very much.', 'Who’s got a 3¢ and 4¢ coin?', 'The initial value “amount + 1” is very handy. If using Int.max to initialize the dp array we need to check the value before using it. Otherwise it causes overflow.', 'Love how you went from the greedy approach to the brute force dfs approach to the optimal dp approach. It helped me understand this problem better. Thank you !', ""how do you do it? how do you teach so well? even I am absolutely clear conceptually about a thing I can't teach it."", 'Nice and short functional programming style solution:\n\ndp = [0]\r\nfor i in range(1, amount+1):\r\n    options = [dp[i-x] for x in coins if i >= x and dp[i-x] != -1]\r\n    dp.append(-1 if not options else 1+min(options))\r\nreturn dp[amount]']"
316,EgI5nU9etnU,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'So amazing brother. Thank you', ""Quick question: I was trying to solve this using the Ailen Dictionary method you also made a video of. I can't get it to pass all test cases. May I ask if the method for the alien dictionary can be applied to this one?"", 'This is very clear explanation, but I met Time Limit Exceeded problem, so I made the follow changes to met the requirements:\nclass Solution(object):\n    def canFinish(self, numCourses, prerequisites):\n        """"""\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: bool\n        """"""\n     \n        adjacency_list = [[] for _ in range(numCourses)]\n        for crs, prec in prerequisites:\n            adjacency_list[crs].append(prec)\n        \n    \n        visited = [0] * numCourses  \n        \n        def dfs(crs):\n            if visited[crs] == 1:  \n                return False\n            if visited[crs] == 2: \n                return True\n            \n            visited[crs] = 1  \n            for prec in adjacency_list[crs]:\n                if not dfs(prec):\n                    return False\n            visited[crs] = 2  \n            return True\n\n        for crs in range(numCourses):\n            if not dfs(crs):\n                return False\n        return True', 'Simplest and easiest explanation. Thankyou!', 'Not able to do the BFS solution of this problem, got stuck in thinking how it will be approached, tried with one problem getting TLE in 29th test case. \n\nCan anyone help!', ""how come you don't use a set instead of a list for the visitedSet? One would need to use the nonlocal keyword but the lookup times are much quicker. Couldn't there be an edge case where your last node in the dfs loops back to the second to last and then you are searching the whole array. This could potentially happen a couple times no? Thanks for any clarity you can provide!"", 'I like ur solution to this problem and I understand it the most but when i converted this code to javascript it runs bottom 10% of javascript leetcode submissions. Any idea why?', ""If you move the line 13 `if preMap[crs] == []` before the line 11 `if` check, then you don't need the `visitedSet.remove(crs)` in line 19, because you will never traverse the visited path that way. Thanks for great explanation."", 'thanks']"
317,DfljaUwZsOk,"['DJ Khaled been real quiet since 4:20 dropped...', 'i found this can be solved without using a deque rather an array/vector with left counter. if possible make a video on that.\nthankx', 'I find the drawn explanations SERIOUSLY lacking (also compared to all your other videos) and I\'ll explain why.  Only the coding part is where anything began to make any sense or answer any of the questions at all.  Even after the coding part though I was left wondering ""Why are we even doing it like this?"" because the drawn explanations were so bad and insufficient.\n\nHere are my first-viewing initial questions watching this drawn explanation around 5:25:  1) If the deque is the size of the window (okay, seems intuitively like it could make sense), why are we popping everything out of it reducing the size to the single largest number?  What does this even tell us?  Why did the size matter?  Why (not when) are you popping (it\'s unexplained)? 2) When we look at the next window (or just next number), how are we making sure that 4 wasn\'t a part of the window that we\'re NOT looking at any longer (the first number of the last window)?  You don\'t cover this at all, you just say ""Compare the 5 and remove the 4 since it\'s larger"" 7:02.  That\'s mostly unhelpful and just perplexing 3) You also say the queue is ""always decreasing"" but what does that even mean?  You don\'t explain that, and all I can see is it\'s not decreasing numerically as it\'s going 1,1,1,1,4,5 by the happenstance of your problem set (it\'s increasing).  In fact, it doesn\'t seem to contain more than one number ever (as mentioned above).\n\nAs you start the next drawn explanation: 1) At 8:49 you draw an arrow to the ""beginning"" at the right side.... and then draw an arrow to the ""beginning"" on the left side. 😑😵\u200d💫 2) You say at 10:14 ""Okay the first thing to notice is the 8 is no longer in bounds so we have to pop"".  HOW DO WE KNOW THAT!?!  We literally didn\'t even add the smaller numbers that might have been before it so we have absolutely no idea where the 8 actually stood because the dequeue doesn\'t represent position of the window at all. 🤯 The 8 could have been the 3rd index (or any other), and still totally be within our window 😑\n\nThe drawn explanations here serve purely as wheels of confusion and raising unanswered and unsolved questions.', 'Have you done cp ?', 'I was trying to solve using stack/queue, until I saw this video to realize we need to use deque here.', 'I do understand solution but where do u get the basic intuation that this can be solved vai monotonic DS?', 'Clever solution!', 'thanks :)', 'My solution that passes on LC:\nI feel as this is more consistant with the way neetcode solved the other ones. Exact same algo\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        q = deque()\n        l = 0\n        res = []\n        for r in range(len(nums)):\n            while len(q) != 0 and nums[r] > nums[q[-1]]:\n                # pop all smaller elements from queue\n                q.pop()\n            q.append(r)\n            if r - l + 1 == k:\n                res.append(nums[q[0]])\n            if r - l + 1 > k:\n                l += 1\n                while q[0] < l:\n                    q.popleft()\n                res.append(nums[q[0]])\n        return res', 'from typing import List\r\nimport collections\r\n\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        """"""\r\n        Find the maximum sliding window in an array of integers.\r\n\r\n        Args:\r\n            nums (List[int]): The input array of integers.\r\n            k (int): The size of the sliding window.\r\n\r\n        Returns:\r\n            List[int]: The list containing the maximum values in each sliding window.\r\n\r\n        Example:\r\n            Input: nums = [1, 3, -1, -3, 5, 3, 6, 7], k = 3\r\n            Output: [3, 3, 5, 5, 6, 7]\r\n        """"""\r\n        q, res = collections.deque(), []  # Use a deque for efficient operations.\r\n        \r\n        # Iterate through the array from left to right.\r\n        for r in range(len(nums)):\r\n            # Remove smaller elements from the deque.\r\n            while q and nums[r] > nums[q[-1]]:\r\n                q.pop()\r\n            \r\n            # Add the current index to the deque.\r\n            q.append(r)\r\n            \r\n            # Check if the window has enough elements.\r\n            if r + 1 < k:\r\n                continue\r\n            \r\n            # Check if the leftmost element is outside the window [r+1-k, r], remove it from the deque.\r\n            # checking if the index at q[0] is smaller than left = r+1-k, if it is then just pop the index at left \r\n            if q[0] < (r + 1 - k): \r\n                q.popleft()\r\n            \r\n            # Append the maximum value in the current window to the result list.\r\n            res.append(nums[q[0]])\r\n        \r\n        return res']"
318,lXVy6YWFcRM,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'thanks for sharing knowledge 😊😊', 'Better than striver.', 'we dont need to check for zero right because we are taking min, max of three elements in which the nums[i] is also there so it will take the nums[i] , and the currmin currmax will not become 0 for the remaining array ! correct me if im wrong', 'Might be this solution does not work for this input: [-5, 0, -3]', 'It can also be solved using max sum sub array algorithm.', '6:20 this is same as kadane’s algorithm for maximum subarray, where we keep track of max subarray ending at ith index. For this problem since two negatives multiplied together give a positive, we need to keep track of the min subarray ending at ith index AND max subarray ending at ith index. Then for i+1 position, if it’s a negative value, then the max product subarray ending at i+1 position is that value * min subarray ending at ith position (if it’s negative value)\n\nDealing with 0s as elements, the zero resets our min and max subarray ending at 0 element’s index. So both min and max become 1 after encountering 0', 'The code works even without the edge case of 0 , can anybody explain why is that ??', 'is the max the max product sequence in the sub array? in the array [1,-2]  at -2 the max is calculated as -2 but shouldnt it be 1', ""Shouldn't brute force be O(n^3)? We have n^2 sub arrays and calculating product for each is an O(n) operation.""]"
319,OM1MTokvxs4,"['Dynamic Programming Playlist: https://www.youtube.com/watch?v=73r3KWiEvyk&list=PLot-Xpze53lcvx_tjrr_m2lgD2NsRHlNO&index=1', 'me watching this knowing that I have an IQ of float(""-inf"")', 'Can you comment a little on the input size?', 'Such an intuitive solution! Thanks!', 'He caught me with my insecurities in the first few seconds', 'So, I have IQ of more than 90, yay!\nIn my opinion, this problem is the easiest of all medium Dynamic Programming problems on LC.', ""This channel is a legitimate goldmine. I solved this problem top-down but I'm grateful I checked out this channel all the same because the bottom-up solution is 10x more elegant."", 'Can you just start out with dp[] = last row and iterate from the second to last row up to the first?', 'LOoks like I have IQ less than 90.', 'This solution is genius! Nice work.']"
320,o811TZLAWOo,"['Linked List Playlist: https://www.youtube.com/watch?v=G0_I-ZF0S38&list=PLot-Xpze53leU0Ec0VkBhnf4npMRFiNcB&index=1', 'can anyone explain it a bit better please', 'Solved the same using recursion.', 'i think there is a problem in the drawing that is after swaping, the prev is pointed to the second position of the list, which is 1, not 3, and the curr is pointed to the 3 instead of 4, thats why it is confusing', 'After the first pair of swapping where is the pointer location I mean where is prev , at 1 ???', 'oh my this problem really fucked up my head last night', 'i hate linkedlists', 'Beautiful explanation. Thanks', 'class Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n        \n        swap(head);\n        swapPairs(head.next.next);\n        \n        return head;\n    }\n    \n    private void swap(ListNode head) {\n        int nextValue = head.next.val;\n        head.next.val = head.val;\n        head.val = nextValue;\n    }\n}', 'I am so dumb 😥😥']"
321,6X7Ha2PrDmM,"['Dynamic Programming Playlist: https://www.youtube.com/watch?v=73r3KWiEvyk&list=PLot-Xpze53lcvx_tjrr_m2lgD2NsRHlNO&index=1', 'i guess the order in which u filled cell is wrong, your final answer may be correct', 'can we do it with dfs?', 'Beautiful explanation', 'Brilliant explanation!', ""I solved it in the below way which passes : \n\nvar maximalSquare = function(matrix) {\n    \n    const n = matrix.length, m = matrix[0].length;\n    const dp = Array(n+1).fill().map(el => Array(m+1).fill(0));\n    let max = 0\n    for (let i = 1; i<=n; i++) {\n        for (let j = 1; j<=m; j++) {\n            if (matrix[i-1][j-1] !== '1') continue;\n\n            dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1],dp[i-1][j-1]) + 1;\n            max = Math.max(max, dp[i][j])\n        }\n    }\n    return max*max\n\n};"", 'the best question if we do repeated works if we can slice it into subproblem', ""Java code: \n\nimport java.util.Arrays;\n\npublic class MaximalSquare {\r\n    static int ROWS;\r\n    static int COLS;\r\n    static char[][] matrix;\r\n    static int maxLength = 0;\r\n    //Key: row, Value: column\r\n    static int[][] cache;\r\n    static int maximalDPTopDown(char[][] matrix) {\r\n        MaximalSquare.matrix = matrix;\r\n        ROWS = matrix.length;\r\n        COLS = matrix[0].length;\r\n        cache = new int[ROWS][COLS];\r\n        for(int i = 0; i < ROWS; i++) {\r\n            Arrays.fill(cache[i], -1);\r\n        }\r\n        helper(0, 0); //top left element\r\n        return maxLength * maxLength;\r\n    }\r\n    static int helper(int row, int col) {\r\n        //Base case\r\n        if(row >= ROWS || col >= COLS) {\r\n            return 0;\r\n        }\r\n        if(cache[row][col] == -1) { //True if NOT in the cache\r\n            int down = helper(row + 1, col); //Check Down\r\n            int right = helper(row, col + 1); //Right position\r\n            int diag = helper(row + 1, col + 1); //Check Diagonally\r\n            cache[row][col] = 0;\r\n            if(matrix[row][col] == '1') { //\r\n                //Takes the minimum off all of these 3 values: down, right and diag\r\n                cache[row][col] = 1 + Math.min(down, Math.min(right, diag));\r\n                maxLength = Math.max(cache[row][col], maxLength);\r\n            }\r\n        }\r\n        return cache[row][col];\r\n    }\r\n}"", '2D, bottom-up DP\nROWS, COLS = len(matrix), len(matrix[0])\r\n        dp = [[0] * (COLS + 1) for _ in range(ROWS + 1)]\r\n        maxLength = 0\r\n        for r in range(ROWS - 1, -1, -1):\r\n            for c in range(COLS - 1, -1, -1):\r\n                if matrix[r][c] == ""1"":\r\n                    dp[r][c] = 1 + min(dp[r][c + 1], dp[r + 1][c], dp[r + 1][c + 1])\r\n                maxLength = max(maxLength, dp[r][c])\r\n        return maxLength ** 2\n\n1D:\nROWS, COLS = len(matrix), len(matrix[0])\r\n        dp = [0] * (COLS + 1)\r\n        maxLength = 0\r\n        for r in range(ROWS - 1, -1, -1):\r\n            nextDP = [0] * (COLS + 1)\r\n            for c in range(COLS - 1, -1, -1):\r\n                if matrix[r][c] == ""1"":\r\n                    nextDP[c] = 1 + min(nextDP[c + 1], dp[c], dp[c + 1])\r\n            curMax = max(nextDP)\r\n            dp = nextDP\r\n            maxLength = max(curMax, maxLength)\r\n            \r\n        return maxLength ** 2', 'There is a way to deconstruct this problem into 1D (maximal area of a histogram) and then find the max of those results as our final area.']"
322,XVuQxVej6y8,"['Linked List Playlist: https://www.youtube.com/watch?v=G0_I-ZF0S38&list=PLot-Xpze53leU0Ec0VkBhnf4npMRFiNcB&index=1', 'Two pointers approach is still 2 pass solution, but we are doing these passes simultaneously)', ""but, what's the different from count the list size = N first then count it again for N - n? for both the solution , the time complexity are O(N)"", ""you're him"", 'Very good explanation', 'dummy = ListNode(0,head)\nright = head\n\nDoes this Linked List has 2 heads? \nHow does the program know that the dummy ListNode is a placeholder?', ""is the 'and right' in the while loop condition necessary?"", 'I did it in one pass using a hash map, but I guess the space complexity was O(n)', ""if n=4 and length==6 \r\n it work i do'nt understand \r\nslow.next=slow.next.next;\r\nplz solve my doubt"", ""Dummy node is actually not required if we run the loops till 'while right.next'. The reason we are using a dummy node is to handle the special case when we have to remove the first (head) node in a list of length 2""]"
323,LHweCQVw9gk,"['I would have used windowing functions for this.', 'Different from my approach, but I liked reviewing your logic/thinking.', ""SELECT Department, Employee, Salary\nFROM\n(\nSELECT D.Name as Department, E.Name as Employee, E.Salary as Salary,\n    DENSE_RANK () OVER (PARTITION BY D.Name ORDER BY E.SALARY DESC) as 'Rank'\n    FROM Employee as E\n    JOIN Department as D ON D.Id=E.DepartmentId\n) as A\nWHERE A.Rank <= 3"", 'I recommend understanding this SQL question first: https://youtu.be/FSSKteJmWMs']"
324,FSSKteJmWMs,"['Hello Neetcode, are you going to solve SQL problems agains? Thank you', 'Why did we use IFNULL to output NULL.? I mean IFNULL takes in NULL and gives some other output. Whats the point of giving NULL as an input to IFNULL and then taking NULL as the output?', 'nvl(select salary \r\nfrom (select* from employee order by salary desc)\r\n    where id=2,NULL)  secondHighstSalary;\r\n\r\n I do this but cannot work keep that I using oracle', 'So well explained. Thank you.', 'Amazing explanations']"
325,JI71sxtHTng,"['Linked List Playlist: https://www.youtube.com/watch?v=G0_I-ZF0S38&list=PLot-Xpze53leU0Ec0VkBhnf4npMRFiNcB&index=1', ""what do you think of this Python solution? I know it's O(n) time and space complexity but this was my first attempt :) \n\n        nums = [ ]\n        dummy = ListNode()\n        current = dummy \n\n        while head:\n            nums.append(head.val)\n            head = head.next\n\n        for num in nums:\n            if num != val:\n                current.next = ListNode(num)\n                current = current.next\n\n        return dummy.next"", 'Done thanks\nUsing 3 pointers, current, previous and next\nUse a dummy node as head so the logic can be straightforward (avoids handling edge case of deleting the head of the list)\nInitialize prev to the dummy node, curr to head of list and next to node after it\nPitfall:-\nWhen you delete a node, move forward current and next pointers while keeping previous in place\n\nRemember that you have a dummy head node so when returning the new list head you give dummy.nxt', 'nice explaination😄', 'thanks a lot', 'If the node you are removing is the head, why would you not just make the head the next element and then nothing changes except the previous head falls off the linked list?', 'How ugly is your pronounciation.', 'For JAVA people \n\nclass Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        ListNode dummy = new ListNode();\n        ListNode prev = dummy;\n        dummy.next = head;\n        ListNode curr = head;\n        while(curr != null )\n        {\n            if(curr.val == val)\n            {\n                prev.next = curr.next;\n            }\n            else\n            {\n                prev = curr;\n            }\n            curr = curr.next;\n        }\n        return dummy.next;\n         \n    }\n}', 'Teşekkürler!', 'I don’t understand why he had while curr: as the while loop. Can someone please explain this to me?']"
326,G0_I-ZF0S38,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'Would another valid solution be to create a new head node. And continuously pop the first node from the original list and push front to the new list until the original  head is null. Then return the new head. Wouldn’t this also have a TC of O(n) and SC of O(1)? Please if I am mistaken I appreciate any corrections, I am new to learning data structures. Thanks!', ""Nice answer . multiple new_head assignment is bit confusing.\n\npractically, if head is null(in case of empty list) or head.next is null will marked as root.\n\nso we can easily stop recursion at last node and keep reversing list without much confusion. \nthis approach has similar time and space requirements(in terms of leet code as well as big oh. infact it's quite better).\n-------------------------- code below ---------------------------\n public ListNode reverseList(ListNode head) {\r\n        if(head == null || head.next == null ) return head;\r\n         \r\n        \r\n            ListNode newHead = reverseList(head.next);\r\n            head.next.next = head;\r\n            head.next = null;\r\n        \r\n        return newHead;\r\n    }\n-------------------------------------------------------------------------"", 'the hardest thing to grasp here is how you return a new head while manipulating the existing linked list. its giving me a headache. this is one of those solution where i would say recursion is not the ideal method for it.', 'Shouldn\'t the recursive solution begin with ""while head.next"" instead of ""if head.next"" - otherwise the branch executes once?', 'For your recursive solution, why is the memory complexity O(n)?', 'I completed this without any help in just 4 hours😅', 'Thanks!', ""class Solution:\n    def reverseList(self, head: ListNode) -> ListNode:\n        # Recursive answer\n        # Base case: If the list is empty or has only one node, it's already reversed.\n        if not head or not head.next:\n            return head\n\n        # Recursive call to reverse the remaining part of the linked list. Break it down to sub problems to keep reversing.\n        # reversed_head will be the head of the reversed linked list for the rest of the nodes.\n        reversed_head = self.reverseList(head.next)\n\n        # At this point, head.next points to the next node in the original list, which will be the last node\n        # in the reversed linked list. We need to make the next node point to the current head node, effectively reversing the link.\n        print(head.next.next)\n        head.next.next = head\n        print(head.next.next.val)\n\n\n        # Set the current head's next pointer to None, as it will be the last node in the reversed linked list.\n        head.next = None\n\n        # Return the new head of the reversed linked list (reversed_head).\n        return reversed_head"", 'Can someone explain the recursive code']"
327,7ABFKPK2hD4,"['LFU Cache: https://youtu.be/bLEIHn-DgoA\n\n🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'waste of memory code', 'What is the need for a previous pointer (MRU) for this question? We only need to have the pointer for the LRU right?', '#Easier(for me) solution using an OrderedDict (Python)\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n            return self.cache[key]\n        else:\n            return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        else:\n            if len(self.cache) == self.capacity:\n                self.cache.popitem(last=False)\n            \n        self.cache[key] = value', ""I think this is one of the most insane questions I've ever tried lol"", ""I hate it when Hard questions get bumped down to Medium just because they're popular and/or they're known to be asked by famous companies. As someone who's in the middle of a career break and one job away from changing careers away from the IT world in general, this is probably leetcode's biggest shortcoming."", 'never would have thought to use a doubly linked list🤦\u200d♀thanks for the explanation!!', 'reminder to me -  have two separate data structures (hashmap for constant look ups and DLL for updating MRU, LRU) which are updated simultaneously with remove / insert helper functions in the DLL.', 'Awesome, thx! It amazes me how clear and easy it gets after explanation, yet how complicated it seems (and actually is) when you have to solve this in a stressful limited time environment like in an interview. One note though - in case if key is already present in cache in insert function, before inserting node itself, we should return before doing len(cache) > capacity check, this way we get quite a significant optimization by not doing redundant heavy logic. Another note would be to add a current count property to LRUCache to not execute len(cache) at all and reduce time complexity from O(n) to O(1).', 'Should easily be able to solve ""mediums"" they say... lol']"
328,1pkOgXD63yU,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'thanks !  but i have a suggestion to  change l += 1 to l = r,  you can try the case [ 1, 6, 7, 3, 0, 9 ],  use l += 1 then will get 6 but use i = r get 9 (Ans)', 'class Solution:\r\n    def maxProfit(self, prices: List[int]) -> int:\r\n        l,r = 0,1\r\n        maxp = 0\r\n        while(r < len(prices)):\r\n          if prices[l] < prices[r]:\r\n             profit =prices[r] - prices[l]\r\n             maxp= max(maxp,profit)\r\n          else:\r\n             l = r\r\n\r\n          r = r + 1\r\n        return maxp \r\n\nit should be l =r', 'what is the time and space complexity of this problem?', 'Thanks for the explanation \nI have a follow-up question \nWhich set to select in case of\n[ 7,2,4,1,3]', 'x = [7,1,5,3,10,4]\n\nmax_profit = 0\nfor i,j in enumerate(x):\n    try:\n        if max(x[i+1:]) - j > max_profit:\n            max_profit = max(x[i+1:]) - j\n    except:\n        break\nprint(max_profit)', 'Awesome work bro. Good explanations for complex algorithms. 🖥️', ""I found this solution a bit confusing. You don't need two pointers. You never use the left pointer for anything except looking up the price (i.e. there's no pointer math), so you could have just stored the minimum price itself instead of a pointer to the minimum price."", ""hey Thanks for your content-- it's been helping me a lot. I have a question about this problem\nI was a bit confused in the beginning because I was trying to solve it with slide window but then I watched your explanation and I could see that it's actually two pointers. As I know slide window is when the window a fixed size, but I can see here that the window can grow as soon as you are moving the right pointer. Help me out here, is this also considered slide window?  Thanks for your help"", 'Well, this is incorrect solution:\nTake input like [3, 14, 15, 2, 5]\nOutput Should be buy day 1 and sell day 3\nBut your solution will give buy at day 4 and sell at day 5\n😅']"
329,s7AvT7cGdSo,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'def permute(self, nums):\r\n        resultList = [] \r\n        self.backtrack(resultList, [], nums)\r\n        return resultList\r\n    \r\n    def backtrack(self, resultList, tempList, nums):\r\n        if len(tempList) == len(nums):\r\n            resultList.append(list(tempList))\r\n            return\r\n        \r\n        for number in nums:\r\n            if number in tempList:\r\n                continue\r\n            tempList.append(number)\r\n            self.backtrack(resultList, tempList, nums)\r\n            tempList.pop()', 'Love everything you have done but this honestly should be a 25-min video', 'I’m having trouble understanding the code. I get the drawing but coding it is so much harder', 'what will be the time and space complexity for this?', ""Thank you so much man !! Please don't delete this videos"", 'Here is a simpler solution that goes very well with the pen and paper method explained in the video to keep things consistent. Cheers!\n\n```\nclass Solution:\n\tdef permute(self, nums: List[int]) -> List[List[int]]:\n\t\tif len(nums)==1:\n\t\t\treturn [nums]\n\t\tresult = []\n\t\tfor i in range(len(nums)):\n\t\t\tremaining = [j for j in nums if j!=nums[i]]\n\t\t\tcurrent_permutation = [nums[i]]\n\t\t\tself.dfs(remaining, current_permutation, result)\n\t\treturn result\n\n\tdef dfs(self, remaining, current_permutation, result):\n\t\t# base case\n\t\tif len(remaining)==1:\n\t\t\tcurrent_permutation.extend(remaining)\n\t\t\tresult.append(current_permutation.copy())\n\t\t\treturn\n\t\t# take a decision for each remaining element\n\t\tfor j in range(len(remaining)):\n\t\t\tnew_remaining = remaining[:j]+remaining[j+1:]\n\t\t\tself.dfs(new_remaining, current_permutation+[remaining[j]], result)\n```', 'I still dont get it how u come up with these brilliant ideas?! When i see your solution, i wonder why i dont come with this idea if its so easy? haha\nThanks brother!!', ""im getting this error.\n    for perm in perms:\r\n                ^^^^^\r\nUnboundLocalError: cannot access local variable 'perms' where it is not associated with a value"", 'i have spend 15 minutes. I was close but not enought in coding.']"
330,P1Ic85RarKY,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'can anyone explain me last line of code? would not while loop also work for the leftovers too? just like 3,2 swapping position ?', 'Thank you very much 🤩', 'how about this solution? : \ndef mergeSortedArray( lst1 :list, lst2 :list) -> list :\r\n        return [item for element in list(zip(lst1,lst2)) for item in element]', 'i dont understand yet, why is there nums1[m] if m is number of element.. which is suppose to be out of bounds,  since array starts counting from 0.', ""last = m + n - 1 don't make any sense to me bc m ist the index of last value of nums1 and n is the index of last value auf nums2. So considering the example from the vid m would be 2 and n would also be 2. So 2+2=4 which is not the last index of m"", 'Amazing explaination, but how is this an easy problem?', ""it's medium level probkem"", 'Definitely you are genius', 'Line 18 in the end should say nums1[last] = nums2[n-1] , no ?']"
331,yOzXms1J6Nk,"['Linked List Playlist: https://www.youtube.com/watch?v=G0_I-ZF0S38&list=PLot-Xpze53leU0Ec0VkBhnf4npMRFiNcB&index=1', ""class Solution:\r\n    def isPalindrome(self, head: Optional[ListNode]) -> bool:\r\n        s = ''\r\n    \r\n        \r\n        while head:\r\n            s += str(head.val)\r\n            head = head.next\r\n\r\n        print(s[::-1])\r\n\r\n        if s == s[::-1]:\r\n            return True\r\n        else:\r\n            return False"", 'This is the middle of a linked list + Reverse a linked list', 'i thought reversing the LL can be a solution but also thought that changing the whole data structure is not good!', ""There is slight difference between this question and reorder list question. In both of them we find middle, reverse second half, but in reorder list question we slice both lists, in this question we don't need that.\n\nIf anyone asks why both left and right list has common node but it doesn't throw error, because we go until right is null.\n\nThis is not the same case as Reorder List problem, in that problem we have to slice list, we must go until both of lists, therefore we shouldn't have any common node."", ""I'm curious how to make sure the slow pointer stops at the midpoint by shifting the left pointer twice and shifting the slow point once?"", 'Do we need to restore the list after checking palindrome?', 'Thank you for the good video. but I feel this is better watched together with one of your other video on reversing a linkedlist : https://www.youtube.com/watch?v=G0_I-ZF0S38&t=2s', 'FANTASTIC. Thank you!', 'After 7:40 it sorta just went over my head. Can anyone help?']"
332,emNkJGwcusQ,"['Actually in Java you can iterate over key/value pairs of hashmap too, using map.entrySet() method instead of map.keySet(), but still the syntax is not so concise as in Python for sure', ""I'm thinking about learning some python because Im interested in machine learning. So far I only know java and sql"", 'No java leetcoders were harmed in this video', ""I am full blown machine learning engineer. I don't know why I am still watching this video lol"", 'why no one talks about the my hero academy reference ""ah yes I like Detroit""', ""Java is more verbose, but that's a good thing to me, it's like more clear to me. Also, I like the WORA philosophy."", 'This make me watch MHA once again.', ""I'm glad I learned Java first. It would be really hard to learn Java after learning Python first"", 'Hi sir \nAs we know python is Comparatively slow because of its dynamically typing nature, being interpreted language and Global interpreter lock by garbage collection and also to tackle such issues we have like C extensions, threading and multiprocessing modules, Numba JIT, \n\nthere is no one such standard python developer best practice to write the code which could match the speed of java and c++ a bit closer. \n\nSo you being a python developer in such a big company,could you please share some standard applied practices to make the python code faster and make ourself feel we are confident about our preferred choice of programming language.. \n\nThanks in advance', 'I was comfortable with python earlier and used to code in python as its very easy to code. It helped me build ml models too.But my company told me to learn java/cpp as it is more useful there. Now i forgot python and coding in java and feeling bad as i missed python 😔.']"
333,K-RYzDZkzCI,"['💡 BINARY SEARCH PLAYLIST: https://www.youtube.com/watch?v=U8XENwh8Oy8&list=PLot-Xpze53leNZQd0iINpD-MAhMOMzWvO', 'Very well explained like why we should left, why not right??\nThanks a lot❤', '1 liner:\nimport bisect\n\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        return bisect.bisect_left(nums, target)', ""i would have never come out with this lol.   Maybe, i would have studied computer science and all i did was code and learn a gang of techniques and thrive to always come out with new ways to make algorithms ran faster and more efficient...crazy, respect to you mah software engineeris, programmers or whatever you are.  honestly , im happy with iteration throught the entire loop lol   Doesn't that make more sense haha.  jk, ima memorize this technique like people memorize Maradona and Magico Gonzales tricks and then show the world"", 'great explanation. Very appreciate!!', ""I don't understand the return L part."", 'Approach\nThe problem is little bit modified when compared to finding the floor/ceil of an element using binary search. Usually to find the floor,(Here I am assuming you know the basic binary search concept of finding the floor and ceil) we consider the rightmost search space.\n\nif(nums[mid]<=target){\n//search to right(normal binary search)\nresult = mid;\nlow=mid+1;\n}else{\nhigh=mid-1;\n}\n\nthe above code snippet finds the floor of an element. But in the problem,we need to find the exact insert postiion,where the element should have been at. Considering floor, it is the MAXIMUM ELEMENT SMALLER THAN TARGET.\nfor eg., floor of 5 is 4. the array contains {1,2,3,4,6,7,8}; so technically, 5 must be inserted next to 4, which is index 4. The index of our floor is 3. So 5 will be inserted right next to the floor, which is index of floor + 1.\n\n\n\n\n\n\nJAVA CODE ------------------------------\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int n = nums.length;\n        int low=0;\n        int high=n-1;\n        int res=0;\n\n        while(low<=high){\n            int mid = low + (high-low)/2;\n\n            if(nums[mid]==target){\n                return mid;\n            }\n            else if(nums[mid]<=target){\n                res=mid+1;\n                low=mid+1;\n            }\n            else if(nums[mid]>=target){\n                high=mid-1;\n            }\n        }\n        return res;\n    }\n}', 'Not me patching up six conditions like the transformers in Transformers 2 that joined together to barely crawl pass through the finish line and guy just does a regular binary search QAQ', 'Thanks you!', ""One o' the best LeetCode channels in YT""]"
334,ljz85bxOYJ0,"['1 % 10 = 1 not 0 \n8:24', 'code in C++:\n\r\n    int sumOfSq(int n ){\r\n\r\n        int sq =0;\r\n\r\n      while(n > 0){\r\n                int ls = n%10;\r\n                sq += ls*ls;\r\n                n /= 10;\r\n        }\r\n      \r\n      return sq;\r\n\r\n    }\r\n\r\n    bool isHappy(int n) {\r\n\r\n        if(n == 1){\r\n            return true;\r\n        }\r\n\r\n        unordered_set<int> hset;\r\n        while(!hset.count(n)){\r\n            hset.insert(n);\r\n            n = sumOfSq(n);\r\n\r\n            if(n==1 ){\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }', ""THE REAL HAPPY NUMBER WAS FOUND\nit's 7\n\nthis code will work no need in set or slow/fast pointer\n\nconst isHappy = function(n) {\n    let number = n\n    let square = 0\n\n    while (number >= 10) {\n        while(number > 0) {\n            square += (number % 10) ** 2\n            number = Math.floor(number / 10)\n        }\n\n        number = square\n        square = 0\n    }\n    \n    // 7 is real happy number :)\n    return number === 1 || number === 7\n};"", ""As someone else in the comments pointed out, if the numbers never cycle to 1, they do cycle back to 4. \n\nMy code basically devolves into doing the process and checking if the number is 4, and to return false if so. It usually takes about 5-10 iterations at most.\n\nI observed the result of a few inputs and got confused as to why all the solutions on LC are with hashmaps, recursion, floyd's algo and so on.. I thought it was labeled easy because you just had to find a loophole in the problem or something 💀💀"", 'for your kind information 37 would be 3*3+7*7=58 not 30  (3:20)', ""how do you know that we always get a cycle? I understand that it's true, but what was your intuition?\n without knowing this as a complete fact this question is not solvable. unless there's a nice way to prove it using this fact as a guest without proving feels like cheating..)"", '1%10 = 1 not 0', '37 -- 9 + 49 -- 58, you did 7* 3 instead of 7*7 lol', '3 squared plus 7 squared is 58 not 30, https://youtu.be/ljz85bxOYJ0?t=197', 'I think this was one of the early videos on your channel.  I have to say your skills grow up a lot after two years!! Still appreciate the content!']"
335,UuiTKBwPgAo,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'shouldnt the first value of ""res"" be 8 not 7?', ""I'm actually curious what program or accessory you use to get those nice see-through brush drawings on the screen. Care to share? Peace."", ""I am quite annoyed by the fact that I was able to come up with the optimal solution for this problem, but still couldn't quite explain if this would be correct for all cases, and after watching your video I still can't explain why this works for all valid cases\nCan someone help me with this?"", 'What if the condition of updation of l and r be like..-\nif(height[l+1] >= height[r-1]) l++;\nelse r--;\nIt is working but is it a correct logic??', 'Is this an edge case that doesnt work? The most left height is lets say 9, the second index is 100, everything else is 8. How would you get the output to be 100 and the most right 8', 'Dude you didnt really explain your solution', 'I came up with the same solution after doing some two pointer problems in neet code 150. I knew this was a two pointer solution beforehand. How do i know what kind of problem it is?', ""This problem isn't something you can easily solve by intuition; you need to approach it logically. If you understand what I'm about to explain, it'll be a lot easier to grasp future problems that involve divide-and-conquer or two-pointer methods.\n\nImagine you have two bars, 'a' and 'b', at the ends of an array. Your optimal solution is going to fall into one of four categories:\n\nBoth 'a' and 'b' are part of the optimal solution.\nOnly 'a' is part of the optimal solution.\nOnly 'b' is part of the optimal solution.\nNeither 'a' nor 'b' are part of the optimal solution.\nSo if we have a function foo() that takes a 1D array of heights and returns the best solution, then the answer would be the max value among: 1 * min(length of 'a', length of 'b'), foo(0 to count-2), foo(1 to count-1), or foo(1 to count-2).\n\nHere's where it gets really interesting. You could solve this recursively, but that's not efficient. Instead, we can use two pointers to reduce time complexity. If one of the bars is shorter, it doesn't matter how long the other bar is. The max area that could involve the shorter bar is only 1 * min(length of 'a', length of 'b'). So, you should move the pointer from the shorter bar, basically taking it out of consideration.\n\nThis is why the final answer would be max(1 * min(length of 'a', length of 'b'), foo(array without the shorter bar)). This speeds things up a lot! And then you can think it as two-pointer that moves only one pointer."", ""Very bad explanation. why should your second approach work? You just presented a solution that you have across online. Didn't even try to give an intuitive explanation and even why it should work.\n\nDon't encourage this kind of work.""]"
336,SVvr3ZjtjI8,"[""🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤\n\nI didn't mention this but using Python helped me a lot because you can write MUCH less code. I know most schools teach Java/C++, mine did as well, but i would highly recommend a language like Python/Javascript.\nHere's a short video highlighting the benefits of Python: https://youtu.be/emNkJGwcusQ"", ""One thing you can also do is after completing a problem you can see code ranked by memory space and speed. Check out the high results for both, and don't just take the first one but look through them as there is usually a very streamlined approach that handles it while also being very readable. On several of those problems where I resorted to array lists or sets, simple array manipulation was used and was very well thought out."", ""I never thought about the spreadsheet and it's such a great idea."", 'tl;dr he did a lot f coding interview questions', ""I've solved the 2:21 problem on my 3rd year of college xd\nTook me 2 weeks lol"", ""leetcode worst don't waste time on leetcode shit"", 'you r a GOAT', 'If you ever get an extremely hard coding question your ""interview"" was rigged from the start', 'Can you please share the spreadsheet again? the old link is not working.', ""Where's the spreadsheet please?""]"
337,q5a5OiGbT6Q,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'Great video! Does the mergedLists variable take up O(K) memory complexity?', 'if you implemented the merge 2 lists, we can just start merging from reverse order and remove the merged row from lists:\n        while len(lists) > 1: \n            lists[-2] = merge(lists[-1], lists[-2])\n            lists.pop()\n        return lists[0]\nor this option seems better:\nwhile len(lists) > 1: \n            for i in range(len(lists)//2):\n                lists[i] = merge(lists[i], lists[-1])\n                lists.pop()  \nreturn lists[0]', 'great explanation! Very clear and concise!', 'From 2023.9.24 this solution will result in TLE, I am assuming the dummy node initialization and the merging of the two lists is much more inefficient than the priority queue. Any comments?', 'You are the legend. Thank you for your job', 'Can you also focus on the space complexity while solving a question please', 'divide and conquer is used to iterate on the O(nk) approach of merging one by one\n\nfor each step, `n` nodes (all of them) are compared during the merge process -- O(n)\n\nat the end of each step, the number of lists that need to be merged has been halved\n\ntherefore the number of iterations needed is the number of times you can halve `k` until you get to 1. that is `log k` (base 2). so each step will be done `log k` times -- O(log k)\n\nthus the time complexity is O(n log k)', 'the most straighforward intuitive approach is.\njust iterate through all the linked list and get their values append those values to a list.\nthen sort.\nthen just convert the combined sorted list to a linked list.\n\nthere were no restrictions so its the simplest approach.\n\nthat approach beats 80% of python submissions', 'Whats the space complexity?']"
338,XIdigk956u0,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'this is the new updated solution:\n\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode()\n        tail = dummy\n\n        while list1 and list2:\n            if list1.val < list2.val:\n                tail.next = list1\n                list1 = list1.next\n            else:\n                tail.next = list2\n                list2 = list2.next\n        \n            tail = tail.next\n\n        if list1:\n             tail.next = list1\n        elif list2:\n             tail.next = list2\n            \n        return dummy.next', ""I don't understanding the last part, you only assign tail.next=l1; this will only take one number from l1? it's not a loop"", 'Hi Neetcode,what do you mean by dummy=listnode?? do you mean listnode(none)?', 'I don’t understand the point of dummy and why it helps in edge cases, also won’t this list have just an empty node in the dummy node which increases the size of the list?', 'At the start of the solution, why hasn\'t he just written ""tail = ListNode()""...???', ""how do u solve the problem without a dummy node? I'm still kind confused abt the dummy node"", 'Can someone tell me why this is wrong? Trying to understand how linked lists work..          class Solution(object):\n\n    def mergeTwoLists(self, list1, list2):\r\n        dummy = ListNode()\r\n        f = dummy\r\n\r\n        while list1 and list2:\r\n            if list1.val < list2.val:\r\n                f = list1\r\n                list1 = list1.next\r\n            else:\r\n                f = list2\r\n                list2 = list2.next\r\n            f = f.next\r\n\r\n        if list1:\r\n            f = list1\r\n        elif list2:\r\n            f = list2\r\n        \r\n        return dummy', 'understood', 'love your content boss glad i found your channel!']"
339,wgFPrzTjm7s,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'When was dummy head ever updated in the code? Please help!', 'Inspirational first line', 'Thank you !!!', '', 'NC: You do probably remember how to add two numbers together\nMe: You severely overestimate my abilities', 'its interesting how you build the answer after the dummy node and return the answer. Its not like the test cases can detect the dummy node', 'Can someone explain the dummy listnode and how changing in cur changes dummy?', ""what's the function of next and val do?"", 'There is a VERY simple solution.\nSimple go through both lists and for each one create a string with the values.\nThen reverse both strings, convert them to int and add them together.\nThen convert that to a string and go through each char and create a new Node in the new LL, still O(n)\n\ndef addTwoNumbers(l1: ListNode, l2: ListNode) -> ListNode:\n\n    # treat them as string and reverse them\n    s1 = """"\n    cur = l1\n    while cur:\n        s1 += str(cur.val)\n        cur = cur.next\n\n    s2 = """"\n    cur = l2\n    while cur:\n        s2 += str(cur.val)\n        cur = cur.next\n\n    s1 = s1[::-1]\n    s2 = s2[::-1]\n\n    # Calculate the new number\n    res_string = str(int(s1) + int(s2))\n    \n    # Reverse it\n    res_string = res_string[::-1]\n\n    # Create the new LinkedList\n    dummy = ListNode(-1)\n\n    prev = dummy\n    for char in res_string:\n        cur = ListNode(int(char))\n        prev.next = cur\n\n        prev = cur\n\n    return dummy.next']"
340,XYQecbcd6_c,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'why use resLen instead of len(res)), Is there any difference?', '', ""This is two pointer problem instead of DP problem no?\nIt doesn't really solve subproblem and does not have recurrence relationship. The category in the Neetcode Roadmap got me. I spent quite a while trying to come up with the recurrence function but no avail :D"", 'but can you do it in O(n) time?', 'Says, ""we can write a function .. but I am lazy to do that"". However, types the whole thing again instead of Ctrl + c, Ctrl +v. Respect !!', 'How is this a dynamic programming question though. Seems more like sliding windows, no?', 'will it be possible to explain the even bit again', '@neetcode - a Quick Question --- where is the variable resLen being used?\nI meant I didnt see it contributing to the final res string..', 'Why is this a dynamic programming solution?']"
341,6jf6SK9qWBc,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews\n\nHow to get employed 101:\n1. Solve the problems in an intuitive order: https://neetcode.io/\n2. Visualize the problem (draw a picture, its so much easier)\n3. Maybe the first 50 questions take 50 hours, the next 50 questions will take 15 hours. You will be SHOCKED by how quickly you improve!', 'Goku for example Haha I love it', 'First 3 seconds of the video and I all I can think about ""is this guy is goated"".', 'Yes. I am goku now.', ""What is this program at 5:49? I know it's some drawing thing but which one?"", 'Hey @NeetCode, were you able to get a girlfriend?', 'Still working on getting a girlfriend, any leetcode you can recommend to help with that?', 'thank you so much', 'thanks man i really needed that', 'I too started with Two Sum, I think Three Sum is much in-depth and exhilarating if you ask me. 😏']"
342,xCsIkPLS4Ls,"['I have to tell you this man. I have seen lot of videos.. however your explanations always are the best. I hope you will keep doing this. Great work & Thank you.', 'more efficient python solution\n\nclass Solution(object):\r\n    def rotate(self, nums, k):\r\n        k = k%(len(nums))\r\n        nums[:] = nums[::-1]\r\n        nums[:k],nums[k:]=nums[:k][::-1], nums[k:][::-1]\r\n        return nums', 'for best java solution :-\n\nhttps://www.youtube.com/watch?v=UCPWl_32auE&t=553s', 'Thank you so much', ""why do we have to mod the res in each loop? shouldn't we find the total possibilities(res) and then mod it?"", 'A more efficient python solution\n\nclass Solution:\n    def numSubseq(self, nums: list[int], target: int) -> int:\n        nums.sort()\n        l, r = 0, len(nums) - 1\n        ans = 0\n        mod = 10**9 + 7\n        while l <= r:\n            if nums[l] + nums[r] > target:\n                r -= 1\n            else:\n                ans += pow(2, r - l, mod)\n                l += 1\n        return ans % mod', 'Thank you so much!', ""Where is the 2^2 coming from at 3:23? It's not very clear to me whats happening here. Can you explain the math behind that a bit more?"", 'the execution time is over 8000ms. probably leads an TLE.\nwe can change 2 ** (r - i) to be (1<<(r - i)) in python. That gonna save a lot of time.\nBTW, in python, x<<n means x * (2 ** n). x >> n means x / (2 ** n).\nAlso, we could use two ptrs to slove this problem, same idea with neetcode.\n\nclass Solution:\r\n    def numSubseq(self, nums: List[int], target: int) -> int:\r\n        # # 2 ptrs\r\n        # nums.sort()\r\n        # res = 0\r\n        # mod = int(10 ** 9 + 7)\r\n        # l, r = 0, len(nums) - 1\r\n        # while l <= r:\r\n        #     if nums[l] + nums[r] > target:\r\n        #         r -= 1\r\n        #     else:\r\n        #         res = (res + (1<<(r - l))) % mod\r\n        #         l += 1\r\n        # return res\r\n\r\n        # neetcode\r\n        nums.sort()\r\n        res = 0\r\n        mod = (10 ** 9 + 7)\r\n        r = len(nums) - 1\r\n        for i, left in enumerate(nums):\r\n            while left + nums[r] > target and i <= r:\r\n                r -= 1\r\n            if i <= r:\r\n                res += 1<<(r - i)\r\n\r\n        return res % mod', ""We don't need the for loop.\n\n        nums.sort()\r\n        l, r = 0, len(nums) - 1\r\n        MOD = (10 ** 9) + 7\r\n        res = 0\r\n        \r\n        while l <= r:\r\n            if nums[l] + nums[r] > target:\r\n                r -= 1\r\n            else:\r\n                res = (res + (2**(r - l))) % MOD\r\n                l += 1\r\n        return res % MOD""]"
343,wiGpQwVHdE0,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'Check Out This one:\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        temp = ans = """"\r\n        for i in s:\r\n            if i in temp:\r\n                temp = temp[temp.index(i) + 1:]\r\n            temp += i\r\n            ans = temp if len(temp) > len(ans) else ans\r\n        return len(ans)', ""While inside for doesn't make it O(n^2)??"", ""What wasn't immediately intuitive to me is that we can stop when the right pointer hits the end and not care about the left doing any more things (shortening I guess)."", ""Just curious, Wouldn't the space be O(1) because even in the worst case, we know for a fact that the size of the set is not going to exceed 26 assuming every character is lowercase. Essentially, it is not scaling with input size and hence, we can say it has constant space complexity."", 'one of the best explanation', 'Thanks a lot, great as always! I believe we can slightly improve by using the hashmap, instead of the set, to also keep track of the index where the character appeared last time so that we can instantly move the left pointer past that index, once the duplicate is found.', ""man so many of neetcode's solution on github is vandalised by ab12gu, \nneetcode's video solution is usually much better in terms of readability and more intuitive variable name but someone else comes and update the code and now the neetcode' site's solution is different to the video solution"", 'I watched this 3 times, still no idea how is it working :(', 'Thank you !!!']"
344,Jk16lZGFWxE,"['https://www.youtube.com/watch?v=OnSn2XEQ4MY&list=PLot-Xpze53ldg4pN6PfzoJY7KsKcxF1jg&index=1', 'your voice is so calm in this video =D', 'I like the example in the last part.', 'I thought it should add to a total result variable when node.left and node.right are absent rather than return straight up ?', 'Thankyouuuu', 'i did this by recursion\nint SumNumbers(TreeNode root)\r\n                {\r\n                    int temp = 0;\r\n                    int res = 0;\r\n                    void Recursion(TreeNode N)\r\n                    {\r\n                        temp = temp * 10 + N.val;\r\n                        if (N.left == null && N.right == null)\r\n                        {\r\n                            res += temp;\r\n                        }\r\n                        else\r\n                        {\r\n                            if (N.left != null) Recursion(N.left);\r\n                            if (N.right != null) Recursion(N.right);\r\n                        }\r\n                        temp /= 10;\r\n                    }\r\n                    Recursion(root);\r\n                    return res;\r\n                }', 'Thanks', 'The is a better constant memory solution', 'If you are a regular follower, you will love those key clicks sound from the keyboard. Could you please tell me what keyboard you are using? Thanks', 'Thank you so much']"
345,jzZsG8n2R9A,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', ""Funnily enough the solution you came up with doesn't consider the possibility a triplet doesn't exist to meet the conditions, nor does the problem specify a valid triplet always exists, however in the current version of the problem one of the examples indicates you should return an empty array if no valid triplets exist. However, when run through the test cases, the case where a valid triplet doesn't exist expects you to just return the input array(it happens to be length 3). Also they need to change the title of the problem I couldn't stop snickering"", 'A smaller version code with similar logic: \n        res = []\r\n        nums.sort()\r\n        for i, val in enumerate(nums):\r\n            l, k = i+1, len(nums) - 1\r\n            while l < k:\r\n                three_sums = val + nums[l] + nums[k]\r\n                if three_sums < 0:\r\n                    l += 1\r\n                elif three_sums > 0:\r\n                    k -= 1\r\n                else:\r\n                    if [nums[i], nums[l], nums[k]] not in res:\r\n                        res.append([nums[i], nums[l], nums[k]])\r\n                    l += 1\r\n        return res', ""@NeetCode why don't you move this question to sliding window in your 150 list. This is very similar to Best Time to buy and sell."", 'threesome))', 'Thanks a lot. You must have helped thousand, if not millions of people!', '@NeetCode if happen to read this again, may the almighty bless you and your family fam. I truly got my joy back!', ""Why didn't we solve it like the 'longest palindrome substring' problem?"", 'threesome, the sequel to the popular question twosome', 'but this solution will skip the [-1,-1,2] in the solution. accoring to the code. if a == nums[i-1] then continue, and nums[l] = nums[l-1] then l+=1\nthis will get skip or am i wrong?']"
346,Ox0TenN3Zpg,"['Dynamic Programming Playlist: https://www.youtube.com/watch?v=73r3KWiEvyk&list=PLot-Xpze53lcvx_tjrr_m2lgD2NsRHlNO&index=1', ""But where are we ignoring the similar the structures like 2->1->3 and 3->1->2 have same structures. Aren't we considering both of them?"", 'Recursion is bad and slow, we have to use dp', 'can someone explain how time Complexity is O(n^2) . I think it must be n!', 'I understand everything in the solution, except for the thing that why do we just multiply the values, I mean there can be other cases as well right?\nLet me elaborate, \nIf you draw the diagram for 5 nodes solution, for f(5) we have f(3)*f(1) is good, but the three on the left also have 4C3 choices right?', 'crisp explanation', 'thanks! for  line #13 - I would have think - root should go from 0 to node +1 ( even if left is None for root = 0 - there our some combinations that will result from the right side ?). what am i missing pls ?', ""The explainnation is so good ! you're an absolute legend"", 'DOUBT: line 6, numTrees[3]*numTree[1]. When we pick the last node as the root node we would have 3 values in the left subtree and 1 value in the right subtree. Why? Should we have 0 values in the right subtree? As we selected the last value as root then there will be no choices to make for the right subtree it would be just a null.', 'There is a mistake at line 6 I think. Thanks for the solution nevertheless']"
347,73r3KWiEvyk,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'WHERE IS THE RECURSION', 'MAN I LVOE YOUR VIDEOS!!!', 'In 2023 house robber is actually a medium problem', 'I still have a hard time understanding how the code addresses the adjacency constrain. Nothing in the code looks at the indexes, or tracks whether or not we have already robbed the index before the current one.', 'little correction, check for input [2,1,1,2]\n // Assuming all +ve values\r\nvar rob = function(nums) {\r\nif(!nums) return 0;\r\nif(nums.length == 1 ) return nums[0];\r\nif(nums.length == 2) return Math.max(nums[1], nums[0]);\r\n    \r\n    let rob1 = nums[0];\r\n    let rob2 = Math.max(nums[0], nums[1]);\r\n\r\n    for (let i=2; i< nums.length; i++) {\r\n        // Here we are \r\n        let temp = Math.max(rob1 + nums[i], rob2);\r\n\r\n        rob1 = rob2;\r\n        rob2 = temp;\r\n    }\r\n\r\n    return rob2;\r\n};', 'Poorly explained compared to most of your other great videos.', '8:40 ❤️❤️', '6:20 i think you meant to say house 4', 'the African-American problem']"
348,U8XENwh8Oy8,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews\n\nSearch in Rotated Sorted Array II - https://youtu.be/oUnF7o88_Xc', 'class Solution:\r\n    def search(self, nums: List[int], target: int) -> int:\r\n        \r\n        if target in nums:\r\n            return nums.index(target)\r\n        else:\r\n            return -1\n\n#sometimes my genius is almost frightening', 'What he\'s trying to say, is that if when you\'re in the middle the leftmost value is not less than you, then you know that a split/pivot has occurred.  If you detect that the left of middle is in split, he says that you\'re in ""the right sorted portion"", where by ""right"" he means ...\n\nHe explains at 1:57 ""Lets say the left side is exclusively greater than the right side, because that\'s what it means by rotating the array""\n\nSo he\'s just defining left and right in what is I think mostly WRONG and arbitrary logic to where ""in the left side"" means THE PART AFTER THE SPLIT POINT (OF LARGER NUMBERS) (which was actually the freaking right side of the number line before the split).\n\nLeft and right to him don\'t even have anything to do with left and right of center even though this whole thing revolves around a center number.\n\nHe even erroneously says at exactly 1:49 ""We took some pivot and then swap these halves around"".  *THEY ARE NOT HALVES*. WE\'RE LITERALLY IN A PROBLEM ABOUT HALVES AND MIDDLES AND HE\'S MISUSING THE WORD HALF TO NOT MEAN LITERALLY HALF.  They\'re just parts because the split isn\'t always in the middle!!!  This flawed and erroneous description is the entire basis of him calling everything left and right side; the entire explanation to everything and grokking his solution.  At 2:42 he erroneously misuses the term halves again! 🤦\u200d♂', 'Faster solution, no need for a min:\n        l, r = 0, len(nums) - 1\n\n        while l < r:\n            m = (l + r) // 2\n\n            if nums[m] < nums[r]:\n                r = m\n            else:\n                l = m + 1\n\n        return nums[l]', 'is problem ko solve karna Matlab Udta teer pichwade me lena', 'This doesnt seem to be working for non-distinct values', 'can not pass the testcase:nums =\n[3,1], targer = 1', 'I think of it like this:\n\nif mid > than R, everything left of mid is sorted\nif mid < than R, everything right of mid is sorted\n\nCheck if target would fall into the range of the sorted part, and if so move the L or R pointer to binary search that segment. Otherwise move to the unsorted segment and repeat:\n\ndef search(nums: List[int], target: int) -> int:\n    l, r = 0, len(nums) - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < nums[r]:\n            if nums[mid + 1] <= target <= nums[r]:\n                l = mid + 1\n            else:\n                r = mid - 1\n        else:\n            if nums[l] <= target <= nums[mid - 1]:\n                r = mid - 1\n            else:\n                l = mid + 1\n    return -1\n\nEDIT: I see that multiple people came up with this version already 👍', ""Does anyone else think declaring multiple python variables on one line feels/looks weird?  Like l, r = 0, len(nums) - 1  I'm used to it now, but for readability purposes I don't think I wanna use that in a technical interview."", 'I think using the inequality signs like this makes it a lot more intuitive:\n    def search(self, nums, target):\r\n        L, R = 0, len(nums) - 1\r\n\r\n        while L <= R:\r\n            m = (L + R) // 2\r\n\r\n            if nums[m] == target:\r\n                return m\r\n\r\n            # If the left half is sorted\r\n            if nums[L] <= nums[m]:\r\n                # If target is in the sorted left half\r\n                if nums[L] <= target < nums[m]:\r\n                    R = m - 1\r\n                else:\r\n                    L = m + 1\r\n            # If the right half is sorted\r\n            else:\r\n                # If target is in the sorted right half\r\n                if nums[m] < target <= nums[R]:\r\n                    L = m + 1\r\n                else:\r\n                    R = m - 1\r\n\r\n        return -1']"
349,pV2kpPD66nE,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'I think I might try marking the cells as visited by changing the ""1"" to another char such as ""v"". maybe that\'s why LeetCode did it as a string instead of number. then you don\'t need more memory with the set pairs.', 'I think neetcode mentions the directions wrong. [0, 1] -> right , [0, -1] -> left, [1, 0] -> below and [-1, 0]-> above', 'Great video!\nBtw we can optimize space by using grid itself to mark visited cells.\n\nAlso I like a recursion solution, it looks intuitive and clean. Check this out:\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n\n        def isIsland(i, j):\n            if not (0 <= i < len(grid) and 0 <= j < len(grid[0])) or grid[i][j] == ""V"" or grid[i][j] == ""0"":\n                return False\n\n            grid[i][j] = ""V""\n            \n            isIsland(i, j + 1)\n            isIsland(i, j - 1)\n            isIsland(i + 1, j)\n            isIsland(i - 1, j)\n\n            return True\n        \n        count = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if isIsland(i, j):\n                    count += 1\n\n        return count', 'u sound sad here :(', ""This is one is pretty easy to do once you've done the pacific waterflow"", 'this is water this is water this is water this is water this is water this is water this is water this is water this is water this is water this is water this is water this is water this is water this is water this is water this is water this is water..................................', 'wow', 'did anyone get the right output by using 2d list ?', 'what is the benefit to solving this with bfs instead of dfs? dfs seems easier to understand imo, maybe I just need to practice bfs more']"
350,5WZl3MMT0Eg,"['🚀 https://neetcode.io/ - A better way to prepare for Coding Interviews', 'So this is just like the stock trading profit maximization problem', 'How to slice that exact subarray???', ""Hi! Thank you for the video, it provided me with a few insights. One question, so this algorithm won't work if the array contains only negative numbers?"", 'what if all the numbers of the array are negative?', 'the only question i have \nhow the fuck you got the same runtime in the last two submit 😂😂😂😂', ""It's a medium question now 🤣"", ""I don't not fully understand the if (cursum < 0) part. why 0?"", 'Kadane devised this solution within a minute', ""They've asked for the divide and conquer approach, can u give that solution ?""]"
351,cQ1Oz4ckceM,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'I get that we can use this solution, but why don’t we use the Hashmap one pass solution? Is it because we occupy O(n) space and that isn’t optimal?', 'that task is medium rn', '@neetcode if happen to read this! THANK YOU FAM!', 'Which one js better the hashing way or this one?', 'I\'m shit at programming, so I\'d love to hear from someone if the solution I came up with actually works (memory wise its less efficient then the solution here guaranteed)\n\nMy solution is basically this:\n\nSubtract each number in the array from the target and save the result (probably in a hashmap with the key being the index) and if, at any point, the next number is equal to ine if the reaults, those are the correct numbers.\n\nSo basically ""Target - num[n] = result[n]"", result get saved, and if num[n+i] = result[n] thats the solution.\n\nLogically it makes sense, I have no idea if there is a proper (and efficient) way to code this though. Could someone tell me if that works?', ""my code TLE'd in c++\n\nclass Solution {\r\npublic:\r\n    vector<int> twoSum(vector<int>& numbers, int target) {\r\n        vector<int> ans;\r\n        int i=0;\r\n        int j=numbers.size()-1;\r\n        int sum=0;\r\n        while(i<j){\r\n        sum=(numbers[i]+numbers[j]);\r\n        if(sum==target){\r\n            ans.push_back(i+1);\r\n            ans.push_back(j+1);\r\n        }\r\n        else if(sum>target){\r\n            j--;\r\n        }\r\n        else if(sum<target){\r\n            i++;\r\n        }\r\n        }\r\n        return ans;\r\n    }\r\n};"", 'What would be the time complexity if i solved using hashmap?', 'dudeee whatttt this is so ginormous brain', 'So, in 2sum 2 as compared to 2sum, we use the fact that the array is sorted to take the best-case space complexity from O(n) to O(1).']"
352,KLlXCFG5TnA,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'x = [1, -2, 5, 10]\ntar = -1\n\nfor j,i in enumerate(x):\n    #print (tar-1, x[j+1:])\n    if tar-i in x[j+1:]:\n        print(j,x.index(tar-i))\n        break', 'What if we sort the array and use left and right approach', 'Do Three Sum!', 'Can someone explain to me why searching in the dictionary takes only O(1) ?', 'Someone please help me understand the difference between hashmap and hash set used in ""Contains Duplicate?""', 'sorry to ask this stupid question but what is the key for the hash map? is it the indexs? or the value?', 'What tool do you use to film the hand drawing?', ""Shouldn't the memory be O(n-1)"", 'In interview I was asked three sum question']"
353,zx5Sw9130L0,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤', 'Intuition -\n• If current item is lesser than previous => pop the previous item\n• Maintain a stack with 2 tuple => [index, height]', 'Watched 3 times, now it really clicked!\nIf two consecutive bars have the same height it will be hard to do expanding to left, but the first one will take care of the rectangle anyway.', 'I was so close to solving my first hard problem, One day i will become just as good as this guy', 'Honestly, this is one of your weaker explanations - i don\'t know why you started using word ""pop"" right at the start. We really need get the core idea first and then think of the stack to solve  it - stil great work  on explanation of algorithm/code but wish it was better on the intuition.', ""9:42 THE STACK SHOULD CONTAIN 1 INSTEAD OF 0!!! There's no need to switching the index"", ""What if the heights are all equal. How do you extend the later elements back since the whole loop won't run?"", ""My only doubt is, shouldn't it be i - index +1 at the end of line 10? if a rectangle extends from say index 0 to 1, i - index should only return 1 when it should be 2.."", 'Got it!!', ""Your explanation is so good, I didn't even have to look at the code solution!""]"
354,P6RZZMu_maU,"['🚀 https://neetcode.io/ - I created a FREE site to make interview prep a lot easier, hope it helps! ❤\n\n\nCorrection: at 8:13 the subtitle should read ""We could also initialize length=1""', ""I never used SET in my life during problem solving 😂 and now I'm giving it a try in every sequence problem that i come across. Genius👏"", 'In short: add to set. Set count = 0.Iterate, where num-1 not in set. Set curr_count=1. Set n as num. while n+1 is there in set, increment curr_count. Set count to Max of count and curr_count. Return count', 'I just want to say that the runtime you achieved is different now maybe because of changed test cases i get now a runtime of 377ms with your solution', ""This isn't the most optimal way to do this. If we instead look left and right and traverse both ways until we don't find a neighbor while deleting items from the set as we go, and once both left and right search end compare to the max, then repeat this on the remaining set until at start its len<max. This should be more efficient."", 'Why is this solution O(n)?  On average it seems like it should be pseudo-linear at least, but at each value you still have to loop through until you find a larger sequence', 'Wow, leetcode downgrade it into medium category?', 'why is a set easier?', 'its medium right? was ist hard before? lmaooo', 'Ths graph is a very good explanation on why we need to look for nums-1 in the hash set / set.']"
355,m17yOR5_PpI,"['💡 GRAPH PLAYLIST: https://www.youtube.com/watch?v=EgI5nU9etnU&list=PLot-Xpze53ldBT_7QA8NVot219jFNr_GI&index=2', ""In short: Create count variable to store count of change in direction required. Create an empty set named visited. Create set of the pairs named edges. Create map of all cities from 0 to given n and add their partner city to it's value in an array. Do a Depth First recursion, starting from 0. Add 0 to visited set and call recursion function by passing 0 as city. For each value, check if it is not in visited, then for each neighbour of the city check if there is no neighbour, city pair in edges, then increment count. Add neighbour to visited. Call recursion function by passing the neighbour as city. After the recursion return the count."", 'this solution is giving time limit exceeded now', 'Why do we add 0 to visited before calling the dfs(0)?', ""I found your videos about a week ago and found the explanations easy to understand and very helpful. It has quickly become a habit to come and check your channel when I'm stuck on LC"", 'class Solution {\n    Map<Integer,Set<Integer>> map = new HashMap();\n    Set<Integer> set = new HashSet();\n    Set<String> connects = new HashSet();\n    int rc = 0;\n    public int minReorder(int n, int[][] connections) {\n        for (int i=0;i<n;i++)\n            map.put(i,new HashSet());\n        for (int[] c : connections)\n        {\n            connects.add(c[0] +"" ""+c[1]);\n            map.get(c[0]).add(c[1]);\n            map.get(c[1]).add(c[0]);\n        }\n        set.add(0);\n        dfs(0);\n        return rc;\n    }\n    void dfs( int i) {\n        for (int neigh : map.get(i) ) {\n            if ( set.contains(neigh )) continue;\n            if ( !connects.contains(neigh+"" ""+i) )\n                rc++;\n            set.add(neigh);\n            dfs(neigh);\n\n        }\n    }\n}', 'why we need to take both the possibilities if its directed graph. why line 16 ?', 'Thank you! Awesome explanation!', 'really clean & intuitive solution. Well done.', ""BFS FYI:\ndef minReorder(self, n: int, connections: List[List[int]]) -> int:\r\n        '''\r\n        start at city 0\r\n        list the original edges\r\n        count the changes\r\n        '''\r\n        edges = {(a, b) for a, b in connections}\r\n        neighbors = {city: [] for city in range(n)}\r\n        \r\n        visit = set()\r\n        changes = 0\r\n        # connect all nodes\r\n        for a, b in connections:\r\n            neighbors[a].append(b)\r\n            neighbors[b].append(a)\r\n        \r\n        q = collections.deque([0])\r\n        visit.add(0)\r\n        while q:\r\n            city = q.popleft()\r\n            for nei in neighbors[city]:\r\n                if nei in visit:\r\n                    continue\r\n                if (city, nei) in edges:\r\n                    changes += 1\r\n                q.append(nei)\r\n                visit.add(nei)\r\n        return changes""]"
356,ZHjKhUjcsaU,"['Timestamps: \n0:00 - Conceptual brute force solution \n2:03 - Conceptual optimal solution \n6:03 - Coding optimal solution', 'I thought of suffix array and almost skipped the video but something stopped me and made me watch the whole solution and now after watching the solution I came to know i can save some space by not creating the suffix array seperately. Kudos 👏', 'In short: Iterate from end to start. Maintain Max m = -1. At each value, set Max at that element to be m, update m to be Max of current element and m.', 'class Solution:\n    def replaceElements(self, arr: List[int]) -> List[int]:\n        \n        # Brute Force will be use nested loops to compute right max num for each num in arr then TC = O(N*N) SC = O(1)!\n        # My Optimal Solution:-\n        \n        max = -1;\n        l = len(arr)\n        \n        for i in range (l-1, -1,-1):\n            # save cur num before updating it to right max number!\n            temp = arr[i]\n            \n            arr[i] = max;\n            \n            # update max if temp is greater\n            if temp > max:\n                \n                max = temp;\n                \n        return arr;\n    \n    # TC = O(N)  SC = O(1)\n        \n    My solution similar to neetcode without max()', 'this is an ""Easy"" excercise, can\'t imagine medium ones', 'I come from futur and I want to tell you that you will get a job at Google, Just Keep Going bro, much love <3 ^^', ""Better memory than 100% of solutions... you're truly a god of Leetcode"", 'your channel is awesome dude!', ""I'm embarrassed that I could not solve this easyass problem :////\nThank you for the solution"", ""shouldn't there be lst[-1] = -1 after the loop so that the last element is always -1""]"
